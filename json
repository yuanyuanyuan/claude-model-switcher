Project Path: claude-model-switcher

Source Tree:

```txt
claude-model-switcher
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ code2prompt.json
â”œâ”€â”€ config
â”‚   â”œâ”€â”€ app.conf
â”‚   â”œâ”€â”€ mcp.json
â”‚   â”œâ”€â”€ models.conf
â”‚   â””â”€â”€ providers.conf
â”œâ”€â”€ docs
â”‚   â”œâ”€â”€ claude-code-cli-reference.md
â”‚   â”œâ”€â”€ claude-code-github-actions.md
â”‚   â”œâ”€â”€ claude-code-hooks-guide.md
â”‚   â”œâ”€â”€ claude-code-hooks.md
â”‚   â”œâ”€â”€ claude-code-interactive-mode.md
â”‚   â”œâ”€â”€ claude-code-mcp.md
â”‚   â”œâ”€â”€ claude-code-memory.md
â”‚   â”œâ”€â”€ claude-code-sdk.md
â”‚   â”œâ”€â”€ claude-code-settings.md
â”‚   â”œâ”€â”€ claude-code-slash-commands.md
â”‚   â”œâ”€â”€ claude-code-statusline.md
â”‚   â”œâ”€â”€ claude-code-sub-agents.md
â”‚   â”œâ”€â”€ claude-hooks-fix-report.md
â”‚   â”œâ”€â”€ deepseek-anthropic-api.md
â”‚   â”œâ”€â”€ deepseek-function-calling.md
â”‚   â”œâ”€â”€ deepseek-pricing.md
â”‚   â”œâ”€â”€ moonshot.md
â”‚   â””â”€â”€ statusline-configuration-complete.md
â”œâ”€â”€ install.sh
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”œâ”€â”€ config_loader.sh
â”‚   â”‚   â”œâ”€â”€ logger.sh
â”‚   â”‚   â””â”€â”€ validator.sh
â”‚   â”œâ”€â”€ installers
â”‚   â”‚   â”œâ”€â”€ claude_installer.sh
â”‚   â”‚   â””â”€â”€ nodejs_installer.sh
â”‚   â”œâ”€â”€ managers
â”‚   â”‚   â””â”€â”€ model_manager.sh
â”‚   â””â”€â”€ utils
â”œâ”€â”€ main.sh
â”œâ”€â”€ memory-bank
â”œâ”€â”€ templates
â””â”€â”€ tests
    â”œâ”€â”€ bdd
    â”‚   â””â”€â”€ test_user_scenarios.sh
    â”œâ”€â”€ integration
    â”‚   â””â”€â”€ test_installation.sh
    â”œâ”€â”€ results
    â”‚   â””â”€â”€ test_report.txt
    â”œâ”€â”€ temp
    â”œâ”€â”€ test_runner.sh
    â””â”€â”€ unit
        â”œâ”€â”€ test_logger.sh
        â””â”€â”€ test_validator.sh

```

`claude-model-switcher/CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ğŸ—ï¸ Project Overview

**Claude Model Switcher v5.0.0** - A modular, configuration-driven Claude Code installer and multi-model management system with comprehensive testing support.

### Architecture Characteristics
- **Modular Design**: Single-responsibility modules (â‰¤500 lines each)
- **Configuration-Driven**: All settings in external config files
- **Test-First**: TDD/BDD framework with unit, integration, and behavioral tests
- **Shell Integration**: Automatic shell configuration and CLI functions
- **Provider-Agnostic**: Supports multiple AI providers (Moonshot, Zhipu, etc.)

## ğŸ“ Directory Structure

```
claude-model-switcher/
â”œâ”€â”€ main.sh              # Entry point & command router
â”œâ”€â”€ config/              # Configuration files
â”‚   â”œâ”€â”€ app.conf        # Application settings
â”‚   â”œâ”€â”€ models.conf     # Model definitions
â”‚   â”œâ”€â”€ providers.conf  # API provider configs
â”‚   â””â”€â”€ mcp.json        # MCP server configurations
â”œâ”€â”€ lib/                 # Core modules
â”‚   â”œâ”€â”€ core/           # Foundation modules
â”‚   â”‚   â”œâ”€â”€ logger.sh   # Logging & output formatting
â”‚   â”‚   â”œâ”€â”€ config_loader.sh # Configuration management
â”‚   â”‚   â””â”€â”€ validator.sh # Input validation & checks
â”‚   â”œâ”€â”€ installers/     # Installation modules
â”‚   â”‚   â”œâ”€â”€ nodejs_installer.sh   # Node.js/NVM setup
â”‚   â”‚   â””â”€â”€ claude_installer.sh   # Claude Code installation
â”‚   â””â”€â”€ managers/       # Runtime management
â”‚       â””â”€â”€ model_manager.sh # Model switching & management
â””â”€â”€ tests/              # Test framework
    â”œâ”€â”€ test_runner.sh  # TDD/BDD test execution
    â”œâ”€â”€ unit/          # Module-level tests
    â”œâ”€â”€ integration/   # Cross-module tests
    â””â”€â”€ bdd/           # User scenario tests
```

## ğŸš€ Common Commands

### Development Workflow
```bash
# Run all tests
./tests/test_runner.sh

# Run specific test types
./tests/test_runner.sh unit          # Unit tests only
./tests/test_runner.sh integration   # Integration tests
./tests/test_runner.sh bdd          # BDD scenarios

# Run single test file
./tests/test_runner.sh tests/unit/test_logger.sh

# Install development environment
./main.sh install

# Check system status
./main.sh status

# List available models
./main.sh list-models

# Switch model provider
./main.sh use-model kimi
```

### Shell Functions (Post-Installation)
```bash
# Available after source ~/.bashrc
list_models                    # List all configured models
use_model <model-name>        # Switch to specific model
```

## ğŸ”§ Key Configuration Files

### Primary Configs
- **config/app.conf**: Application settings, paths, versions
- **config/models.conf**: Model definitions & metadata
- **config/providers.conf**: API provider configurations
- **config/mcp.json**: MCP server configurations

### Environment Variables
- `CLAUDE_SWITCHER_DIR`: Installation directory
- `CLAUDE_MODELS_CONF`: Model configuration path
- `LOG_LEVEL`: Debug/INFO/WARN/ERROR

## ğŸ¤– MCP Server Configuration

The project includes pre-configured MCP (Model Context Protocol) servers to extend Claude Code capabilities.

### Available MCP Servers

**Jina AI Server** (`jina-mcp-server`)
- **Type**: SSE (Server-Sent Events)
- **Purpose**: AI-powered search and content processing
- **Environment**: `JINA_API_KEY` required
- **Usage**: Web search, document processing, content analysis

**Filesystem Server** (`filesystem`)
- **Type**: stdio (Node.js process)
- **Purpose**: Local file system access
- **Access**: `${HOME}/Documents`, `${HOME}/Desktop`
- **Usage**: File operations, directory navigation, content reading

**GitHub Server** (`github`)
- **Type**: stdio (Node.js process)
- **Purpose**: GitHub repository management
- **Environment**: `GITHUB_TOKEN` required
- **Usage**: Repository operations, issue management, code review

**Brave Search Server** (`brave-search`)
- **Type**: stdio (Node.js process)
- **Purpose**: Web search via Brave Search API
- **Environment**: `BRAVE_API_KEY` required
- **Usage**: Real-time web search, information retrieval

### Configuration Format

```json
{
  "mcpServers": {
    "server-name": {
      "type": "stdio|sse",
      "command": "npx",  // For stdio type
      "args": ["-y", "@package/name"],
      "env": {
        "API_KEY": "${ENV_VAR}"
      },
      "url": "https://api.url",  // For SSE type
      "headers": {
        "Authorization": "Bearer ${TOKEN}"
      }
    }
  }
}
```

### Adding Custom MCP Servers

1. **Edit config/mcp.json** - Add new server configuration
2. **Set environment variables** - Required API keys and tokens
3. **Test connectivity** - Use Claude Code's `/mcp` command
4. **Verify permissions** - Check with `/permissions` command

### MCP Server Management

```bash
# Check MCP server status (in Claude Code)
/mcp

# View available permissions
/permissions

# Enable debug mode for troubleshooting
claude --mcp-debug
```

### Environment Setup

```bash
# Required environment variables
export JINA_API_KEY="your_jina_api_key"
export GITHUB_TOKEN="your_github_token"
export BRAVE_API_KEY="your_brave_api_key"

# For Chinese users - use npm mirror
npm config set registry https://registry.npmmirror.com
```

## ğŸ§ª Testing Framework

### Test Types
- **Unit Tests**: `tests/unit/` - Individual module validation
- **Integration Tests**: `tests/integration/` - Module interactions
- **BDD Tests**: `tests/bdd/` - User scenario validation

### Test Functions Available
```bash
# Assertions
assert_success "description" "command"
assert_failure "description" "command"
assert_equals "description" "expected" "actual"
assert_file_exists "description" "path"
assert_contains "description" "string" "substring"

# BDD Structure
describe "Feature Name"
context "Scenario Context"
it "should behave correctly"
```

## ğŸ¯ Core Module Responsibilities

### Core Modules (`lib/core/`)
- **logger.sh**: Colorized output, log levels, file logging
- **config_loader.sh**: Config validation, caching, reload detection
- **validator.sh**: System requirements, input validation

### Installers (`lib/installers/`)
- **nodejs_installer.sh**: Node.js/NVM version management
- **claude_installer.sh**: Claude Code CLI installation

### Managers (`lib/managers/`)
- **model_manager.sh**: Model switching, API provider coordination

## ğŸ“Š Quality Gates

Before committing changes:
1. **Tests Pass**: `./tests/test_runner.sh` must succeed
2. **Config Validation**: All config files must be valid
3. **Shell Compatibility**: Test on bash/zsh
4. **Error Handling**: All edge cases handled gracefully

## ğŸ”„ Extension Patterns

### Adding New Models
1. Edit `config/models.conf`: Add model metadata
2. Edit `config/providers.conf`: Add provider config
3. Update `lib/managers/model_manager.sh`: Add provider logic
4. Add tests in appropriate test directories

### Adding New Modules
1. Create module in appropriate `lib/` subdirectory
2. Follow existing naming: `<function>_module.sh`
3. Add comprehensive tests
4. Include in `main.sh` module loading

## ğŸ› ï¸ Development Tips

### Debugging
```bash
# Enable debug logging
export LOG_LEVEL="DEBUG"
./main.sh <command>

# Check logs
tail -f ~/.claude/claude-model-switcher/logs/installer.log
```

### Testing Changes
```bash
# Quick validation
./tests/test_runner.sh unit/test_logger.sh

# Full system test
./tests/test_runner.sh
```

### Module Testing
```bash
# Test individual module
source lib/core/logger.sh && logger_init && log_info "test"
```

## ğŸ” Key Patterns Used

- **Configuration Over Code**: All settings externalized
- **Single Responsibility**: Each module has one clear purpose
- **Dependency Injection**: Modules sourced dynamically
- **Defensive Programming**: Extensive validation and error handling
- **Atomic Operations**: Safe configuration changes with rollback
- **Observability**: Structured logging and status reporting
```

`claude-model-switcher/LICENSE`:

```
MIT License

Copyright (c) 2025 stark-y

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`claude-model-switcher/README.md`:

```md
# Claude Model Switcher - AIæ¨¡å‹ç®¡ç†ä¸“å®¶

> ğŸš€ **Claude Model Switcher v5.0.0** - ä¸“ä¸šçº§Claude Codeå¤šæ¨¡å‹ç®¡ç†è§£å†³æ–¹æ¡ˆ

ä¸€ä¸ªé‡‡ç”¨**æ¨¡å—åŒ–æ¶æ„**è®¾è®¡çš„Claude Codeå®‰è£…å™¨å’Œå¤šæ¨¡å‹ç®¡ç†ç³»ç»Ÿï¼Œä¸“ä¸ºå¼€å‘å›¢é˜Ÿå’Œä¸ªäººå¼€å‘è€…è®¾è®¡ï¼Œæä¾›ä¼ä¸šçº§çš„æ¨¡å‹ç®¡ç†ä½“éªŒã€‚

## ğŸ¯ è§£å†³çš„æ ¸å¿ƒé—®é¢˜

### åœºæ™¯ç—›ç‚¹
- **å¤šæ¨¡å‹åˆ‡æ¢å›°éš¾**ï¼šä¸åŒåœºæ™¯éœ€è¦ä¸åŒAIæ¨¡å‹ï¼Œæ‰‹åŠ¨åˆ‡æ¢ç¹ç
- **é…ç½®å¤æ‚**ï¼šæ¯ä¸ªæ¨¡å‹éƒ½æœ‰ç‹¬ç«‹çš„APIå¯†é’¥å’Œé…ç½®å‚æ•°
- **ç‰ˆæœ¬ç®¡ç†æ··ä¹±**ï¼šæ— æ³•è¿½è¸ªå’Œå›æ»šæ¨¡å‹é…ç½®å˜æ›´
- **å›¢é˜Ÿåä½œå›°éš¾**ï¼šå›¢é˜Ÿæˆå‘˜ä½¿ç”¨ä¸åŒæ¨¡å‹é…ç½®ï¼Œå¯¼è‡´ç»“æœä¸ä¸€è‡´
- **å®‰è£…éƒ¨ç½²å¤æ‚**ï¼šæ–°æ‰‹ç”¨æˆ·éš¾ä»¥æ­£ç¡®å®‰è£…å’Œé…ç½®Claude Code

### è§£å†³æ–¹æ¡ˆ
- âœ… **ä¸€é”®åˆ‡æ¢**ï¼š3ç§’å†…å®Œæˆæ¨¡å‹åˆ‡æ¢
- âœ… **é…ç½®é›†ä¸­ç®¡ç†**ï¼šæ‰€æœ‰æ¨¡å‹é…ç½®ç»Ÿä¸€ç®¡ç†ï¼Œæ”¯æŒç‰ˆæœ¬æ§åˆ¶
- âœ… **å›¢é˜Ÿåä½œ**ï¼šå…±äº«æ¨¡å‹é…ç½®ï¼Œç¡®ä¿å›¢é˜Ÿæˆå‘˜ä½¿ç”¨ç›¸åŒè®¾ç½®
- âœ… **è‡ªåŠ¨åŒ–å®‰è£…**ï¼šä¸€é”®å®ŒæˆClaude CodeåŠå…¶ä¾èµ–çš„å®‰è£…
- âœ… **ä¼ä¸šçº§å®‰å…¨**ï¼šAPIå¯†é’¥å®‰å…¨å­˜å‚¨ï¼Œæ”¯æŒå›¢é˜Ÿæƒé™ç®¡ç†

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒè®¾è®¡ç†å¿µ
- **æ¨¡å—åŒ–æ¶æ„**ï¼šæ¯ä¸ªåŠŸèƒ½ç‹¬ç«‹æˆæ¨¡å—ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
- **é…ç½®é©±åŠ¨**ï¼šæ‰€æœ‰è®¾ç½®å¤–éƒ¨åŒ–ï¼Œæ”¯æŒçƒ­æ›´æ–°
- **æµ‹è¯•ä¼˜å…ˆ**ï¼šå®Œæ•´çš„TDD/BDDæµ‹è¯•æ¡†æ¶
- **é›¶ä¾èµ–éƒ¨ç½²**ï¼šçº¯Shellè„šæœ¬ï¼Œæ— éœ€é¢å¤–ä¾èµ–

### æŠ€æœ¯æ ˆ
```
â”œâ”€â”€ Shellè„šæœ¬ (Bash/Zshå…¼å®¹)
â”œâ”€â”€ é…ç½®æ–‡ä»¶ (INIæ ¼å¼ï¼Œæ˜“äºç¼–è¾‘)
â”œâ”€â”€ æµ‹è¯•æ¡†æ¶ (è‡ªå®šä¹‰BDDæµ‹è¯•)
â”œâ”€â”€ æ—¥å¿—ç³»ç»Ÿ (ç»“æ„åŒ–æ—¥å¿—)
â””â”€â”€ æ¨¡å—ç³»ç»Ÿ (åŠ¨æ€åŠ è½½)
```

## ğŸ“ é¡¹ç›®ç»“æ„

```
claude-model-switcher/
â”œâ”€â”€ ğŸ“‹ main.sh                    # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ âš™ï¸ config/                    # é…ç½®ä¸­å¿ƒ
â”‚   â”œâ”€â”€ app.conf                 # åº”ç”¨é…ç½®
â”‚   â”œâ”€â”€ models.conf              # æ¨¡å‹å®šä¹‰
â”‚   â””â”€â”€ providers.conf           # æä¾›å•†é…ç½®
â”œâ”€â”€ ğŸ”§ lib/                      # æ ¸å¿ƒæ¨¡å—åº“
â”‚   â”œâ”€â”€ core/                    # åŸºç¡€æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ logger.sh           # æ—¥å¿—ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ config_loader.sh    # é…ç½®ç®¡ç†
â”‚   â”‚   â””â”€â”€ validator.sh        # æ•°æ®éªŒè¯
â”‚   â”œâ”€â”€ installers/             # å®‰è£…æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ nodejs_installer.sh # Node.jsç®¡ç†
â”‚   â”‚   â””â”€â”€ claude_installer.sh # Claudeå®‰è£…
â”‚   â””â”€â”€ managers/               # ä¸šåŠ¡æ¨¡å—
â”‚       â””â”€â”€ model_manager.sh    # æ¨¡å‹ç®¡ç†
â”œâ”€â”€ ğŸ§ª tests/                   # æµ‹è¯•æ¡†æ¶
â”‚   â”œâ”€â”€ test_runner.sh         # æµ‹è¯•è¿è¡Œå™¨
â”‚   â”œâ”€â”€ unit/                  # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration/           # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ bdd/                   # åœºæ™¯æµ‹è¯•
â”œâ”€â”€ ğŸ“š docs/                   # æ–‡æ¡£ç›®å½•
â””â”€â”€ ğŸ“ README.md               # æœ¬æ–‡æ¡£
```

## ğŸš€ å¿«é€Ÿå…¥é—¨

### 1. ä¸€é”®å®‰è£…

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/your-repo/claude-model-switcher.git
cd claude-model-switcher

# æ‰§è¡Œå®‰è£…
chmod +x install.sh
./install.sh

# éªŒè¯å®‰è£…
list_models
```

### 2. åŸºç¡€ä½¿ç”¨

```bash
# æŸ¥çœ‹å¯ç”¨æ¨¡å‹
list_models

# åˆ‡æ¢åˆ°Kimiæ¨¡å‹
use_model kimi

# ä½¿ç”¨Claude Code
claude "è¯·å¸®æˆ‘åˆ†æè¿™æ®µä»£ç "

# åˆ‡æ¢åˆ°GPT-4
use_model gpt4
```

### 3. é«˜çº§åŠŸèƒ½

```bash
# æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€
~/.claude/claude-model-switcher/main.sh status

# æ·»åŠ è‡ªå®šä¹‰æ¨¡å‹
~/.claude/claude-model-switcher/main.sh add-model \
  "custom-model" \
  "openai" \
  "gpt-4-turbo-preview" \
  "https://api.openai.com/v1"

# æ‰¹é‡ç®¡ç†æ¨¡å‹
~/.claude/claude-model-switcher/main.sh batch-update
```

## âš™ï¸ é…ç½®è¯¦è§£

### 1. åº”ç”¨é…ç½® (config/app.conf)

```bash
# åŸºç¡€è®¾ç½®
APP_NAME="Claude Model Switcher"
APP_VERSION="5.0.0"
INSTALL_DIR="$HOME/.claude/claude-model-switcher"

# æ—¥å¿—é…ç½®
LOG_LEVEL="INFO"
LOG_FILE="$INSTALL_DIR/logs/app.log"
MAX_LOG_SIZE="10M"

# æ€§èƒ½è®¾ç½®
CACHE_TTL=3600
PARALLEL_JOBS=4
TIMEOUT_SECONDS=30
```

### 2. æ¨¡å‹é…ç½® (config/models.conf)

```bash
# Kimiæ¨¡å‹
[kimi]
provider="moonshot"
api_name="kimi-k2-turbo-preview"
context_length="128K"
max_tokens=4096
temperature=0.6

# GPT-4
[gpt4]
provider="openai"
api_name="gpt-4-turbo-preview"
context_length="128K"
max_tokens=4096
temperature=0.7

# Claude 3.5 Sonnet
[claude35]
provider="anthropic"
api_name="claude-3-5-sonnet-20241022"
context_length="200K"
max_tokens=4096
temperature=0.7
```

### 3. æä¾›å•†é…ç½® (config/providers.conf)

```bash
# Moonshot (Kimi)
[moonshot]
base_url="https://api.moonshot.cn/anthropic/"
api_key_env="MOONSHOT_API_KEY"
rate_limit=60

# OpenAI
[openai]
base_url="https://api.openai.com/v1"
api_key_env="OPENAI_API_KEY"
rate_limit=100

# Anthropic
[anthropic]
base_url="https://api.anthropic.com"
api_key_env="ANTHROPIC_API_KEY"
rate_limit=50
```

## ğŸ§ª æµ‹è¯•é©±åŠ¨å¼€å‘

### æµ‹è¯•æ¡†æ¶ç‰¹æ€§
- âœ… **å•å…ƒæµ‹è¯•**ï¼šæ¯ä¸ªå‡½æ•°ç‹¬ç«‹æµ‹è¯•
- âœ… **é›†æˆæµ‹è¯•**ï¼šæ¨¡å—é—´åä½œéªŒè¯
- âœ… **BDDåœºæ™¯**ï¼šç”¨æˆ·æ•…äº‹é©±åŠ¨æµ‹è¯•
- âœ… **æ€§èƒ½æµ‹è¯•**ï¼šå“åº”æ—¶é—´å’Œèµ„æºä½¿ç”¨
- âœ… **å®‰å…¨æµ‹è¯•**ï¼šè¾“å…¥éªŒè¯å’Œæƒé™æ§åˆ¶

### è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
./tests/test_runner.sh

# è¿è¡Œç‰¹å®šç±»å‹æµ‹è¯•
./tests/test_runner.sh unit           # å•å…ƒæµ‹è¯•
./tests/test_runner.sh integration    # é›†æˆæµ‹è¯•
./tests/test_runner.sh bdd           # åœºæ™¯æµ‹è¯•

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
./tests/test_runner.sh tests/unit/test_model_manager.sh

# è°ƒè¯•æ¨¡å¼è¿è¡Œæµ‹è¯•
DEBUG=1 ./tests/test_runner.sh
```

### æµ‹è¯•æ–­è¨€åº“

```bash
# æ–­è¨€æˆåŠŸ
assert_success "åº”è¯¥æˆåŠŸåˆ‡æ¢æ¨¡å‹" "use_model kimi"

# æ–­è¨€å¤±è´¥
assert_failure "åº”è¯¥æ‹’ç»æ— æ•ˆæ¨¡å‹" "use_model invalid-model"

# æ–­è¨€è¾“å‡ºåŒ…å«
assert_contains "è¾“å‡ºåº”åŒ…å«æ¨¡å‹åç§°" "$(list_models)" "kimi"

# æ–­è¨€æ–‡ä»¶å­˜åœ¨
assert_file_exists "é…ç½®æ–‡ä»¶åº”å­˜åœ¨" "$HOME/.claude/config/models.conf"
```

## ğŸ”§ å¼€å‘æŒ‡å—

### 1. æ¨¡å—å¼€å‘è§„èŒƒ

#### æ¨¡å—ç»“æ„æ¨¡æ¿
```bash
#!/bin/bash
# Module: my_module.sh
# Purpose: æè¿°æ¨¡å—ç”¨é€”
# Version: 1.0.0

# æ¨¡å—çŠ¶æ€
MODULE_NAME="my_module"
MODULE_VERSION="1.0.0"
MODULE_ENABLED=true

# æ¨¡å—åˆå§‹åŒ–
my_module_init() {
    log_info "åˆå§‹åŒ– $MODULE_NAME v$MODULE_VERSION"
    # åˆå§‹åŒ–é€»è¾‘
}

# ä¸»è¦åŠŸèƒ½å‡½æ•°
my_module_main_function() {
    local param1="$1"
    local param2="$2"
    
    # è¾“å…¥éªŒè¯
    validate_input "$param1" || return 1
    
    # æ ¸å¿ƒé€»è¾‘
    # ...
    
    # ç»“æœè¿”å›
    echo "å¤„ç†ç»“æœ"
}

# æ¸…ç†å‡½æ•°
my_module_cleanup() {
    log_debug "æ¸…ç† $MODULE_NAME èµ„æº"
    # æ¸…ç†é€»è¾‘
}
```

### 2. é…ç½®æ‰©å±•

#### æ·»åŠ æ–°æ¨¡å‹
```bash
# 1. ç¼–è¾‘ config/models.conf
[new-model]
provider="new-provider"
api_name="new-model-name"
context_length="32K"
max_tokens=2048

# 2. æ·»åŠ æä¾›å•†é…ç½®
[new-provider]
base_url="https://api.new-provider.com"
api_key_env="NEW_PROVIDER_API_KEY"
rate_limit=100

# 3. è¿è¡Œæµ‹è¯•éªŒè¯
./tests/test_runner.sh integration/test_new_model.sh
```

#### æ·»åŠ æ–°åŠŸèƒ½æ¨¡å—
```bash
# 1. åˆ›å»ºæ¨¡å—æ–‡ä»¶
lib/managers/new_feature_manager.sh

# 2. å®ç°æ¨¡å—æ¥å£
new_feature_init()
new_feature_main()
new_feature_cleanup()

# 3. æ·»åŠ åˆ°ä¸»ç¨‹åº
# åœ¨ main.sh ä¸­æ·»åŠ ï¼š
source "lib/managers/new_feature_manager.sh"

# 4. ç¼–å†™æµ‹è¯•
tests/unit/test_new_feature_manager.sh
```

### 3. è°ƒè¯•å·¥å…·

```bash
# å¯ç”¨è°ƒè¯•æ¨¡å¼
export DEBUG=1
export LOG_LEVEL=DEBUG

# æŸ¥çœ‹è¯¦ç»†æ—¥å¿—
tail -f ~/.claude/claude-model-switcher/logs/debug.log

# æ€§èƒ½åˆ†æ
time ~/.claude/claude-model-switcher/main.sh list_models

# å†…å­˜ä½¿ç”¨ç›‘æµ‹
./tests/test_runner.sh performance
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜ç­–ç•¥
```bash
# é…ç½®ç¼“å­˜
CACHE_TTL=3600          # 1å°æ—¶ç¼“å­˜
CACHE_SIZE=100MB        # æœ€å¤§ç¼“å­˜å¤§å°
CACHE_DIR="$HOME/.claude/cache"

# æ‰‹åŠ¨æ¸…ç†ç¼“å­˜
~/.claude/claude-model-switcher/main.sh cache-clear
```

### 2. å¹¶è¡Œå¤„ç†
```bash
# æ‰¹é‡æ¨¡å‹æ£€æµ‹
PARALLEL_JOBS=4
~/.claude/claude-model-switcher/main.sh batch-check
```

### 3. å†…å­˜ä¼˜åŒ–
```bash
# é™åˆ¶å†…å­˜ä½¿ç”¨
MAX_MEMORY=512MB
~/.claude/claude-model-switcher/main.sh optimize-memory
```

## ğŸ”’ å®‰å…¨æœ€ä½³å®è·µ

### 1. APIå¯†é’¥ç®¡ç†
```bash
# å®‰å…¨å­˜å‚¨APIå¯†é’¥
export MOONSHOT_API_KEY="your-key-here"
export OPENAI_API_KEY="your-key-here"

# ä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡
~/.claude/claude-model-switcher/main.sh setup-key-manager
```

### 2. æƒé™æ§åˆ¶
```bash
# è®¾ç½®æ–‡ä»¶æƒé™
chmod 600 ~/.claude/config/providers.conf
chmod 755 ~/.claude/claude-model-switcher/main.sh

# ç”¨æˆ·æƒé™ç®¡ç†
~/.claude/claude-model-switcher/main.sh setup-user-permissions
```

### 3. å®¡è®¡æ—¥å¿—
```bash
# æŸ¥çœ‹æ“ä½œæ—¥å¿—
~/.claude/claude-model-switcher/main.sh audit-log

# å®‰å…¨æ‰«æ
~/.claude/claude-model-switcher/main.sh security-scan
```

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### 1. å•æœºéƒ¨ç½²
```bash
# æ ‡å‡†å®‰è£…
./install.sh

# Dockeréƒ¨ç½²
docker run -it \
  -v ~/.claude:/root/.claude \
  claude-model-switcher:latest
```

### 2. å›¢é˜Ÿéƒ¨ç½²
```bash
# å…±äº«é…ç½®éƒ¨ç½²
~/.claude/claude-model-switcher/main.sh team-setup \
  --config-repo "git@github.com:team/claude-config.git" \
  --shared-models "kimi,gpt4,claude35"

# æƒé™ç®¡ç†
~/.claude/claude-model-switcher/main.sh setup-team-permissions \
  --admin-users "alice,bob" \
  --readonly-users "charlie,david"
```

### 3. CI/CDé›†æˆ
```yaml
# GitHub Actionsç¤ºä¾‹
name: Claude Model Switcher CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Tests
        run: |
          ./tests/test_runner.sh
          ~/.claude/claude-model-switcher/main.sh security-scan
```

## ğŸ“ˆ ç›‘æ§å’Œè¿ç»´

### 1. ç³»ç»Ÿç›‘æ§
```bash
# å®æ—¶çŠ¶æ€
~/.claude/claude-model-switcher/main.sh status --real-time

# æ€§èƒ½æŒ‡æ ‡
~/.claude/claude-model-switcher/main.sh metrics

# å¥åº·æ£€æŸ¥
~/.claude/claude-model-switcher/main.sh health-check
```

### 2. å‘Šè­¦é…ç½®
```bash
# è®¾ç½®å‘Šè­¦é˜ˆå€¼
~/.claude/claude-model-switcher/main.sh setup-alerts \
  --api-timeout 30 \
  --error-rate 5% \
  --memory-usage 80%

# é›†æˆé€šçŸ¥æœåŠ¡
~/.claude/claude-model-switcher/main.sh setup-notifications \
  --slack-webhook "https://hooks.slack.com/services/..." \
  --email "admin@company.com"
```

## ğŸ¤ ç¤¾åŒºå’Œæ”¯æŒ

### 1. è·å–å¸®åŠ©
- ğŸ“– **æ–‡æ¡£**ï¼šå®Œæ•´çš„å¼€å‘æ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—
- ğŸ’¬ **è®¨è®º**ï¼šGitHub Discussions æŠ€æœ¯äº¤æµ
- ğŸ› **é—®é¢˜**ï¼šGitHub Issues é—®é¢˜åé¦ˆ
- ğŸ“§ **é‚®ä»¶**ï¼šclaude-switcher@company.com

### 2. è´¡çŒ®æŒ‡å—
```bash
# 1. Forké¡¹ç›®
git clone https://github.com/your-username/claude-model-switcher.git

# 2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/amazing-feature

# 3. ç¼–å†™æµ‹è¯•
./tests/test_runner.sh

# 4. æäº¤ä»£ç 
git commit -m "Add amazing feature"

# 5. åˆ›å»ºPR
git push origin feature/amazing-feature
```

### 3. ç‰ˆæœ¬å‘å¸ƒ
- **ä¸»ç‰ˆæœ¬**ï¼šæ¶æ„é‡å¤§å‡çº§
- **æ¬¡ç‰ˆæœ¬**ï¼šæ–°åŠŸèƒ½å¢åŠ 
- **ä¿®è®¢ç‰ˆæœ¬**ï¼šBugä¿®å¤å’Œä¼˜åŒ–

## ğŸ“„ è®¸å¯è¯

MIT License - è¯¦è§ [LICENSE](LICENSE) æ–‡ä»¶

## ğŸ™ è‡´è°¢

æ„Ÿè°¢ä»¥ä¸‹å¼€æºé¡¹ç›®çš„æ”¯æŒï¼š
- [Claude Code](https://claude.ai/code) - Anthropicå®˜æ–¹CLIå·¥å…·
- [Bash Testing Framework](https://github.com/bats-core/bats-core) - æµ‹è¯•æ¡†æ¶çµæ„Ÿ
- [ShellCheck](https://www.shellcheck.net/) - Shellè„šæœ¬è´¨é‡æ£€æŸ¥

---

<div align="center">

**Claude Model Switcher v5.0.0**  
è®©AIæ¨¡å‹ç®¡ç†å˜å¾—ç®€å•è€Œå¼ºå¤§ï¼ ğŸš€

[![Stars](https://img.shields.io/github/stars/your-repo/claude-model-switcher?style=social)](https://github.com/your-repo/claude-model-switcher)  
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)  
[![Version](https://img.shields.io/badge/version-5.0.0-green.svg)](CHANGELOG.md)

</div>
```

`claude-model-switcher/code2prompt.json`:

```json
Project Path: claude-model-switcher

Source Tree:

```txt
claude-model-switcher
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ config
â”‚   â”œâ”€â”€ app.conf
â”‚   â”œâ”€â”€ models.conf
â”‚   â””â”€â”€ providers.conf
â”œâ”€â”€ install.sh
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”œâ”€â”€ config_loader.sh
â”‚   â”‚   â”œâ”€â”€ logger.sh
â”‚   â”‚   â””â”€â”€ validator.sh
â”‚   â”œâ”€â”€ installers
â”‚   â”‚   â”œâ”€â”€ claude_installer.sh
â”‚   â”‚   â””â”€â”€ nodejs_installer.sh
â”‚   â”œâ”€â”€ managers
â”‚   â”‚   â””â”€â”€ model_manager.sh
â”‚   â””â”€â”€ utils
â”œâ”€â”€ main.sh
â”œâ”€â”€ memory-bank
â”œâ”€â”€ templates
â””â”€â”€ tests
    â”œâ”€â”€ bdd
    â”‚   â””â”€â”€ test_user_scenarios.sh
    â”œâ”€â”€ integration
    â”‚   â””â”€â”€ test_installation.sh
    â”œâ”€â”€ results
    â”‚   â””â”€â”€ test_report.txt
    â”œâ”€â”€ temp
    â”œâ”€â”€ test_runner.sh
    â””â”€â”€ unit
        â”œâ”€â”€ test_logger.sh
        â””â”€â”€ test_validator.sh

```

`claude-model-switcher/CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ğŸ—ï¸ Project Overview

**Claude Model Switcher v5.0.0** - A modular, configuration-driven Claude Code installer and multi-model management system with comprehensive testing support.

### Architecture Characteristics
- **Modular Design**: Single-responsibility modules (â‰¤500 lines each)
- **Configuration-Driven**: All settings in external config files
- **Test-First**: TDD/BDD framework with unit, integration, and behavioral tests
- **Shell Integration**: Automatic shell configuration and CLI functions
- **Provider-Agnostic**: Supports multiple AI providers (Moonshot, Zhipu, etc.)

## ğŸ“ Directory Structure

```
claude-model-switcher/
â”œâ”€â”€ main.sh              # Entry point & command router
â”œâ”€â”€ config/              # Configuration files
â”‚   â”œâ”€â”€ app.conf        # Application settings
â”‚   â”œâ”€â”€ models.conf     # Model definitions
â”‚   â””â”€â”€ providers.conf  # API provider configs
â”œâ”€â”€ lib/                 # Core modules
â”‚   â”œâ”€â”€ core/           # Foundation modules
â”‚   â”‚   â”œâ”€â”€ logger.sh   # Logging & output formatting
â”‚   â”‚   â”œâ”€â”€ config_loader.sh # Configuration management
â”‚   â”‚   â””â”€â”€ validator.sh # Input validation & checks
â”‚   â”œâ”€â”€ installers/     # Installation modules
â”‚   â”‚   â”œâ”€â”€ nodejs_installer.sh   # Node.js/NVM setup
â”‚   â”‚   â””â”€â”€ claude_installer.sh   # Claude Code installation
â”‚   â””â”€â”€ managers/       # Runtime management
â”‚       â””â”€â”€ model_manager.sh # Model switching & management
â””â”€â”€ tests/              # Test framework
    â”œâ”€â”€ test_runner.sh  # TDD/BDD test execution
    â”œâ”€â”€ unit/          # Module-level tests
    â”œâ”€â”€ integration/   # Cross-module tests
    â””â”€â”€ bdd/           # User scenario tests
```

## ğŸš€ Common Commands

### Development Workflow
```bash
# Run all tests
./tests/test_runner.sh

# Run specific test types
./tests/test_runner.sh unit          # Unit tests only
./tests/test_runner.sh integration   # Integration tests
./tests/test_runner.sh bdd          # BDD scenarios

# Run single test file
./tests/test_runner.sh tests/unit/test_logger.sh

# Install development environment
./main.sh install

# Check system status
./main.sh status

# List available models
./main.sh list-models

# Switch model provider
./main.sh use-model kimi
```

### Shell Functions (Post-Installation)
```bash
# Available after source ~/.bashrc
list_models                    # List all configured models
use_model <model-name>        # Switch to specific model
```

## ğŸ”§ Key Configuration Files

### Primary Configs
- **config/app.conf**: Application settings, paths, versions
- **config/models.conf**: Model definitions & metadata
- **config/providers.conf**: API provider configurations

### Environment Variables
- `CLAUDE_SWITCHER_DIR`: Installation directory
- `CLAUDE_MODELS_CONF`: Model configuration path
- `LOG_LEVEL`: Debug/INFO/WARN/ERROR

## ğŸ§ª Testing Framework

### Test Types
- **Unit Tests**: `tests/unit/` - Individual module validation
- **Integration Tests**: `tests/integration/` - Module interactions
- **BDD Tests**: `tests/bdd/` - User scenario validation

### Test Functions Available
```bash
# Assertions
assert_success "description" "command"
assert_failure "description" "command"
assert_equals "description" "expected" "actual"
assert_file_exists "description" "path"
assert_contains "description" "string" "substring"

# BDD Structure
describe "Feature Name"
context "Scenario Context"
it "should behave correctly"
```

## ğŸ¯ Core Module Responsibilities

### Core Modules (`lib/core/`)
- **logger.sh**: Colorized output, log levels, file logging
- **config_loader.sh**: Config validation, caching, reload detection
- **validator.sh**: System requirements, input validation

### Installers (`lib/installers/`)
- **nodejs_installer.sh**: Node.js/NVM version management
- **claude_installer.sh**: Claude Code CLI installation

### Managers (`lib/managers/`)
- **model_manager.sh**: Model switching, API provider coordination

## ğŸ“Š Quality Gates

Before committing changes:
1. **Tests Pass**: `./tests/test_runner.sh` must succeed
2. **Config Validation**: All config files must be valid
3. **Shell Compatibility**: Test on bash/zsh
4. **Error Handling**: All edge cases handled gracefully

## ğŸ”„ Extension Patterns

### Adding New Models
1. Edit `config/models.conf`: Add model metadata
2. Edit `config/providers.conf`: Add provider config
3. Update `lib/managers/model_manager.sh`: Add provider logic
4. Add tests in appropriate test directories

### Adding New Modules
1. Create module in appropriate `lib/` subdirectory
2. Follow existing naming: `<function>_module.sh`
3. Add comprehensive tests
4. Include in `main.sh` module loading

## ğŸ› ï¸ Development Tips

### Debugging
```bash
# Enable debug logging
export LOG_LEVEL="DEBUG"
./main.sh <command>

# Check logs
tail -f ~/.claude/claude-model-switcher/logs/installer.log
```

### Testing Changes
```bash
# Quick validation
./tests/test_runner.sh unit/test_logger.sh

# Full system test
./tests/test_runner.sh
```

### Module Testing
```bash
# Test individual module
source lib/core/logger.sh && logger_init && log_info "test"
```

## ğŸ” Key Patterns Used

- **Configuration Over Code**: All settings externalized
- **Single Responsibility**: Each module has one clear purpose
- **Dependency Injection**: Modules sourced dynamically
- **Defensive Programming**: Extensive validation and error handling
- **Atomic Operations**: Safe configuration changes with rollback
- **Observability**: Structured logging and status reporting
```

`claude-model-switcher/LICENSE`:

```
MIT License

Copyright (c) 2025 stark-y

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`claude-model-switcher/README.md`:

```md
# Claude Model Switcher v5.0.0 - æ¨¡å—åŒ–æ¶æ„

ä¸€ä¸ªå¼ºå¤§çš„ Claude Code å®‰è£…å™¨å’Œå¤šæ¨¡å‹ç®¡ç†ç³»ç»Ÿï¼Œé‡‡ç”¨æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œéµå¾ªã€Šè®¾è®¡æ¨¡å¼ã€‹å’Œã€Šä»£ç ç®€æ´ä¹‹é“ã€‹çš„æœ€ä½³å®è·µã€‚

## ğŸ—ï¸ æ¶æ„ç‰¹æ€§

### âœ¨ æ ¸å¿ƒæ”¹è¿›

- **æ¨¡å—åŒ–è®¾è®¡**: å°†å•ä¸ª378è¡Œæ–‡ä»¶æ‹†åˆ†ä¸ºå¤šä¸ªä¸“é—¨æ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—ä¸è¶…è¿‡500è¡Œ
- **é…ç½®é©±åŠ¨**: å®Œå…¨æ¶ˆé™¤ç¡¬ç¼–ç ï¼Œæ‰€æœ‰é…ç½®é›†ä¸­ç®¡ç†
- **æµ‹è¯•é©±åŠ¨**: æ”¯æŒTDD/BDDçš„å®Œæ•´æµ‹è¯•æ¡†æ¶
- **å…³æ³¨ç‚¹åˆ†ç¦»**: æ¯ä¸ªæ¨¡å—èŒè´£å•ä¸€ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
- **ä¾èµ–æ³¨å…¥**: æ¨¡å—é—´æ¾è€¦åˆï¼Œä¾¿äºå•ç‹¬æµ‹è¯•

### ğŸ¯ è®¾è®¡åŸåˆ™

1. **å•ä¸€èŒè´£åŸåˆ™ (SRP)**: æ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½åŸŸ
2. **å¼€é—­åŸåˆ™ (OCP)**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
3. **ä¾èµ–å€’ç½®åŸåˆ™ (DIP)**: ä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
4. **é…ç½®åŒ–ç®¡ç†**: æ‰€æœ‰å¯å˜å‚æ•°å¤–éƒ¨åŒ–é…ç½®
5. **æµ‹è¯•ä¼˜å…ˆ**: æ”¯æŒå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•å’ŒBDDåœºæ™¯æµ‹è¯•

## ğŸ“ ç›®å½•ç»“æ„

```
claude-model-switcher/
â”œâ”€â”€ main.sh                    # ä¸»å…¥å£ç‚¹ - æ¨¡å—ç¼–æ’å™¨
â”œâ”€â”€ install.sh                 # ç®€åŒ–çš„å®‰è£…å¼•å¯¼è„šæœ¬
â”œâ”€â”€ config/                    # é…ç½®æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ app.conf              # åº”ç”¨ç¨‹åºé…ç½®
â”‚   â”œâ”€â”€ models.conf           # æ¨¡å‹å®šä¹‰é…ç½®
â”‚   â””â”€â”€ providers.conf        # æä¾›å•†é…ç½®
â”œâ”€â”€ lib/                      # æ ¸å¿ƒåº“ç›®å½•
â”‚   â”œâ”€â”€ core/                 # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ logger.sh         # æ—¥å¿—æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ config_loader.sh  # é…ç½®åŠ è½½å™¨
â”‚   â”‚   â””â”€â”€ validator.sh      # éªŒè¯å™¨æ¨¡å—
â”‚   â”œâ”€â”€ installers/           # å®‰è£…å™¨æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ nodejs_installer.sh  # Node.jså®‰è£…å™¨
â”‚   â”‚   â””â”€â”€ claude_installer.sh  # Claude Codeå®‰è£…å™¨
â”‚   â”œâ”€â”€ managers/             # ç®¡ç†å™¨æ¨¡å—
â”‚   â”‚   â””â”€â”€ model_manager.sh  # æ¨¡å‹ç®¡ç†å™¨
â”‚   â””â”€â”€ utils/                # å·¥å…·æ¨¡å— (å¾…æ‰©å±•)
â”œâ”€â”€ tests/                    # æµ‹è¯•æ¡†æ¶
â”‚   â”œâ”€â”€ test_runner.sh        # æµ‹è¯•è¿è¡Œå™¨
â”‚   â”œâ”€â”€ unit/                 # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration/          # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ bdd/                  # BDDåœºæ™¯æµ‹è¯•
â””â”€â”€ templates/                # æ¨¡æ¿æ–‡ä»¶ (å¾…æ‰©å±•)
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
# å…‹éš†æˆ–ä¸‹è½½é¡¹ç›®
git clone <repository-url>
cd claude-model-switcher

# è¿è¡Œå®‰è£…è„šæœ¬
./install.sh
```

### åŸºæœ¬ä½¿ç”¨

```bash
# åˆ—å‡ºå¯ç”¨æ¨¡å‹
list_models

# åˆ‡æ¢åˆ°æŒ‡å®šæ¨¡å‹
use_model kimi

# ä½¿ç”¨ Claude Code
claude "ä½ çš„æç¤ºè¯"
```

### é«˜çº§ç®¡ç†

```bash
# ä½¿ç”¨å®Œæ•´CLI
~/.claude/claude-model-switcher/main.sh --help

# ç³»ç»ŸçŠ¶æ€æ£€æŸ¥
~/.claude/claude-model-switcher/main.sh status

# æ·»åŠ è‡ªå®šä¹‰æ¨¡å‹
~/.claude/claude-model-switcher/main.sh add-model my-model openai gpt-4

# è¿è¡Œæµ‹è¯•
~/.claude/claude-model-switcher/tests/test_runner.sh
```

## ğŸ”§ æ¨¡å—è¯¦è§£

### æ ¸å¿ƒæ¨¡å— (lib/core/)

#### logger.sh - æ—¥å¿—æ¨¡å—
- **èŒè´£**: ç»Ÿä¸€çš„æ—¥å¿—è®°å½•å’Œè¾“å‡ºæ ¼å¼åŒ–
- **ç‰¹æ€§**: å¤šçº§åˆ«æ—¥å¿—ã€æ–‡ä»¶è¾“å‡ºã€å½©è‰²æ§åˆ¶å°è¾“å‡º
- **å‡½æ•°**: `log_info()`, `log_error()`, `log_success()`, `log_debug()`

#### config_loader.sh - é…ç½®åŠ è½½å™¨
- **èŒè´£**: é…ç½®æ–‡ä»¶çš„åŠ è½½ã€éªŒè¯å’Œç¼“å­˜ç®¡ç†
- **ç‰¹æ€§**: è‡ªåŠ¨é‡è½½ã€è¯­æ³•éªŒè¯ã€ä¾èµ–æ£€æŸ¥
- **å‡½æ•°**: `config_load()`, `config_validate_syntax()`, `config_load_all()`

#### validator.sh - éªŒè¯å™¨æ¨¡å—
- **èŒè´£**: è¾“å…¥éªŒè¯å’Œç³»ç»Ÿç¯å¢ƒæ£€æŸ¥
- **ç‰¹æ€§**: å¤šç§éªŒè¯è§„åˆ™ã€è¯¦ç»†é”™è¯¯ä¿¡æ¯
- **å‡½æ•°**: `validate_model_alias()`, `validate_api_key()`, `validate_system_requirements()`

### å®‰è£…å™¨æ¨¡å— (lib/installers/)

#### nodejs_installer.sh - Node.jså®‰è£…å™¨
- **èŒè´£**: Node.jså’ŒNVMçš„å®‰è£…ç®¡ç†
- **ç‰¹æ€§**: ç‰ˆæœ¬æ£€æŸ¥ã€å¹³å°é€‚é…ã€å®‰è£…éªŒè¯
- **å‡½æ•°**: `install_nodejs()`, `validate_nodejs()`, `upgrade_nodejs()`

#### claude_installer.sh - Claude Codeå®‰è£…å™¨
- **èŒè´£**: Claude Code CLIçš„å®‰è£…å’Œé…ç½®
- **ç‰¹æ€§**: NPMåŒ…ç®¡ç†ã€é…ç½®æ–‡ä»¶ç”Ÿæˆ
- **å‡½æ•°**: `install_claude_code()`, `update_claude_code()`, `test_claude_installation()`

### ç®¡ç†å™¨æ¨¡å— (lib/managers/)

#### model_manager.sh - æ¨¡å‹ç®¡ç†å™¨
- **èŒè´£**: AIæ¨¡å‹çš„åˆ‡æ¢ã€é…ç½®å’Œç®¡ç†
- **ç‰¹æ€§**: åŠ¨æ€é…ç½®åŠ è½½ã€æä¾›å•†é€‚é…ã€ä¼šè¯ç®¡ç†
- **å‡½æ•°**: `list_models()`, `use_model()`, `add_model()`, `remove_model()`

## ğŸ§ª æµ‹è¯•æ¡†æ¶

### æµ‹è¯•ç±»å‹

1. **å•å…ƒæµ‹è¯•** (`tests/unit/`): æµ‹è¯•å•ä¸ªæ¨¡å—çš„åŠŸèƒ½
2. **é›†æˆæµ‹è¯•** (`tests/integration/`): æµ‹è¯•æ¨¡å—é—´çš„åä½œ
3. **BDDæµ‹è¯•** (`tests/bdd/`): åŸºäºç”¨æˆ·åœºæ™¯çš„è¡Œä¸ºé©±åŠ¨æµ‹è¯•

### è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
./tests/test_runner.sh

# è¿è¡Œç‰¹å®šç±»å‹çš„æµ‹è¯•
./tests/test_runner.sh unit
./tests/test_runner.sh integration
./tests/test_runner.sh bdd

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
./tests/test_runner.sh tests/unit/test_logger.sh
```

### æµ‹è¯•æ–­è¨€å‡½æ•°

- `assert_success()` - å‘½ä»¤åº”è¯¥æˆåŠŸ
- `assert_failure()` - å‘½ä»¤åº”è¯¥å¤±è´¥
- `assert_equals()` - å­—ç¬¦ä¸²ç›¸ç­‰
- `assert_file_exists()` - æ–‡ä»¶å­˜åœ¨
- `assert_contains()` - å­—ç¬¦ä¸²åŒ…å«

## âš™ï¸ é…ç½®ç®¡ç†

### é…ç½®æ–‡ä»¶

#### config/app.conf - åº”ç”¨é…ç½®
```bash
APP_VERSION="5.0.0"
SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
CLAUDE_DEFAULT_TEMPERATURE="0.6"
LOG_LEVEL="INFO"
```

#### config/models.conf - æ¨¡å‹é…ç½®
```bash
# æ¨¡å‹å®šä¹‰
MODEL_PROVIDERS["kimi"]="moonshot"
MODEL_API_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_CONTEXTS["kimi"]="128K tokens"
```

#### config/providers.conf - æä¾›å•†é…ç½®
```bash
# æä¾›å•†é…ç½®
PROVIDER_MOONSHOT_BASE_URL="https://api.moonshot.cn/anthropic/"
PROVIDER_ZHIPU_BASE_URL="https://open.bigmodel.cn/api/anthropic"
```

## ğŸ”„ æ‰©å±•æŒ‡å—

### æ·»åŠ æ–°çš„AIæä¾›å•†

1. åœ¨ `config/providers.conf` ä¸­æ·»åŠ æä¾›å•†é…ç½®
2. åœ¨ `lib/managers/model_manager.sh` ä¸­æ·»åŠ æä¾›å•†é€»è¾‘
3. æ›´æ–° `config/models.conf` ä¸­çš„å¯ç”¨æä¾›å•†åˆ—è¡¨
4. ç¼–å†™ç›¸åº”çš„æµ‹è¯•ç”¨ä¾‹

### æ·»åŠ æ–°çš„æ¨¡å—

1. åœ¨é€‚å½“çš„ `lib/` å­ç›®å½•ä¸­åˆ›å»ºæ–°æ¨¡å—
2. éµå¾ªç°æœ‰çš„å‘½åçº¦å®šå’Œä»£ç é£æ ¼
3. åœ¨ `main.sh` ä¸­å¼•å…¥æ–°æ¨¡å—
4. ç¼–å†™å¯¹åº”çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### è‡ªå®šä¹‰é…ç½®

æ‰€æœ‰é…ç½®éƒ½å¯ä»¥é€šè¿‡ä¿®æ”¹ `config/` ç›®å½•ä¸‹çš„æ–‡ä»¶è¿›è¡Œè‡ªå®šä¹‰ï¼Œæ— éœ€ä¿®æ”¹ä»£ç ã€‚

## ğŸ› ï¸ å¼€å‘å·¥å…·

### ä»£ç é£æ ¼
- ä½¿ç”¨æ¸…æ™°çš„å˜é‡å‘½å
- å…¨å±€é…ç½®ä½¿ç”¨å¤§å†™ï¼Œå±€éƒ¨å˜é‡ä½¿ç”¨å°å†™
- æ¯ä¸ªå‡½æ•°åŒ…å«è¯¦ç»†æ³¨é‡Š
- é”™è¯¯å¤„ç†å’Œè¿”å›ç ä¸€è‡´æ€§

### è°ƒè¯•æ”¯æŒ
```bash
# å¯ç”¨è°ƒè¯•æ¨¡å¼
export LOG_LEVEL="DEBUG"

# æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶
tail -f ~/.claude/claude-model-switcher/logs/installer.log
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

- é…ç½®æ–‡ä»¶ç¼“å­˜æœºåˆ¶ï¼Œé¿å…é‡å¤åŠ è½½
- æ¨¡å—æŒ‰éœ€åŠ è½½ï¼Œå‡å°‘å¯åŠ¨æ—¶é—´
- å¹¶è¡ŒåŒ–å¤„ç†ï¼Œæå‡å®‰è£…é€Ÿåº¦
- æ™ºèƒ½å¤‡ä»½ç­–ç•¥ï¼ŒèŠ‚çœå­˜å‚¨ç©ºé—´

## ğŸ”’ å®‰å…¨ç‰¹æ€§

- APIå¯†é’¥ä»…åœ¨ä¼šè¯ä¸­å­˜å‚¨ï¼Œä¸å†™å…¥æ–‡ä»¶
- æ‰€æœ‰æ–‡ä»¶ä¿®æ”¹å‰è‡ªåŠ¨å¤‡ä»½
- åŸå­æ“ä½œï¼Œé˜²æ­¢é…ç½®æŸå
- è¾“å…¥éªŒè¯ï¼Œé˜²æ­¢æ³¨å…¥æ”»å‡»

## ğŸ“ˆ ç›‘æ§å’Œæ—¥å¿—

- ç»“æ„åŒ–æ—¥å¿—è®°å½•
- å¤šçº§åˆ«æ—¥å¿—æ§åˆ¶
- æ“ä½œå®¡è®¡è¿½è¸ª
- æ€§èƒ½æŒ‡æ ‡æ”¶é›†

## ğŸ¤ è´¡çŒ®æŒ‡å—

1. Fork é¡¹ç›®
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
3. ç¼–å†™æµ‹è¯•ç”¨ä¾‹
4. æäº¤ä»£ç å˜æ›´
5. åˆ›å»º Pull Request

## ğŸ“ ç‰ˆæœ¬å†å²

### v5.0.0 (å½“å‰ç‰ˆæœ¬)
- ğŸ‰ å®Œå…¨æ¨¡å—åŒ–é‡æ„
- âœ… å®ç°é…ç½®é©±åŠ¨æ¶æ„
- ğŸ§ª æ·»åŠ å®Œæ•´æµ‹è¯•æ¡†æ¶
- ğŸ“š æ”¹è¿›æ–‡æ¡£å’Œç”¨æˆ·ä½“éªŒ

### v4.2.0 (é—ç•™ç‰ˆæœ¬)
- å•æ–‡ä»¶æ¶æ„
- ç¡¬ç¼–ç é…ç½®
- åŸºæœ¬åŠŸèƒ½å®ç°

## ğŸ“ æ”¯æŒ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·ï¼š
1. æŸ¥çœ‹æœ¬æ–‡æ¡£
2. è¿è¡Œ `./main.sh --help` è·å–å¸®åŠ©
3. æ£€æŸ¥æ—¥å¿—æ–‡ä»¶
4. æäº¤ Issue

---

**Claude Model Switcher v5.0.0** - è®©AIæ¨¡å‹åˆ‡æ¢å˜å¾—ç®€å•è€Œå¼ºå¤§ï¼ ğŸš€

```

`claude-model-switcher/config/app.conf`:

```conf
# Claude Model Switcher Application Configuration
# Version: 5.0.0 (Modular Architecture)
# This file contains all application-level configurations

# Application Metadata
APP_NAME="Claude Model Switcher"
APP_VERSION="5.0.0"
APP_DESCRIPTION="Robust installer and manager for Claude Code with multi-model support"

# Directory Structure
SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
CONFIG_DIR="$SWITCHER_DIR/config"
LIB_DIR="$SWITCHER_DIR/lib"
MEMORY_DIR="$SWITCHER_DIR/memory"
LOG_DIR="$SWITCHER_DIR/logs"
BACKUP_DIR="$SWITCHER_DIR/backups"

# Configuration Files
MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
PROVIDERS_CONFIG_FILE="$CONFIG_DIR/providers.conf"
USER_CONFIG_FILE="$CONFIG_DIR/user.conf"

# Shell Integration
SHELL_CONFIG_MARKER="# CLAUDE_CODE_MODEL_MANAGER_V5"
SHELL_CONFIG_END_MARKER="# END_OF_CLAUDE_CONFIG"

# Node.js Configuration
NODE_MIN_VERSION="18"
NVM_VERSION="v0.39.7"
NVM_INSTALL_URL="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh"

# Claude Code Configuration
CLAUDE_PACKAGE="@anthropic-ai/claude-code"
CLAUDE_DEFAULT_TEMPERATURE="0.6"
CLAUDE_DEFAULT_TIMEOUT="300000"

# Logging Configuration
LOG_LEVEL="INFO"  # DEBUG, INFO, WARN, ERROR
LOG_FILE="$LOG_DIR/installer.log"
LOG_MAX_SIZE="10M"
LOG_BACKUP_COUNT="5"

# Safety and Backup Configuration
ENABLE_BACKUPS="true"
BACKUP_RETENTION_DAYS="30"
ATOMIC_OPERATIONS="true"

# Feature Flags
ENABLE_DUAL_MODEL_SUPPORT="true"
ENABLE_TEMPERATURE_CONTROL="true"
ENABLE_TIMEOUT_CONTROL="true"
ENABLE_MEMORY_TRACKING="true"
ENABLE_SHELL_HOOKS="true"

# UI Configuration
USE_EMOJIS="true"
PROGRESS_BAR_WIDTH="50"
TABLE_WIDTH="110"


```

`claude-model-switcher/config/models.conf`:

```conf
# Claude Model Switcher Model Configuration
# This file defines all available AI models and their properties
# Requires Bash 4.0+ for associative arrays

# Associative arrays to hold model properties
# (Arrays are declared in config_loader.sh before sourcing this file)

# --- Moonshot Models ---

# Model: Kimi K2 Turbo Preview
MODEL_PROVIDERS["kimi"]="moonshot"
MODEL_API_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_SMALL_FAST_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_CONTEXTS["kimi"]="128K tokens (Main & Fast)"
MODEL_DESCRIPTIONS["kimi"]="Moonshot Kimi K2 - Advanced reasoning and long context"
MODEL_CAPABILITIES["kimi"]="text,reasoning,code"

# --- Zhipu GLM Models ---

# Model: GLM-4.5 Series
MODEL_PROVIDERS["glm4"]="zhipu"
MODEL_API_NAMES["glm4"]="glm-4.5"
MODEL_SMALL_FAST_NAMES["glm4"]="glm-4.5-flash"
MODEL_CONTEXTS["glm4"]="32K tokens (Main) / 128K tokens (Fast)"
MODEL_DESCRIPTIONS["glm4"]="Zhipu GLM-4.5 - Balanced performance with fast variant"
MODEL_CAPABILITIES["glm4"]="text,reasoning,code,multimodal"

# --- Example Future Models (Commented) ---

# OpenAI GPT-4
# MODEL_PROVIDERS["gpt4"]="openai"
# MODEL_API_NAMES["gpt4"]="gpt-4"
# MODEL_SMALL_FAST_NAMES["gpt4"]="gpt-3.5-turbo"
# MODEL_CONTEXTS["gpt4"]="8K tokens (Main) / 4K tokens (Fast)"
# MODEL_DESCRIPTIONS["gpt4"]="OpenAI GPT-4 - Most capable model"
# MODEL_CAPABILITIES["gpt4"]="text,reasoning,code"

# Anthropic Claude
# MODEL_PROVIDERS["claude"]="anthropic"
# MODEL_API_NAMES["claude"]="claude-3-opus"
# MODEL_SMALL_FAST_NAMES["claude"]="claude-3-sonnet"
# MODEL_CONTEXTS["claude"]="200K tokens (Main) / 200K tokens (Fast)"
# MODEL_DESCRIPTIONS["claude"]="Anthropic Claude 3 - Excellent reasoning"
# MODEL_CAPABILITIES["claude"]="text,reasoning,code,analysis"

# Model Registry
# List of all available model aliases (used for validation and iteration)
AVAILABLE_MODELS="kimi glm4"

# Default Model Settings
DEFAULT_MODEL="kimi"
FALLBACK_MODEL="glm4"

# Model Categories
TEXT_MODELS="kimi glm4"
CODE_MODELS="kimi glm4"
MULTIMODAL_MODELS="glm4"
REASONING_MODELS="kimi glm4"


```

`claude-model-switcher/config/providers.conf`:

```conf
# Claude Model Switcher Provider Configuration
# This file defines all supported AI model providers

# Provider Configuration Format:
# PROVIDER_<NAME>_BASE_URL="base_url"
# PROVIDER_<NAME>_AUTH_TYPE="bearer|api_key"
# PROVIDER_<NAME>_DESCRIPTION="description"

# Moonshot Provider Configuration
PROVIDER_MOONSHOT_BASE_URL="https://api.moonshot.cn/anthropic/"
PROVIDER_MOONSHOT_AUTH_TYPE="bearer"
PROVIDER_MOONSHOT_DESCRIPTION="Moonshot AI - Kimi series models"
PROVIDER_MOONSHOT_SUPPORTED_MODELS="kimi-k2-turbo-preview"

# Zhipu GLM Provider Configuration
PROVIDER_ZHIPU_BASE_URL="https://open.bigmodel.cn/api/anthropic"
PROVIDER_ZHIPU_AUTH_TYPE="bearer"
PROVIDER_ZHIPU_DESCRIPTION="Zhipu AI - GLM series models"
PROVIDER_ZHIPU_SUPPORTED_MODELS="glm-4.5,glm-4.5-flash"

# OpenAI Provider Configuration (Example for future extension)
PROVIDER_OPENAI_BASE_URL="https://api.openai.com/v1"
PROVIDER_OPENAI_AUTH_TYPE="bearer"
PROVIDER_OPENAI_DESCRIPTION="OpenAI - GPT series models"
PROVIDER_OPENAI_SUPPORTED_MODELS="gpt-4,gpt-3.5-turbo"

# Anthropic Provider Configuration (Example for future extension)
PROVIDER_ANTHROPIC_BASE_URL="https://api.anthropic.com"
PROVIDER_ANTHROPIC_AUTH_TYPE="api_key"
PROVIDER_ANTHROPIC_DESCRIPTION="Anthropic - Claude series models"
PROVIDER_ANTHROPIC_SUPPORTED_MODELS="claude-3-opus,claude-3-sonnet"

# Provider Registry
# List of all available providers (used for validation and iteration)
AVAILABLE_PROVIDERS="moonshot zhipu openai anthropic"

# Default Provider Settings
DEFAULT_PROVIDER="moonshot"
FALLBACK_PROVIDER="zhipu"


```

`claude-model-switcher/install.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Simplified Installation Script
# Version 5.0.0 - Modular Architecture
# This script bootstraps the modular installation system

set -e

# Script metadata
SCRIPT_VERSION="5.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_TARGET="$HOME/.claude/claude-model-switcher"

# Simple logging for bootstrap
log_info() {
    echo "â„¹ï¸  $1"
}

log_success() {
    echo "âœ… $1"
}

log_error() {
    echo "âŒ $1"
}

log_progress() {
    echo "ğŸš€ $1"
}

# Bootstrap installation
bootstrap_install() {
    log_info "Claude Model Switcher v$SCRIPT_VERSION - Modular Installation"
    echo "================================================================="
    
    # Check if we're running from the correct location
    if [ ! -f "$SCRIPT_DIR/main.sh" ]; then
        log_error "main.sh not found. Please ensure you're running from the correct directory."
        exit 1
    fi
    
    # Check if already installed
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_info "Existing installation detected at: $INSTALL_TARGET"
        echo -n "Do you want to update the existing installation? [y/N]: "
        read -r update_choice
        
        case "$update_choice" in
            [yY]|[yY][eS]|[yY][eE][sS])
                log_progress "Updating existing installation..."
                ;;
            *)
                log_info "Installation cancelled by user"
                exit 0
                ;;
        esac
    fi
    
    # Create installation directory
    log_progress "Creating installation directory: $INSTALL_TARGET"
    mkdir -p "$INSTALL_TARGET"
    
    # Copy all files to installation directory
    log_progress "Copying modular system files..."
    cp -r "$SCRIPT_DIR"/* "$INSTALL_TARGET/"
    
    # Make scripts executable
    chmod +x "$INSTALL_TARGET/main.sh"
    chmod +x "$INSTALL_TARGET/tests/test_runner.sh"
    
    log_success "Modular system files copied successfully"
    
    # Run the modular installation
    log_progress "Running modular installation process..."
    cd "$INSTALL_TARGET"
    
    if ./main.sh install; then
        log_success "Installation completed successfully!"
        echo ""
        log_info "The modular system is now installed at: $INSTALL_TARGET"
        log_info "You can manage it using: $INSTALL_TARGET/main.sh [command]"
        echo ""
        log_info "Quick start:"
        log_info "1. Source your shell configuration: source ~/.bashrc"
        log_info "2. List models: list_models"
        log_info "3. Use a model: use_model kimi"
    else
        log_error "Installation failed!"
        exit 1
    fi
}

# Uninstall function
uninstall() {
    log_info "Uninstalling Claude Model Switcher..."
    
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_progress "Running modular uninstallation..."
        cd "$INSTALL_TARGET"
        ./main.sh uninstall
    else
        log_info "Modular system not found, cleaning up manually..."
        
        # Manual cleanup for legacy installations
        local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
        for shell_file in "${shell_files[@]}"; do
            if [ -f "$shell_file" ] && grep -q "CLAUDE_CODE_MODEL_MANAGER" "$shell_file"; then
                log_progress "Cleaning shell configuration: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.cleanup_backup.$(date +%Y%m%d_%H%M%S)"
                # Remove old configuration blocks (both V4 and V5)
                sed -i '/# CLAUDE_CODE_MODEL_MANAGER/,/# END_OF_CLAUDE_CONFIG/d' "$shell_file"
            fi
        done
        
        # Remove installation directory
        if [ -d "$INSTALL_TARGET" ]; then
            rm -rf "$INSTALL_TARGET"
            log_success "Installation directory removed"
        fi
        
        # Remove parent directory if empty
        local parent_dir
        parent_dir=$(dirname "$INSTALL_TARGET")
        if [ -d "$parent_dir" ] && [ -z "$(ls -A "$parent_dir" 2>/dev/null)" ]; then
            rmdir "$parent_dir"
        fi
    fi
    
    log_success "Uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Show help
show_help() {
    cat << EOF
Claude Model Switcher v$SCRIPT_VERSION - Installation Script

USAGE:
    $0 [OPTION]

OPTIONS:
    (no option)    Install or update Claude Model Switcher
    --uninstall    Remove Claude Model Switcher completely
    --help         Show this help message

DESCRIPTION:
    This script installs the modular Claude Model Switcher system.
    The system will be installed to: $INSTALL_TARGET

FEATURES:
    â€¢ Modular architecture with clean separation of concerns
    â€¢ Configuration-driven (no hardcoded values)
    â€¢ Comprehensive test suite with TDD/BDD support
    â€¢ Support for multiple AI model providers
    â€¢ Automatic shell integration
    â€¢ Safe installation with backups

EXAMPLES:
    $0                 # Install or update
    $0 --uninstall     # Complete removal
    $0 --help          # Show this help

After installation, you can use:
    list_models        # List available models
    use_model <alias>  # Switch to a model
    
Or use the full CLI:
    $INSTALL_TARGET/main.sh [command]

EOF
}

# Main execution
main() {
    local command="${1:-install}"
    
    case "$command" in
        "install"|"")
            bootstrap_install
            ;;
        "--uninstall")
            uninstall
            ;;
        "--help"|"-h")
            show_help
            ;;
        *)
            log_error "Unknown option: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"

```

`claude-model-switcher/lib/core/config_loader.sh`:

```sh
#!/bin/bash

# Configuration Loader Module
# Handles loading and validation of configuration files

# Source the logger
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Global configuration variables
declare -A CONFIG_CACHE
declare -A CONFIG_FILE_TIMESTAMPS

# Load a configuration file
config_load() {
    local config_file="$1"
    local force_reload="${2:-false}"
    local config_name="${3:-$(basename "$config_file" .conf)}"
    
    if [ ! -f "$config_file" ]; then
        log_error "Configuration file not found: $config_file"
        return 1
    fi
    
    # Check if we need to reload based on file modification time
    local current_timestamp
    current_timestamp=$(stat -c %Y "$config_file" 2>/dev/null || echo "0")
    local cached_timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]:-0}"
    
    if [ "$force_reload" = "true" ] || [ "$current_timestamp" -gt "$cached_timestamp" ]; then
        log_debug "Loading configuration: $config_file"
        
        # Validate configuration file syntax
        if ! config_validate_syntax "$config_file"; then
            log_error "Configuration file has syntax errors: $config_file"
            return 1
        fi
        
        # Pre-declare associative arrays for models.conf
        if [[ "$config_file" == *"models.conf" ]]; then
            declare -gA MODEL_PROVIDERS 2>/dev/null || true
            declare -gA MODEL_API_NAMES 2>/dev/null || true
            declare -gA MODEL_CONTEXTS 2>/dev/null || true
            declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
            declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
            declare -gA MODEL_CAPABILITIES 2>/dev/null || true
        fi
        
        # Source the configuration file
        if source "$config_file"; then
            CONFIG_FILE_TIMESTAMPS[$config_name]="$current_timestamp"
            CONFIG_CACHE[$config_name]="loaded"
            log_debug "Configuration loaded successfully: $config_name"
            return 0
        else
            log_error "Failed to load configuration: $config_file"
            return 1
        fi
    else
        log_debug "Configuration already loaded and up-to-date: $config_name"
        return 0
    fi
}

# Validate configuration file syntax
config_validate_syntax() {
    local config_file="$1"
    
    # Basic shell syntax check
    if ! bash -n "$config_file" 2>/dev/null; then
        log_error "Shell syntax error in configuration file: $config_file"
        return 1
    fi
    
    # Check for required variables based on file type
    local filename=$(basename "$config_file")
    case "$filename" in
        "app.conf")
            config_validate_app_config "$config_file"
            ;;
        "models.conf")
            config_validate_models_config "$config_file"
            ;;
        "providers.conf")
            config_validate_providers_config "$config_file"
            ;;
        *)
            log_debug "No specific validation rules for: $filename"
            return 0
            ;;
    esac
}

# Validate app configuration
config_validate_app_config() {
    local config_file="$1"
    local required_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    # Source config in a subshell to check variables
    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$config_file"; then
            log_error "Required variable '$var' not found in $config_file"
            return 1
        fi
    done
    
    log_debug "App configuration validation passed"
    return 0
}

# Validate models configuration
config_validate_models_config() {
    local config_file="$1"
    
    # Check for model assignments (arrays are declared externally)
    if ! grep -q "MODEL_PROVIDERS\[" "$config_file"; then
        log_error "No MODEL_PROVIDERS assignments found in $config_file"
        return 1
    fi
    
    if ! grep -q "MODEL_API_NAMES\[" "$config_file"; then
        log_error "No MODEL_API_NAMES assignments found in $config_file"
        return 1
    fi
    
    log_debug "Models configuration validation passed"
    return 0
}

# Validate providers configuration
config_validate_providers_config() {
    local config_file="$1"
    
    # Check for at least one provider configuration
    if ! grep -q "PROVIDER_.*_BASE_URL=" "$config_file"; then
        log_error "No provider configurations found in $config_file"
        return 1
    fi
    
    log_debug "Providers configuration validation passed"
    return 0
}

# Load all configuration files
config_load_all() {
    local config_dir="${1:-$HOME/.claude/claude-model-switcher/config}"
    local force_reload="${2:-false}"
    
    if [ ! -d "$config_dir" ]; then
        log_error "Configuration directory not found: $config_dir"
        return 1
    fi
    
    log_progress "Loading all configuration files from: $config_dir"
    
    # Load configurations in order of dependency
    local config_files=(
        "$config_dir/app.conf"
        "$config_dir/providers.conf"
        "$config_dir/models.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            if ! config_load "$config_file" "$force_reload"; then
                log_error "Failed to load configuration: $config_file"
                return 1
            fi
        else
            log_warn "Configuration file not found (optional): $config_file"
        fi
    done
    
    log_success "All configuration files loaded successfully"
    return 0
}

# Get configuration value with fallback
config_get() {
    local var_name="$1"
    local default_value="$2"
    
    # Check if variable is set
    if [ -n "${!var_name}" ]; then
        echo "${!var_name}"
    else
        log_debug "Configuration variable '$var_name' not set, using default: $default_value"
        echo "$default_value"
    fi
}

# Set configuration value
config_set() {
    local var_name="$1"
    local value="$2"
    
    export "$var_name"="$value"
    log_debug "Configuration variable set: $var_name=$value"
}

# Check if configuration is loaded
config_is_loaded() {
    local config_name="$1"
    [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]
}

# Reload specific configuration
config_reload() {
    local config_name="$1"
    local config_dir="${2:-$HOME/.claude/claude-model-switcher/config}"
    
    config_load "$config_dir/${config_name}.conf" "true" "$config_name"
}

# List loaded configurations
config_list_loaded() {
    log_info "Loaded configurations:"
    for config_name in "${!CONFIG_CACHE[@]}"; do
        if [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]; then
            local timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]}"
            local date_str=$(date -d "@$timestamp" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
            log_indent info "$config_name (loaded at: $date_str)" 2
        fi
    done
}

# Validate current environment against configuration
config_validate_environment() {
    log_progress "Validating environment against configuration..."
    
    # Check bash version for associative arrays
    local bash_version="${BASH_VERSION%%.*}"
    if [ "$bash_version" -lt 4 ]; then
        log_error "Bash 4.0+ required for associative arrays. Current version: $BASH_VERSION"
        return 1
    fi
    
    # Check required directories
    local required_dirs=(
        "$SWITCHER_DIR"
        "$CONFIG_DIR"
        "$LIB_DIR"
        "$MEMORY_DIR"
        "$LOG_DIR"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ -n "$dir" ] && [ ! -d "$dir" ]; then
            log_warn "Required directory missing: $dir"
            mkdir -p "$dir" || {
                log_error "Failed to create directory: $dir"
                return 1
            }
            log_success "Created directory: $dir"
        fi
    done
    
    log_success "Environment validation completed"
    return 0
}


```

`claude-model-switcher/lib/core/logger.sh`:

```sh
#!/bin/bash

# Logger Module - Centralized logging functionality
# Supports different log levels and formatted output

# Initialize logger (should be called once)
logger_init() {
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    local log_file="${LOG_FILE:-$log_dir/installer.log}"
    
    # Ensure log directory exists
    mkdir -p "$log_dir"
    
    # Set global log file
    export LOGGER_FILE="$log_file"
    export LOGGER_LEVEL="${LOG_LEVEL:-INFO}"
    export LOGGER_USE_EMOJIS="${USE_EMOJIS:-true}"
    
    # Initialize log file with session header
    echo "=== New Session Started: $(date) ===" >> "$LOGGER_FILE"
}

# Get current timestamp
_get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Get emoji for log level
_get_emoji() {
    local level="$1"
    if [ "$LOGGER_USE_EMOJIS" != "true" ]; then
        echo ""
        return
    fi
    
    case "$level" in
        DEBUG) echo "ğŸ”" ;;
        INFO)  echo "â„¹ï¸" ;;
        WARN)  echo "âš ï¸" ;;
        ERROR) echo "âŒ" ;;
        SUCCESS) echo "âœ…" ;;
        PROGRESS) echo "ğŸš€" ;;
        *) echo "ğŸ“" ;;
    esac
}

# Check if log level should be printed
_should_log() {
    local level="$1"
    local current_level="${LOGGER_LEVEL:-INFO}"
    
    case "$current_level" in
        DEBUG) return 0 ;;
        INFO)  [[ "$level" =~ ^(INFO|WARN|ERROR|SUCCESS|PROGRESS)$ ]] ;;
        WARN)  [[ "$level" =~ ^(WARN|ERROR|SUCCESS)$ ]] ;;
        ERROR) [[ "$level" =~ ^(ERROR|SUCCESS)$ ]] ;;
        *) return 0 ;;
    esac
}

# Core logging function
_log() {
    local level="$1"
    local message="$2"
    local to_file="${3:-true}"
    local to_console="${4:-true}"
    
    if ! _should_log "$level"; then
        return 0
    fi
    
    local timestamp="$(_get_timestamp)"
    local emoji="$(_get_emoji "$level")"
    local formatted_message="[$timestamp] [$level] $message"
    local console_message="$emoji $message"
    
    # Log to file
    if [ "$to_file" = "true" ] && [ -n "$LOGGER_FILE" ]; then
        # Ensure log directory exists before writing
        local log_dir
        log_dir=$(dirname "$LOGGER_FILE")
        if [ ! -d "$log_dir" ]; then
            mkdir -p "$log_dir" 2>/dev/null || true
        fi
        
        # Only write to file if we can create/access the directory
        if [ -d "$log_dir" ] && [ -w "$log_dir" ]; then
            echo "$formatted_message" >> "$LOGGER_FILE" 2>/dev/null || true
        fi
    fi
    
    # Log to console
    if [ "$to_console" = "true" ]; then
        echo "$console_message"
    fi
}

# Public logging functions
log_debug() {
    _log "DEBUG" "$1" "${2:-true}" "${3:-true}"
}

log_info() {
    _log "INFO" "$1" "${2:-true}" "${3:-true}"
}

log_warn() {
    _log "WARN" "$1" "${2:-true}" "${3:-true}"
}

log_error() {
    _log "ERROR" "$1" "${2:-true}" "${3:-true}"
}

log_success() {
    _log "SUCCESS" "$1" "${2:-true}" "${3:-true}"
}

log_progress() {
    _log "PROGRESS" "$1" "${2:-true}" "${3:-true}"
}

# Special logging functions
log_separator() {
    local char="${1:--}"
    local width="${2:-50}"
    local message=""
    
    for ((i=1; i<=width; i++)); do
        message+="$char"
    done
    
    log_info "$message"
}

log_header() {
    local title="$1"
    local width="${2:-50}"
    
    log_separator "=" "$width"
    log_info "$title"
    log_separator "=" "$width"
}

# Log with indentation (for nested operations)
log_indent() {
    local level="$1"
    local message="$2"
    local indent="${3:-2}"
    
    local spaces=""
    for ((i=1; i<=indent; i++)); do
        spaces+=" "
    done
    
    case "$level" in
        debug) log_debug "$spaces$message" ;;
        info)  log_info "$spaces$message" ;;
        warn)  log_warn "$spaces$message" ;;
        error) log_error "$spaces$message" ;;
        success) log_success "$spaces$message" ;;
        progress) log_progress "$spaces$message" ;;
    esac
}

# Log command execution
log_command() {
    local cmd="$1"
    local show_output="${2:-false}"
    
    log_debug "Executing command: $cmd"
    
    if [ "$show_output" = "true" ]; then
        eval "$cmd" 2>&1 | while read -r line; do
            log_indent debug "$line" 4
        done
        return "${PIPESTATUS[0]}"
    else
        eval "$cmd" >/dev/null 2>&1
        return $?
    fi
}

# Cleanup old log files
log_cleanup() {
    local retention_days="${BACKUP_RETENTION_DAYS:-30}"
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    
    if [ -d "$log_dir" ]; then
        log_debug "Cleaning up log files older than $retention_days days"
        find "$log_dir" -name "*.log" -type f -mtime +"$retention_days" -delete 2>/dev/null || true
    fi
}


```

`claude-model-switcher/lib/core/validator.sh`:

```sh
#!/bin/bash

# Validator Module
# Provides validation functions for various inputs and system states

# Source dependencies
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Validate system requirements
validate_system_requirements() {
    log_progress "Validating system requirements..."
    
    local errors=0
    
    # Check operating system
    local os_name=$(uname -s)
    case "$os_name" in
        Linux|Darwin)
            log_success "Operating system supported: $os_name"
            ;;
        *)
            log_error "Unsupported operating system: $os_name"
            ((errors++))
            ;;
    esac
    
    # Check bash version
    local bash_major="${BASH_VERSION%%.*}"
    if [ "$bash_major" -ge 4 ]; then
        log_success "Bash version supported: $BASH_VERSION"
    else
        log_error "Bash 4.0+ required. Current version: $BASH_VERSION"
        ((errors++))
    fi
    
    # Check required commands
    local required_commands=("curl" "sed" "grep" "mkdir" "cp" "rm")
    for cmd in "${required_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            log_debug "Required command available: $cmd"
        else
            log_error "Required command not found: $cmd"
            ((errors++))
        fi
    done
    
    # Check write permissions for home directory
    if [ -w "$HOME" ]; then
        log_success "Home directory is writable: $HOME"
    else
        log_error "Home directory is not writable: $HOME"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All system requirements validated successfully"
        return 0
    else
        log_error "System requirements validation failed with $errors errors"
        return 1
    fi
}

# Validate Node.js installation
validate_nodejs() {
    local min_version="${1:-18}"
    
    log_debug "Validating Node.js installation (minimum version: $min_version)"
    
    if ! command -v node >/dev/null 2>&1; then
        log_warn "Node.js not found"
        return 1
    fi
    
    local current_version
    current_version=$(node -v 2>/dev/null | sed 's/v//')
    
    if [ -z "$current_version" ]; then
        log_error "Could not determine Node.js version"
        return 1
    fi
    
    local major_version
    major_version=$(echo "$current_version" | cut -d. -f1)
    
    if [ "$major_version" -ge "$min_version" ]; then
        log_success "Node.js version meets requirements: v$current_version (>= v$min_version)"
        return 0
    else
        log_warn "Node.js version too old: v$current_version (< v$min_version)"
        return 1
    fi
}

# Validate Claude Code installation
validate_claude_code() {
    log_debug "Validating Claude Code installation"
    
    if ! command -v claude >/dev/null 2>&1; then
        log_warn "Claude Code not found"
        return 1
    fi
    
    local version
    if version=$(claude --version 2>/dev/null); then
        log_success "Claude Code is installed: $version"
        return 0
    else
        log_error "Claude Code installation appears corrupted"
        return 1
    fi
}

# Validate model alias
validate_model_alias() {
    local alias="$1"
    
    if [ -z "$alias" ]; then
        log_error "Model alias cannot be empty"
        return 1
    fi
    
    # Check if alias contains only allowed characters
    if [[ ! "$alias" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Model alias contains invalid characters: $alias"
        log_info "Allowed characters: letters, numbers, underscore, hyphen"
        return 1
    fi
    
    # Check alias length
    if [ ${#alias} -gt 20 ]; then
        log_error "Model alias too long (max 20 characters): $alias"
        return 1
    fi
    
    log_debug "Model alias validation passed: $alias"
    return 0
}

# Validate provider name
validate_provider_name() {
    local provider="$1"
    local available_providers="${2:-$AVAILABLE_PROVIDERS}"
    
    if [ -z "$provider" ]; then
        log_error "Provider name cannot be empty"
        return 1
    fi
    
    # Check if provider is in the list of available providers
    if [[ " $available_providers " =~ " $provider " ]]; then
        log_debug "Provider validation passed: $provider"
        return 0
    else
        log_error "Unknown provider: $provider"
        log_info "Available providers: $available_providers"
        return 1
    fi
}

# Validate API key format
validate_api_key() {
    local api_key="$1"
    local provider="${2:-generic}"
    
    if [ -z "$api_key" ]; then
        log_error "API key cannot be empty"
        return 1
    fi
    
    # Check minimum length
    if [ ${#api_key} -lt 10 ]; then
        log_error "API key too short (minimum 10 characters)"
        return 1
    fi
    
    # Provider-specific validation
    case "$provider" in
        "moonshot")
            if [[ "$api_key" =~ ^sk-[a-zA-Z0-9]{40,}$ ]]; then
                log_debug "Moonshot API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Moonshot (expected: sk-...)"
                return 0  # Warning only, don't fail
            fi
            ;;
        "zhipu")
            if [[ "$api_key" =~ ^[a-zA-Z0-9]{32,}$ ]]; then
                log_debug "Zhipu API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Zhipu"
                return 0  # Warning only, don't fail
            fi
            ;;
        *)
            log_debug "Generic API key validation passed"
            return 0
            ;;
    esac
}

# Validate file path
validate_file_path() {
    local file_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$file_path" ]; then
        log_error "File path cannot be empty"
        return 1
    fi
    
    # Check if file must exist
    if [ "$must_exist" = "true" ] && [ ! -f "$file_path" ]; then
        log_error "File does not exist: $file_path"
        return 1
    fi
    
    # Check if file must be writable
    if [ "$must_be_writable" = "true" ]; then
        local dir_path
        dir_path=$(dirname "$file_path")
        if [ ! -w "$dir_path" ]; then
            log_error "Directory not writable: $dir_path"
            return 1
        fi
        
        if [ -f "$file_path" ] && [ ! -w "$file_path" ]; then
            log_error "File not writable: $file_path"
            return 1
        fi
    fi
    
    log_debug "File path validation passed: $file_path"
    return 0
}

# Validate directory path
validate_directory_path() {
    local dir_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$dir_path" ]; then
        log_error "Directory path cannot be empty"
        return 1
    fi
    
    # Check if directory must exist
    if [ "$must_exist" = "true" ] && [ ! -d "$dir_path" ]; then
        log_error "Directory does not exist: $dir_path"
        return 1
    fi
    
    # Check if directory must be writable
    if [ "$must_be_writable" = "true" ] && [ -d "$dir_path" ] && [ ! -w "$dir_path" ]; then
        log_error "Directory not writable: $dir_path"
        return 1
    fi
    
    log_debug "Directory path validation passed: $dir_path"
    return 0
}

# Validate URL format
validate_url() {
    local url="$1"
    
    if [ -z "$url" ]; then
        log_error "URL cannot be empty"
        return 1
    fi
    
    # Basic URL format validation
    if [[ "$url" =~ ^https?://[a-zA-Z0-9.-]+[a-zA-Z0-9]+(:[0-9]+)?(/.*)?$ ]]; then
        log_debug "URL format validation passed: $url"
        return 0
    else
        log_error "Invalid URL format: $url"
        return 1
    fi
}

# Validate version string
validate_version() {
    local version="$1"
    
    if [ -z "$version" ]; then
        log_error "Version cannot be empty"
        return 1
    fi
    
    # Semantic version format (major.minor.patch)
    if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
        log_debug "Version format validation passed: $version"
        return 0
    else
        log_error "Invalid version format: $version (expected: major.minor.patch)"
        return 1
    fi
}

# Validate shell type
validate_shell_type() {
    local shell_path="$1"
    
    if [ -z "$shell_path" ]; then
        shell_path="$SHELL"
    fi
    
    local shell_name
    shell_name=$(basename "$shell_path")
    
    case "$shell_name" in
        bash|zsh|sh)
            log_debug "Supported shell detected: $shell_name"
            return 0
            ;;
        *)
            log_warn "Shell may not be fully supported: $shell_name"
            return 0  # Warning only, don't fail
            ;;
    esac
}

# Validate configuration completeness
validate_configuration_completeness() {
    log_progress "Validating configuration completeness..."
    
    local errors=0
    
    # Check required variables from app.conf
    local required_app_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    for var in "${required_app_vars[@]}"; do
        if [ -z "${!var}" ]; then
            log_error "Required configuration variable not set: $var"
            ((errors++))
        fi
    done
    
    # Check model configuration
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_error "No models configured in MODEL_PROVIDERS"
        ((errors++))
    fi
    
    # Check provider configuration
    if [ -z "$AVAILABLE_PROVIDERS" ]; then
        log_error "No providers configured in AVAILABLE_PROVIDERS"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "Configuration completeness validation passed"
        return 0
    else
        log_error "Configuration completeness validation failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/installers/claude_installer.sh`:

```sh
#!/bin/bash

# Claude Code Installer Module
# Handles Claude Code CLI installation and configuration

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Claude Code CLI
install_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Installation"
    
    # Validate Node.js is available
    if ! validate_nodejs; then
        log_error "Node.js is required for Claude Code installation"
        return 1
    fi
    
    # Check if Claude Code is already installed
    if validate_claude_code; then
        log_info "Claude Code is already installed and working"
        _display_claude_info
        return 0
    fi
    
    log_progress "Installing Claude Code CLI package: $package_name"
    
    # Install via npm
    if _install_claude_npm "$package_name"; then
        log_success "Claude Code CLI installed successfully"
    else
        log_error "Failed to install Claude Code CLI"
        return 1
    fi
    
    # Configure Claude Code
    if _configure_claude_code; then
        log_success "Claude Code configured successfully"
    else
        log_warn "Claude Code installation succeeded but configuration failed"
    fi
    
    # Verify installation
    if validate_claude_code; then
        log_success "Claude Code installation and verification completed"
        _display_claude_info
        return 0
    else
        log_error "Claude Code installation verification failed"
        return 1
    fi
}

# Install Claude Code via npm
_install_claude_npm() {
    local package_name="$1"
    
    log_debug "Installing $package_name via npm..."
    
    # Check npm availability
    if ! command -v npm >/dev/null 2>&1; then
        log_error "npm command not found"
        return 1
    fi
    
    # Install globally with error handling
    local install_output
    if install_output=$(npm install -g "$package_name" 2>&1); then
        log_debug "npm install output: $install_output"
        return 0
    else
        log_error "npm install failed: $install_output"
        return 1
    fi
}

# Configure Claude Code
_configure_claude_code() {
    log_progress "Configuring Claude Code to skip onboarding..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    
    # Ensure Claude config directory exists
    if ! mkdir -p "$claude_config_dir"; then
        log_error "Failed to create Claude config directory: $claude_config_dir"
        return 1
    fi
    
    # Create or update configuration using Node.js
    local config_script='
        const fs = require("fs");
        const path = require("path");
        const os = require("os");
        const configPath = path.join(os.homedir(), ".claude.json");
        
        let config = {};
        if (fs.existsSync(configPath)) {
            try {
                const content = fs.readFileSync(configPath, "utf-8");
                config = JSON.parse(content);
            } catch (e) {
                console.error("Warning: Could not parse existing config, creating new one");
                config = {};
            }
        }
        
        config.hasCompletedOnboarding = true;
        
        try {
            fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
            console.log("Configuration updated successfully");
        } catch (e) {
            console.error("Failed to write configuration:", e.message);
            process.exit(1);
        }
    '
    
    if node -e "$config_script" 2>/dev/null; then
        log_success "Claude Code configuration updated"
        return 0
    else
        log_error "Failed to configure Claude Code"
        return 1
    fi
}

# Display Claude Code information
_display_claude_info() {
    log_info "Claude Code Installation Summary:"
    
    if command -v claude >/dev/null 2>&1; then
        local claude_version
        if claude_version=$(claude --version 2>/dev/null); then
            log_indent info "Claude Code version: $claude_version" 2
        else
            log_indent warn "Could not determine Claude Code version" 2
        fi
        
        local claude_path
        if claude_path=$(which claude 2>/dev/null); then
            log_indent info "Claude Code path: $claude_path" 2
        fi
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration file: $config_file" 2
        local onboarding_status
        if onboarding_status=$(node -e "
            try {
                const config = JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'));
                console.log(config.hasCompletedOnboarding ? 'completed' : 'pending');
            } catch (e) {
                console.log('unknown');
            }
        " 2>/dev/null); then
            log_indent info "Onboarding status: $onboarding_status" 2
        fi
    fi
}

# Update Claude Code
update_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Update"
    
    # Check current installation
    if ! validate_claude_code; then
        log_error "Claude Code not found. Please install it first."
        return 1
    fi
    
    log_progress "Updating Claude Code CLI package: $package_name"
    
    # Update via npm
    if _update_claude_npm "$package_name"; then
        log_success "Claude Code CLI updated successfully"
        _display_claude_info
        return 0
    else
        log_error "Failed to update Claude Code CLI"
        return 1
    fi
}

# Update Claude Code via npm
_update_claude_npm() {
    local package_name="$1"
    
    log_debug "Updating $package_name via npm..."
    
    local update_output
    if update_output=$(npm update -g "$package_name" 2>&1); then
        log_debug "npm update output: $update_output"
        return 0
    else
        log_error "npm update failed: $update_output"
        return 1
    fi
}

# Uninstall Claude Code
uninstall_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Uninstallation"
    
    # Check if Claude Code is installed
    if ! command -v claude >/dev/null 2>&1; then
        log_info "Claude Code not found, nothing to uninstall"
        return 0
    fi
    
    log_progress "Uninstalling Claude Code CLI package: $package_name"
    
    # Uninstall via npm
    if _uninstall_claude_npm "$package_name"; then
        log_success "Claude Code CLI uninstalled successfully"
    else
        log_error "Failed to uninstall Claude Code CLI"
        return 1
    fi
    
    # Clean up configuration (optional)
    local cleanup_config="${2:-false}"
    if [ "$cleanup_config" = "true" ]; then
        _cleanup_claude_config
    fi
    
    return 0
}

# Uninstall Claude Code via npm
_uninstall_claude_npm() {
    local package_name="$1"
    
    log_debug "Uninstalling $package_name via npm..."
    
    local uninstall_output
    if uninstall_output=$(npm uninstall -g "$package_name" 2>&1); then
        log_debug "npm uninstall output: $uninstall_output"
        return 0
    else
        log_error "npm uninstall failed: $uninstall_output"
        return 1
    fi
}

# Clean up Claude Code configuration
_cleanup_claude_config() {
    log_progress "Cleaning up Claude Code configuration..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    local claude_settings_file="$claude_config_dir/settings.json"
    
    # Remove configuration files
    local files_to_remove=("$claude_config_file" "$claude_settings_file")
    
    for file in "${files_to_remove[@]}"; do
        if [ -f "$file" ]; then
            log_debug "Removing configuration file: $file"
            rm -f "$file"
        fi
    done
    
    # Remove empty directory
    if [ -d "$claude_config_dir" ] && [ -z "$(ls -A "$claude_config_dir" 2>/dev/null)" ]; then
        log_debug "Removing empty Claude config directory: $claude_config_dir"
        rmdir "$claude_config_dir"
    fi
    
    log_success "Claude Code configuration cleanup completed"
}

# Test Claude Code installation
test_claude_installation() {
    log_header "Claude Code Installation Test"
    
    local errors=0
    
    # Test Claude command availability
    if command -v claude >/dev/null 2>&1; then
        log_success "Claude command is available"
    else
        log_error "Claude command not found"
        ((errors++))
    fi
    
    # Test Claude version command
    local version_output
    if version_output=$(claude --version 2>/dev/null); then
        log_success "Claude version command works: $version_output"
    else
        log_error "Claude version command failed"
        ((errors++))
    fi
    
    # Test Claude help command
    if claude --help >/dev/null 2>&1; then
        log_success "Claude help command works"
    else
        log_error "Claude help command failed"
        ((errors++))
    fi
    
    # Test configuration file
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_success "Claude configuration file exists"
        
        # Test configuration file validity
        if node -e "JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'))" 2>/dev/null; then
            log_success "Claude configuration file is valid JSON"
        else
            log_error "Claude configuration file has invalid JSON"
            ((errors++))
        fi
    else
        log_warn "Claude configuration file not found (may be created on first run)"
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Claude Code tests passed"
        return 0
    else
        log_error "Claude Code tests failed with $errors errors"
        return 1
    fi
}

# Get Claude Code status
get_claude_status() {
    log_info "Claude Code Status:"
    
    if command -v claude >/dev/null 2>&1; then
        log_indent success "Status: Installed" 2
        
        local version
        if version=$(claude --version 2>/dev/null); then
            log_indent info "Version: $version" 2
        fi
        
        local path
        if path=$(which claude 2>/dev/null); then
            log_indent info "Path: $path" 2
        fi
    else
        log_indent error "Status: Not installed" 2
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration: Found" 2
    else
        log_indent warn "Configuration: Not found" 2
    fi
}


```

`claude-model-switcher/lib/installers/nodejs_installer.sh`:

```sh
#!/bin/bash

# Node.js Installer Module
# Handles Node.js installation via NVM

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Node.js via NVM
install_nodejs() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    local nvm_version="${2:-$NVM_VERSION}"
    
    log_header "Node.js Installation"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met for Node.js installation"
        return 1
    fi
    
    # Check if Node.js is already installed and meets requirements
    if validate_nodejs "$min_version"; then
        log_info "Node.js already meets requirements, skipping installation"
        return 0
    fi
    
    local platform
    platform=$(uname -s)
    
    case "$platform" in
        Linux|Darwin)
            _install_nodejs_unix "$min_version" "$nvm_version"
            ;;
        *)
            log_error "Unsupported platform for Node.js installation: $platform"
            return 1
            ;;
    esac
}

# Install Node.js on Unix-like systems (Linux/macOS)
_install_nodejs_unix() {
    local min_version="$1"
    local nvm_version="$2"
    
    log_progress "Installing Node.js via NVM for Unix-like system..."
    
    # Check if NVM is already installed
    if [ -d "$HOME/.nvm" ]; then
        log_info "NVM directory already exists, sourcing existing installation..."
        _source_nvm
    else
        log_progress "Downloading and installing NVM $nvm_version..."
        if ! _install_nvm "$nvm_version"; then
            log_error "Failed to install NVM"
            return 1
        fi
    fi
    
    # Install Node.js LTS
    log_progress "Installing Node.js LTS version..."
    if ! _install_nodejs_lts; then
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Verify installation
    if validate_nodejs "$min_version"; then
        log_success "Node.js installation completed successfully"
        _display_nodejs_info
        return 0
    else
        log_error "Node.js installation verification failed"
        return 1
    fi
}

# Install NVM
_install_nvm() {
    local nvm_version="$1"
    local install_url="${NVM_INSTALL_URL:-https://raw.githubusercontent.com/nvm-sh/nvm/$nvm_version/install.sh}"
    
    log_debug "Downloading NVM from: $install_url"
    
    # Validate URL format
    if ! validate_url "$install_url"; then
        log_error "Invalid NVM install URL: $install_url"
        return 1
    fi
    
    # Download and execute NVM installer
    if curl -s -o- "$install_url" | bash; then
        log_success "NVM installation script executed successfully"
        _source_nvm
        return 0
    else
        log_error "Failed to download or execute NVM installer"
        return 1
    fi
}

# Source NVM environment
_source_nvm() {
    log_debug "Sourcing NVM environment..."
    
    export NVM_DIR="$HOME/.nvm"
    
    # Source NVM script
    if [ -s "$NVM_DIR/nvm.sh" ]; then
        source "$NVM_DIR/nvm.sh"
        log_debug "NVM script sourced successfully"
    else
        log_error "NVM script not found: $NVM_DIR/nvm.sh"
        return 1
    fi
    
    # Source NVM bash completion (optional)
    if [ -s "$NVM_DIR/bash_completion" ]; then
        source "$NVM_DIR/bash_completion"
        log_debug "NVM bash completion sourced"
    fi
    
    return 0
}

# Install Node.js LTS
_install_nodejs_lts() {
    # Ensure NVM is sourced
    if ! command -v nvm >/dev/null 2>&1; then
        if ! _source_nvm; then
            log_error "NVM not available after sourcing"
            return 1
        fi
    fi
    
    log_debug "Installing Node.js LTS via NVM..."
    
    # Install LTS version
    if nvm install --lts; then
        log_success "Node.js LTS installed successfully"
    else
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Use LTS version
    if nvm use --lts; then
        log_success "Switched to Node.js LTS"
    else
        log_error "Failed to switch to Node.js LTS"
        return 1
    fi
    
    # Set LTS as default
    if nvm alias default 'lts/*'; then
        log_success "Node.js LTS set as default"
    else
        log_warn "Failed to set Node.js LTS as default"
    fi
    
    return 0
}

# Display Node.js installation information
_display_nodejs_info() {
    log_info "Node.js Installation Summary:"
    
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_indent info "Node.js version: $node_version" 2
    fi
    
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_indent info "npm version: $npm_version" 2
    fi
    
    if command -v nvm >/dev/null 2>&1; then
        local nvm_version
        nvm_version=$(nvm --version 2>/dev/null)
        log_indent info "NVM version: $nvm_version" 2
    fi
}

# Check if Node.js upgrade is needed
check_nodejs_upgrade() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    
    if ! validate_nodejs "$min_version"; then
        log_info "Node.js upgrade recommended"
        return 1
    else
        log_info "Node.js version is up to date"
        return 0
    fi
}

# Upgrade Node.js to latest LTS
upgrade_nodejs() {
    log_header "Node.js Upgrade"
    
    # Check if NVM is available
    if [ ! -d "$HOME/.nvm" ]; then
        log_error "NVM not found. Please install Node.js first."
        return 1
    fi
    
    # Source NVM
    if ! _source_nvm; then
        log_error "Failed to source NVM environment"
        return 1
    fi
    
    log_progress "Upgrading to latest Node.js LTS..."
    
    # Install latest LTS
    if ! _install_nodejs_lts; then
        log_error "Failed to upgrade Node.js"
        return 1
    fi
    
    log_success "Node.js upgrade completed"
    _display_nodejs_info
    return 0
}

# Uninstall Node.js (remove NVM)
uninstall_nodejs() {
    log_header "Node.js Uninstallation"
    
    if [ -d "$HOME/.nvm" ]; then
        log_progress "Removing NVM directory..."
        rm -rf "$HOME/.nvm"
        log_success "NVM directory removed"
    else
        log_info "NVM directory not found, nothing to remove"
    fi
    
    # Remove NVM lines from shell configuration files
    local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    
    for shell_file in "${shell_files[@]}"; do
        if [ -f "$shell_file" ]; then
            if grep -q "NVM_DIR" "$shell_file"; then
                log_progress "Cleaning NVM configuration from: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.nvm_removal_backup"
                # Remove NVM lines
                sed -i '/NVM_DIR/d' "$shell_file"
                sed -i '/nvm.sh/d' "$shell_file"
                sed -i '/bash_completion/d' "$shell_file"
                log_success "NVM configuration removed from: $shell_file"
            fi
        fi
    done
    
    log_success "Node.js uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Test Node.js installation
test_nodejs_installation() {
    log_header "Node.js Installation Test"
    
    local errors=0
    
    # Test Node.js command
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js command available: $node_version"
    else
        log_error "Node.js command not found"
        ((errors++))
    fi
    
    # Test npm command
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_success "npm command available: $npm_version"
    else
        log_error "npm command not found"
        ((errors++))
    fi
    
    # Test simple Node.js execution
    local test_result
    test_result=$(node -e "console.log('Node.js test successful')" 2>/dev/null)
    if [ "$test_result" = "Node.js test successful" ]; then
        log_success "Node.js execution test passed"
    else
        log_error "Node.js execution test failed"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Node.js tests passed"
        return 0
    else
        log_error "Node.js tests failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/managers/model_manager.sh`:

```sh
#!/bin/bash

# Model Manager Module
# Handles model switching, listing, and configuration

# Source dependencies
# Note: Core modules (logger, validator, config_loader) are expected to be 
# available in the environment. This avoids circular dependencies during testing.

# List available models (implementation)
list_models_impl() {
    log_header "Available Models"
    
    # Reload configuration to get latest models
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if models are configured
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_warn "No models defined in $MODEL_CONFIG_FILE"
        return 1
    fi
    
    # Display table header
    local table_width="${TABLE_WIDTH:-110}"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    printf "%-12s %-12s %-25s %-25s %s\n" "Alias" "Provider" "Main Model" "Fast Model" "Context"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display models
    for alias in "${!MODEL_PROVIDERS[@]}"; do
        local provider="${MODEL_PROVIDERS[$alias]}"
        local main_model="${MODEL_API_NAMES[$alias]}"
        local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
        local context="${MODEL_CONTEXTS[$alias]:-N/A}"
        
        printf "%-12s %-12s %-25s %-25s %s\n" \
            "$alias" \
            "$provider" \
            "$main_model" \
            "$fast_model" \
            "$context"
    done
    
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display additional information
    log_info "Total models configured: ${#MODEL_PROVIDERS[@]}"
    log_info "Configuration file: $MODEL_CONFIG_FILE"
    
    return 0
}

# Use/switch to a specific model (implementation)
use_model_impl() {
    local alias="$1"
    local api_key="$2"  # Optional: can be provided or prompted
    
    log_header "Model Switching: $alias"
    
    # Validate input
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        log_info "Usage: use_model <alias> [api_key]"
        list_models
        return 1
    fi
    
    # Validate alias format
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    # Reload configuration
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if model exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found in configuration"
        list_models
        return 1
    fi
    
    # Get model properties
    local provider="${MODEL_PROVIDERS[$alias]}"
    local main_model="${MODEL_API_NAMES[$alias]}"
    local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
    local context_info="${MODEL_CONTEXTS[$alias]}"
    local description="${MODEL_DESCRIPTIONS[$alias]:-N/A}"
    
    # Validate provider
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    # Configure provider-specific settings
    if ! _configure_provider "$provider" "$alias" "$api_key"; then
        log_error "Failed to configure provider: $provider"
        return 1
    fi
    
    # Set model environment variables
    export ANTHROPIC_MODEL="$main_model"
    export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
    log_success "Model environment variables configured: $main_model | $fast_model"
    
    # Save environment variables for persistence
    _save_current_env_vars "$provider" "$main_model" "$fast_model"
    
    # Configure Claude Code settings
    if ! _configure_claude_settings "$alias" "$main_model" "$fast_model" "$context_info"; then
        log_error "Failed to configure Claude Code settings"
        return 1
    fi
    
    # Update memory/context file
    if ! _update_model_context "$alias" "$provider" "$main_model" "$fast_model" "$context_info" "$description"; then
        log_warn "Failed to update model context file"
    fi
    
    log_success "Successfully switched to model: $alias"
    _display_active_model_info "$alias" "$provider" "$main_model" "$fast_model" "$context_info"
    
    return 0
}

# Configure provider-specific settings
_configure_provider() {
    local provider="$1"
    local alias="$2"
    local api_key="$3"
    
    log_progress "Configuring provider: $provider"
    
    # Get provider configuration
    local base_url_var="PROVIDER_${provider^^}_BASE_URL"
    local base_url="${!base_url_var}"
    
    if [ -z "$base_url" ]; then
        log_error "Base URL not configured for provider: $provider"
        return 1
    fi
    
    # Validate base URL
    if ! validate_url "$base_url"; then
        log_error "Invalid base URL for provider $provider: $base_url"
        return 1
    fi
    
    # Set base URL
    export ANTHROPIC_BASE_URL="$base_url"
    log_success "Base URL configured: $base_url"
    
    # Handle API key
    if [ -z "$api_key" ]; then
        log_info "Please enter your $provider API key (input hidden):"
        read -s api_key
        echo  # New line after hidden input
    fi
    
    # Validate API key
    if ! validate_api_key "$api_key" "$provider"; then
        log_error "Invalid API key format"
        return 1
    fi
    
    # Set API key
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    log_success "API key configured for this session"
    
    return 0
}

# Configure Claude Code settings
_configure_claude_settings() {
    local alias="$1"
    local main_model="$2"
    local fast_model="$3"
    local context_info="$4"
    
    log_progress "Configuring Claude Code settings..."
    
    local claude_dir="$HOME/.claude"
    local settings_file="$claude_dir/settings.json"
    
    # Ensure Claude directory exists
    mkdir -p "$claude_dir"
    
    # Get configuration values
    local temperature="${CLAUDE_DEFAULT_TEMPERATURE:-0.6}"
    local timeout="${CLAUDE_DEFAULT_TIMEOUT:-300000}"
    
    # Create settings JSON
    local settings_content
    settings_content=$(cat << EOF
{
  "model": "$main_model",
  "env": {
    "CLAUDE_CODE_TEMPERATURE": "$temperature",
    "BASH_DEFAULT_TIMEOUT_MS": "$timeout",
    "ANTHROPIC_MODEL": "$main_model",
    "ANTHROPIC_SMALL_FAST_MODEL": "$fast_model"
  },
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "echo 'ğŸ¤– Active: $main_model ($alias) | Fast: $fast_model | Context: $context_info | T:$temperature | Timeout:${timeout}ms'"
      }
    ]
  }
}
EOF
    )
    
    # Write settings file
    if echo "$settings_content" > "$settings_file"; then
        log_success "Claude Code settings updated: $settings_file"
        return 0
    else
        log_error "Failed to write Claude Code settings file"
        return 1
    fi
}

# Update model context file
_update_model_context() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    local description="$6"
    
    local memory_file="$MEMORY_DIR/model-context.md"
    
    # Ensure memory directory exists
    mkdir -p "$MEMORY_DIR"
    
    # Create context content
    local context_content
    context_content=$(cat << EOF
# Model Context Reference

## Current Configuration
- **Provider**: $provider
- **Alias**: $alias
- **Main Model**: $main_model
- **Fast Model**: $fast_model
- **Context Window**: $context_info
- **Description**: $description
- **Temperature**: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6} (Programming Mode)
- **Timeout**: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms (5 minutes)
- **Last Updated**: $(date)

## Environment Variables
- **ANTHROPIC_BASE_URL**: ${ANTHROPIC_BASE_URL:-Not set}
- **ANTHROPIC_MODEL**: $main_model
- **ANTHROPIC_SMALL_FAST_MODEL**: $fast_model

## Usage Instructions
1. Use \`claude "your prompt here"\` for general queries
2. The system automatically selects between main and fast models based on task complexity
3. Programming assistance is optimized with temperature 0.6
4. Session timeout is set to 5 minutes for long-running tasks

## Provider Information
- **Base URL**: ${ANTHROPIC_BASE_URL:-Not configured}
- **Authentication**: Session-based (API key required per session)

---
*Generated by Claude Model Switcher v${APP_VERSION:-5.0.0}*
EOF
    )
    
    # Write context file
    if echo "$context_content" > "$memory_file"; then
        log_debug "Model context file updated: $memory_file"
        return 0
    else
        log_warn "Failed to update model context file: $memory_file"
        return 1
    fi
}

# Display active model information
_display_active_model_info() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    
    log_info "Active Model Configuration:"
    log_indent info "Alias: $alias" 2
    log_indent info "Provider: $provider" 2
    log_indent info "Main Model: $main_model" 2
    log_indent info "Fast Model: $fast_model" 2
    log_indent info "Context: $context_info" 2
    log_indent info "Temperature: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6}" 2
    log_indent info "Timeout: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms" 2
    
    log_info "Ready to use Claude Code with: claude \"your prompt here\""
}

# Get current model status
get_model_status() {
    log_info "Current Model Status:"
    
    # Check environment variables
    if [ -n "$ANTHROPIC_MODEL" ]; then
        log_indent success "Main Model: $ANTHROPIC_MODEL" 2
    else
        log_indent warn "Main Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_SMALL_FAST_MODEL" ]; then
        log_indent success "Fast Model: $ANTHROPIC_SMALL_FAST_MODEL" 2
    else
        log_indent warn "Fast Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_BASE_URL" ]; then
        log_indent success "Base URL: $ANTHROPIC_BASE_URL" 2
    else
        log_indent warn "Base URL: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
        log_indent success "API Key: Configured" 2
    else
        log_indent warn "API Key: Not configured" 2
    fi
    
    # Check settings file
    local settings_file="$HOME/.claude/settings.json"
    if [ -f "$settings_file" ]; then
        log_indent success "Settings File: $settings_file" 2
    else
        log_indent warn "Settings File: Not found" 2
    fi
    
    # Check context file
    local context_file="$MEMORY_DIR/model-context.md"
    if [ -f "$context_file" ]; then
        log_indent success "Context File: $context_file" 2
    else
        log_indent warn "Context File: Not found" 2
    fi
}

# Add a new model to configuration
add_model() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context="$5"
    local description="$6"
    
    log_header "Adding New Model: $alias"
    
    # Validate inputs
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    if [ -z "$main_model" ]; then
        log_error "Main model name is required"
        return 1
    fi
    
    # Set defaults
    fast_model="${fast_model:-$main_model}"
    context="${context:-N/A}"
    description="${description:-Custom model configuration}"
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias already exists
    if [ -n "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' already exists"
        return 1
    fi
    
    # Add model to configuration file
    log_progress "Adding model to configuration file..."
    
    local new_model_config
    new_model_config=$(cat << EOF

# Model Alias: '$alias' - $description
MODEL_PROVIDERS["$alias"]="$provider"
MODEL_API_NAMES["$alias"]="$main_model"
MODEL_SMALL_FAST_NAMES["$alias"]="$fast_model"
MODEL_CONTEXTS["$alias"]="$context"
MODEL_DESCRIPTIONS["$alias"]="$description"
EOF
    )
    
    # Append to configuration file
    if echo "$new_model_config" >> "$MODEL_CONFIG_FILE"; then
        log_success "Model '$alias' added to configuration"
        
        # Update AVAILABLE_MODELS list
        local current_models
        current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
        local updated_models="$current_models $alias"
        
        # Update the AVAILABLE_MODELS line
        sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
        
        log_success "Model successfully added and configuration updated"
        return 0
    else
        log_error "Failed to add model to configuration file"
        return 1
    fi
}

# Remove a model from configuration
remove_model() {
    local alias="$1"
    
    log_header "Removing Model: $alias"
    
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        return 1
    fi
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found"
        return 1
    fi
    
    # Create backup
    local backup_file="${MODEL_CONFIG_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    if cp "$MODEL_CONFIG_FILE" "$backup_file"; then
        log_success "Configuration backup created: $backup_file"
    else
        log_warn "Failed to create backup, proceeding anyway"
    fi
    
    # Remove model entries from configuration file
    log_progress "Removing model entries from configuration..."
    
    # Remove all lines related to this model
    sed -i "/MODEL_PROVIDERS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_API_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_SMALL_FAST_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_CONTEXTS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_DESCRIPTIONS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    
    # Update AVAILABLE_MODELS list
    local current_models
    current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
    local updated_models
    updated_models=$(echo "$current_models" | sed "s/\b$alias\b//g" | tr -s ' ' | sed 's/^ *//;s/ *$//')
    
    sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
    
    log_success "Model '$alias' removed from configuration"
    return 0
}

# Save current environment variables for persistence
_save_current_env_vars() {
    local provider="$1"
    local main_model="$2"
    local fast_model="$3"
    
    local env_file="$CONFIG_DIR/current_env.conf"
    
    # Create environment configuration content
    local env_content
    env_content=$(cat << EOF
# Current Model Environment Variables
# This file is automatically managed by the model switcher
# Last updated: $(date)

export ANTHROPIC_BASE_URL="$ANTHROPIC_BASE_URL"
export ANTHROPIC_AUTH_TOKEN="$ANTHROPIC_AUTH_TOKEN"
export ANTHROPIC_MODEL="$main_model"
export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
EOF
    )
    
    # Write environment file
    if echo "$env_content" > "$env_file"; then
        log_success "Environment variables saved for persistence"
        return 0
    else
        log_warn "Failed to save environment variables"
        return 1
    fi
}

# Load persisted environment variables
load_persisted_env_vars() {
    local env_file="$CONFIG_DIR/current_env.conf"
    
    if [ -f "$env_file" ]; then
        source "$env_file"
        return 0
    fi
    
    return 1
}


```

`claude-model-switcher/main.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Main Entry Point
# Version 5.0.0 - Modular Architecture
# A robust installer and manager for Claude Code with multi-model support

set -e

# --- Script Metadata ---
SCRIPT_VERSION="5.0.0"
SCRIPT_NAME="Claude Model Switcher"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Bootstrap Configuration ---
# Load base configuration to get directory paths
if [ -f "$SCRIPT_DIR/config/app.conf" ]; then
    source "$SCRIPT_DIR/config/app.conf"
else
    echo "âŒ Error: Configuration file not found: $SCRIPT_DIR/config/app.conf"
    echo "Please ensure the script is run from the correct directory."
    exit 1
fi

# --- Module Loading ---
# Load core modules
source "$SCRIPT_DIR/lib/core/logger.sh"
source "$SCRIPT_DIR/lib/core/config_loader.sh"
source "$SCRIPT_DIR/lib/core/validator.sh"

# Load installer modules
source "$SCRIPT_DIR/lib/installers/nodejs_installer.sh"
source "$SCRIPT_DIR/lib/installers/claude_installer.sh"

# Load manager modules
source "$SCRIPT_DIR/lib/managers/model_manager.sh"

# --- Initialization ---
initialize_system() {
    # Initialize logger
    logger_init
    
    log_header "$SCRIPT_NAME v$SCRIPT_VERSION"
    log_info "Initializing modular system..."
    
    # Load all configurations
    if ! config_load_all "$SCRIPT_DIR/config"; then
        log_error "Failed to load configurations"
        return 1
    fi
    
    # Validate environment
    if ! config_validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi
    
    log_success "System initialization completed"
    return 0
}

# --- Command Functions ---

# Install command - Full installation process
cmd_install() {
    log_header "Full Installation Process"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met"
        return 1
    fi
    
    # Install Node.js if needed
    log_progress "Step 1: Node.js Installation"
    if ! install_nodejs; then
        log_error "Node.js installation failed"
        return 1
    fi
    
    # Install Claude Code
    log_progress "Step 2: Claude Code Installation"
    if ! install_claude_code; then
        log_error "Claude Code installation failed"
        return 1
    fi
    
    # Setup shell integration
    log_progress "Step 3: Shell Integration Setup"
    if ! setup_shell_integration; then
        log_error "Shell integration setup failed"
        return 1
    fi
    
    # Display completion message
    display_installation_complete
    
    return 0
}

# Setup shell integration
setup_shell_integration() {
    log_progress "Setting up shell integration..."
    
    # Detect shell
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    log_info "Detected shell: $current_shell"
    log_info "Configuration file: $rc_file"
    
    # Create backup
    if [ -f "$rc_file" ]; then
        local backup_file="$rc_file.claude_backup.$(date +%Y%m%d_%H%M%S)"
        if cp "$rc_file" "$backup_file"; then
            log_success "Backup created: $backup_file"
        else
            log_warn "Failed to create backup"
        fi
        
        # Remove old configuration block
        sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
    fi
    
    # Add new configuration block
    local shell_config
    shell_config=$(cat << 'EOF'

# CLAUDE_CODE_MODEL_MANAGER_V5
# --- Claude Model Switcher (Modular Architecture) ---
# This block is managed automatically by the installation script.

# Define paths for the switcher's files.
export CLAUDE_SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
export CLAUDE_MODELS_CONF="$CLAUDE_SWITCHER_DIR/config/models.conf"

# Load the modular system
if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ]; then
    # Source configuration
    [ -f "$CLAUDE_SWITCHER_DIR/config/app.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/app.conf"
    [ -f "$CLAUDE_SWITCHER_DIR/config/providers.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/providers.conf"
    
    # Pre-declare associative arrays before loading models.conf
    declare -gA MODEL_PROVIDERS 2>/dev/null || true
    declare -gA MODEL_API_NAMES 2>/dev/null || true
    declare -gA MODEL_CONTEXTS 2>/dev/null || true
    declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
    declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
    declare -gA MODEL_CAPABILITIES 2>/dev/null || true
    
    [ -f "$CLAUDE_SWITCHER_DIR/config/models.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/models.conf"
    
    # Source core modules
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh"
    
    # Initialize logger for shell functions
    logger_init >/dev/null 2>&1
    
    # Load persisted environment variables if available
    if declare -f load_persisted_env_vars >/dev/null 2>&1; then
        load_persisted_env_vars >/dev/null 2>&1 || true
    fi
fi

# Shell functions for user interaction
list_models() {
    # Check if the modular system is loaded
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f list_models_impl >/dev/null 2>&1; then
        list_models_impl "$@"
    else
        echo "âŒ Claude Model Switcher not properly installed"
        echo "ğŸ’¡ Try running: source ~/.bashrc"
        return 1
    fi
}

use_model() {
    # Check if the modular system is loaded  
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f use_model_impl >/dev/null 2>&1; then
        use_model_impl "$@"
    else
        echo "âŒ Claude Model Switcher not properly installed"
        echo "ğŸ’¡ Try running: source ~/.bashrc"
        return 1
    fi
}

# END_OF_CLAUDE_CONFIG
EOF
    )
    
    # Append configuration
    if echo "$shell_config" >> "$rc_file"; then
        log_success "Shell integration configured: $rc_file"
        return 0
    else
        log_error "Failed to configure shell integration"
        return 1
    fi
}

# Display installation complete message
display_installation_complete() {
    log_header "Installation Complete!"
    
    echo ""
    log_success "ğŸ‰ Claude Model Switcher v$SCRIPT_VERSION is ready!"
    echo ""
    
    log_info "Next Steps:"
    log_indent info "1. Refresh your environment:" 2
    log_indent info "   source ~/.bashrc  # or ~/.zshrc" 4
    echo ""
    
    log_indent info "2. List available models:" 2
    log_indent info "   list_models" 4
    echo ""
    
    log_indent info "3. Switch to a model:" 2
    log_indent info "   use_model kimi" 4
    log_indent info "   use_model glm4" 4
    echo ""
    
    log_indent info "4. Start using Claude Code:" 2
    log_indent info "   claude \"your prompt here\"" 4
    echo ""
    
    log_info "Configuration Files:"
    log_indent info "â€¢ Models: $MODEL_CONFIG_FILE" 2
    log_indent info "â€¢ Providers: $PROVIDERS_CONFIG_FILE" 2
    log_indent info "â€¢ Application: $SCRIPT_DIR/config/app.conf" 2
    echo ""
    
    log_info "For help: $SCRIPT_DIR/main.sh --help"
}

# Uninstall command
cmd_uninstall() {
    log_header "Uninstallation Process"
    
    echo "This will remove Claude Model Switcher and all its components."
    echo -n "Are you sure you want to continue? [y/N]: "
    read -r confirmation
    
    case "$confirmation" in
        [yY]|[yY][eE][sS])
            log_progress "Proceeding with uninstallation..."
            ;;
        *)
            log_info "Uninstallation cancelled"
            return 0
            ;;
    esac
    
    # Remove shell integration
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    if [ -f "$rc_file" ]; then
        if grep -q "$SHELL_CONFIG_MARKER" "$rc_file"; then
            log_progress "Removing shell integration..."
            
            # Create backup
            local backup_file="$rc_file.uninstall_backup.$(date +%Y%m%d_%H%M%S)"
            cp "$rc_file" "$backup_file"
            
            # Remove configuration block
            sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
            log_success "Shell integration removed. Backup: $backup_file"
        fi
    fi
    
    # Remove switcher directory
    if [ -d "$SWITCHER_DIR" ]; then
        log_progress "Removing switcher directory: $SWITCHER_DIR"
        rm -rf "$SWITCHER_DIR"
        
        # After removing the directory, disable file logging to avoid errors
        # since the log directory no longer exists
        export LOGGER_FILE=""
        
        log_success "Switcher directory removed"
    fi
    
    # Optionally remove Claude Code (ask user)
    echo -n "Do you want to remove Claude Code CLI as well? [y/N]: "
    read -r remove_claude
    
    case "$remove_claude" in
        [yY]|[yY][eE][sS])
            uninstall_claude_code "" "true"
            ;;
        *)
            log_info "Claude Code CLI preserved"
            ;;
    esac
    
    log_success "ğŸ‰ Uninstallation completed successfully"
    log_info "Please restart your terminal for changes to take effect"
    
    return 0
}

# Status command
cmd_status() {
    log_header "System Status"
    
    # System requirements
    log_progress "Checking system requirements..."
    validate_system_requirements
    echo ""
    
    # Node.js status
    log_progress "Checking Node.js..."
    if validate_nodejs; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js: $node_version"
    else
        log_warn "Node.js: Not installed or version too old"
    fi
    echo ""
    
    # Claude Code status
    log_progress "Checking Claude Code..."
    if validate_claude_code; then
        local claude_version
        claude_version=$(claude --version 2>/dev/null)
        log_success "Claude Code: $claude_version"
    else
        log_warn "Claude Code: Not installed"
    fi
    echo ""
    
    # Model configuration
    log_progress "Checking model configuration..."
    get_model_status
    echo ""
    
    # Configuration files
    log_progress "Checking configuration files..."
    local config_files=(
        "$SCRIPT_DIR/config/app.conf"
        "$SCRIPT_DIR/config/models.conf"
        "$SCRIPT_DIR/config/providers.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            log_indent success "$(basename "$config_file"): Found" 2
        else
            log_indent error "$(basename "$config_file"): Missing" 2
        fi
    done
    
    return 0
}

# Help command
cmd_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION - Modular Architecture

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    install         Full installation process (Node.js + Claude Code + Shell integration)
    uninstall       Remove Claude Model Switcher and optionally Claude Code
    status          Show system and component status
    list-models     List all available models
    use-model       Switch to a specific model
    add-model       Add a new model to configuration
    remove-model    Remove a model from configuration
    update          Update Claude Code to latest version
    test            Run system tests
    help            Show this help message

EXAMPLES:
    # Full installation
    $0 install

    # List available models
    $0 list-models

    # Switch to a model
    $0 use-model kimi

    # Add a custom model
    $0 add-model my-model openai gpt-4 gpt-3.5-turbo "8K tokens" "Custom GPT-4 configuration"

    # Check system status
    $0 status

    # Uninstall everything
    $0 uninstall

SHELL FUNCTIONS (available after installation):
    list_models     List available models
    use_model       Switch to a model

CONFIGURATION:
    â€¢ Application: $SCRIPT_DIR/config/app.conf
    â€¢ Models: $SCRIPT_DIR/config/models.conf
    â€¢ Providers: $SCRIPT_DIR/config/providers.conf

For more information, visit: https://github.com/your-repo/claude-model-switcher
EOF
}

# --- Command Line Interface ---

# Parse command line arguments
parse_arguments() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        "install")
            cmd_install "$@"
            ;;
        "uninstall")
            cmd_uninstall "$@"
            ;;
        "status")
            cmd_status "$@"
            ;;
        "list-models")
            list_models_impl "$@"
            ;;
        "use-model")
            use_model_impl "$@"
            ;;
        "add-model")
            add_model "$@"
            ;;
        "remove-model")
            remove_model "$@"
            ;;
        "update")
            update_claude_code "$@"
            ;;
        "test")
            cmd_test "$@"
            ;;
        "help"|"--help"|"-h")
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

# Test command
cmd_test() {
    log_header "System Tests"
    
    local errors=0
    
    # Test Node.js
    if ! test_nodejs_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test Claude Code
    if ! test_claude_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test configuration
    log_progress "Testing configuration..."
    if ! validate_configuration_completeness; then
        ((errors++))
    fi
    echo ""
    
    if [ $errors -eq 0 ]; then
        log_success "ğŸ‰ All tests passed!"
        return 0
    else
        log_error "âŒ Tests failed with $errors errors"
        return 1
    fi
}

# --- Main Execution ---

main() {
    # Initialize system
    if ! initialize_system; then
        echo "âŒ Failed to initialize system"
        exit 1
    fi
    
    # Parse and execute command
    parse_arguments "$@"
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi


```

`claude-model-switcher/tests/bdd/test_user_scenarios.sh`:

```sh
#!/bin/bash

# BDD Tests - User Scenarios

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger first
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    source "$PROJECT_DIR/lib/managers/model_manager.sh"
    
    # Create mock environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    
    # Setup configuration
    mkdir -p "$CONFIG_DIR"
    cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
    config_load_all "$CONFIG_DIR"
}

# Scenario: User wants to list available models
describe "BDD Scenario: Listing Available Models"

context "Given that the system is properly configured"

it "should have model configuration loaded"
assert_success "Model configuration should be loaded" "[ \${#MODEL_PROVIDERS[@]} -gt 0 ]"

context "When the user runs list_models command"

it "should display available models without errors"
# Capture output to verify content
output=$(list_models 2>&1)
assert_success "list_models should execute successfully" "list_models >/dev/null 2>&1"

it "should show model information in table format"
output=$(list_models 2>&1)
assert_contains "Output should contain table header" "$output" "Alias"
assert_contains "Output should contain provider column" "$output" "Provider"
assert_contains "Output should contain kimi model" "$output" "kimi"
assert_contains "Output should contain glm4 model" "$output" "glm4"

# Scenario: User wants to switch to a model (dry run)
describe "BDD Scenario: Model Switching (Validation Only)"

context "Given that models are configured"

it "should validate model alias before switching"
assert_success "Valid alias should pass validation" "validate_model_alias 'kimi'"
assert_failure "Invalid alias should fail validation" "validate_model_alias 'invalid@model'"

context "When user provides a valid model alias"

it "should find the model in configuration"
source "$MODEL_CONFIG_FILE"
assert_success "kimi model should exist in configuration" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"

it "should validate the provider"
provider="${MODEL_PROVIDERS[kimi]}"
assert_success "Provider should be valid" "validate_provider_name '$provider' '$AVAILABLE_PROVIDERS'"

# Scenario: User adds a custom model
describe "BDD Scenario: Adding Custom Model"

context "Given that the user wants to add a new model"

it "should validate new model parameters"
assert_success "New alias should be valid" "validate_model_alias 'custom-model'"
assert_success "Provider should be valid" "validate_provider_name 'moonshot' '$AVAILABLE_PROVIDERS'"

context "When the user adds the model"

it "should accept valid model configuration"
# Test the validation logic that would be used in add_model function
alias="custom-model"
provider="moonshot"
main_model="custom-api-model"
fast_model="custom-api-model-fast"
context="100K tokens"
description="Custom test model"

assert_success "All parameters should validate" "
    validate_model_alias '$alias' && 
    validate_provider_name '$provider' '$AVAILABLE_PROVIDERS' &&
    [ -n '$main_model' ] &&
    [ -n '$fast_model' ]
"

# Scenario: System health check
describe "BDD Scenario: System Health Check"

context "Given that the system is installed"

it "should have all required directories"
config_validate_environment >/dev/null 2>&1
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

context "When checking configuration files"

it "should have all required configuration files"
assert_file_exists "App config should exist" "$CONFIG_DIR/app.conf"
assert_file_exists "Models config should exist" "$CONFIG_DIR/models.conf"
assert_file_exists "Providers config should exist" "$CONFIG_DIR/providers.conf"

context "When validating configuration content"

it "should have valid configuration syntax"
assert_success "App config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/app.conf'"
assert_success "Models config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/models.conf'"
assert_success "Providers config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/providers.conf'"

# Scenario: Error handling
describe "BDD Scenario: Error Handling"

context "Given that user provides invalid input"

it "should handle empty model alias gracefully"
# This should fail gracefully, not crash
assert_failure "Empty alias should be rejected" "validate_model_alias ''"

it "should handle unknown model alias gracefully"
# Load config first
source "$MODEL_CONFIG_FILE"
# Check for non-existent model
assert_equals "Unknown model should return empty provider" "" "${MODEL_PROVIDERS[nonexistent]}"

context "When configuration files are missing"

it "should handle missing config files gracefully"
# Test with non-existent config file
assert_failure "Missing config file should fail gracefully" "config_load '/nonexistent/path/config.conf'"
```

`claude-model-switcher/tests/integration/test_installation.sh`:

```sh
#!/bin/bash

# Integration Tests for Installation Process

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="INFO"
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    
    # Create mock installation environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    
    # Override paths for testing (force override after app.conf)
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export LIB_DIR="$SWITCHER_DIR/lib"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    

}

teardown_all() {
    # Clean up mock environment
    rm -rf "$MOCK_HOME"
}

# Test configuration loading
describe "Integration Tests - Configuration System"

context "When loading configurations"

it "should load all configuration files successfully"
# Copy config files to test environment
mkdir -p "$CONFIG_DIR"
cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
assert_success "All configurations should load" "config_load_all \"$CONFIG_DIR\""

it "should validate configuration completeness"
# Use the absolute path from setup_all to avoid variable override issues
test_config_dir="$TEMP_DIR/mock_home/.claude/claude-model-switcher/config"
test_config_validation() {
    local config_dir="$1"
    config_load_all "$config_dir" "true" && validate_configuration_completeness
}
assert_success "Configuration should be complete" "test_config_validation '$test_config_dir'"

# Test directory structure creation
describe "Integration Tests - Directory Structure"

context "When creating directory structure"

it "should create all required directories"
assert_success "Environment validation should create directories" "config_validate_environment"

it "should create switcher directory"
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"

it "should create config directory"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"

it "should create memory directory"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

it "should create log directory"
assert_dir_exists "Log directory should exist" "$LOG_DIR"

# Test model configuration
describe "Integration Tests - Model Configuration"

context "When working with model configuration"

it "should load model definitions"
assert_success "Model configuration should load" "config_load '$MODEL_CONFIG_FILE'"

it "should have default models configured"
# Source the models config to check arrays
source "$MODEL_CONFIG_FILE"
assert_success "Should have kimi model" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"
assert_success "Should have glm4 model" "[ -n \"\${MODEL_PROVIDERS[glm4]}\" ]"

# Test system validation
describe "Integration Tests - System Validation"

context "When validating system requirements"

it "should validate bash version"
assert_success "Bash version should be valid" "validate_shell_type"

it "should check required commands"
assert_success "Required commands should be available" "command -v curl && command -v sed && command -v grep"
```

`claude-model-switcher/tests/results/test_report.txt`:

```txt
Claude Model Switcher - Test Report
Generated: Tue Aug 19 02:20:26 UTC 2025

TEST SUMMARY:
=============
Total Tests: 86
Passed: 86
Failed: 0
Skipped: 0

PASS RATE: 100%

RESULT: PASSED

```

`claude-model-switcher/tests/test_runner.sh`:

```sh
#!/bin/bash

# Test Runner - Simple TDD/BDD Framework for Bash
# Supports unit tests, integration tests, and BDD scenarios

# Test framework configuration
TEST_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$TEST_DIR")"
RESULTS_DIR="$TEST_DIR/results"
TEMP_DIR="$TEST_DIR/temp"

# Test statistics
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test framework functions

# Initialize test environment
test_init() {
    echo -e "${BLUE}ğŸ§ª Initializing Test Environment${NC}"
    
    # Create necessary directories
    mkdir -p "$RESULTS_DIR"
    mkdir -p "$TEMP_DIR"
    
    # Clean up previous test results
    rm -f "$RESULTS_DIR"/*.log
    rm -rf "$TEMP_DIR"/*
    
    # Initialize test statistics
    TESTS_TOTAL=0
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_SKIPPED=0
    
    echo "Test directory: $TEST_DIR"
    echo "Project directory: $PROJECT_DIR"
    echo "Results directory: $RESULTS_DIR"
    echo ""
}

# Test assertion functions

# Assert that a command succeeds
assert_success() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  âœ“ $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Command: $command"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a command fails
assert_failure() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  âœ— $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${RED}FAIL${NC}"
        echo "    Expected command to fail: $command"
        ((TESTS_FAILED++))
        return 1
    else
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    fi
}

# Assert that two strings are equal
assert_equals() {
    local description="$1"
    local expected="$2"
    local actual="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  = $description... "
    
    if [ "$expected" = "$actual" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Expected: '$expected'"
        echo "    Actual: '$actual'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a file exists
assert_file_exists() {
    local description="$1"
    local file_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ“ $description... "
    
    if [ -f "$file_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    File not found: $file_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a directory exists
assert_dir_exists() {
    local description="$1"
    local dir_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ“‚ $description... "
    
    if [ -d "$dir_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Directory not found: $dir_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a string contains a substring
assert_contains() {
    local description="$1"
    local haystack="$2"
    local needle="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ” $description... "
    
    if [[ "$haystack" == *"$needle"* ]]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    String '$needle' not found in: '$haystack'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Skip a test
skip_test() {
    local description="$1"
    local reason="$2"
    
    ((TESTS_TOTAL++))
    ((TESTS_SKIPPED++))
    
    echo -e "  â­ï¸  $description... ${YELLOW}SKIP${NC}"
    if [ -n "$reason" ]; then
        echo "    Reason: $reason"
    fi
}

# BDD-style functions

# Describe a test suite
describe() {
    local suite_name="$1"
    echo -e "${BLUE}ğŸ“‹ $suite_name${NC}"
}

# Define a test context
context() {
    local context_name="$1"
    echo -e "${BLUE}  ğŸ“ $context_name${NC}"
}

# Define a test case
it() {
    local test_name="$1"
    echo -e "    ğŸ§ª $test_name"
}

# Test setup and teardown - empty by default
setup() { :; }
teardown() { :; }
setup_all() { :; }
teardown_all() { :; }

# Test discovery and execution

# Run a single test file
run_test_file() {
    local test_file="$1"
    
    if [ ! -f "$test_file" ]; then
        echo -e "${RED}âŒ Test file not found: $test_file${NC}"
        return 1
    fi
    
    echo -e "${BLUE}ğŸš€ Running test file: $(basename "$test_file")${NC}"
    echo ""
    
    # Reset functions for this test file
    setup_all() { :; }
    teardown_all() { :; }
    
    # Source the test file in a controlled manner
    set +e  # Don't exit on errors
    
    # First, source only the function definitions (setup_all, teardown_all)
    # by creating a temporary file with only function definitions
    local temp_functions_file="$TEMP_DIR/$(basename "$test_file").functions"
    
    # Extract function definitions from the test file
    awk '/^(setup_all|teardown_all)\(\)/ {p=1} p && /^}$/ {print; p=0; next} p' "$test_file" > "$temp_functions_file"
    
    # Source the function definitions
    source "$temp_functions_file"
    
    # If setup_all is defined, call it first
    if declare -f setup_all >/dev/null 2>&1; then
        setup_all 2>/dev/null || echo -e "${YELLOW}âš ï¸  Warning: setup_all failed${NC}"
    fi
    
    # Now source the full test file to run the tests
    source "$test_file"
    
    # If teardown_all is defined, call it
    if declare -f teardown_all >/dev/null 2>&1; then
        teardown_all 2>/dev/null || echo -e "${YELLOW}âš ï¸  Warning: teardown_all failed${NC}"
    fi
    
    # Clean up temporary file
    rm -f "$temp_functions_file"
    
    set -e  # Re-enable exit on error
    
    echo ""
    return 0
}

# Run all test files in a directory
run_test_directory() {
    local test_dir="$1"
    
    if [ ! -d "$test_dir" ]; then
        echo -e "${RED}âŒ Test directory not found: $test_dir${NC}"
        return 1
    fi
    
    echo -e "${BLUE}ğŸ” Discovering tests in: $test_dir${NC}"
    
    local test_files
    test_files=($(find "$test_dir" -name "test_*.sh" -type f | sort))
    
    if [ ${#test_files[@]} -eq 0 ]; then
        echo -e "${YELLOW}âš ï¸  No test files found in: $test_dir${NC}"
        return 0
    fi
    
    echo "Found ${#test_files[@]} test files"
    echo ""
    
    for test_file in "${test_files[@]}"; do
        run_test_file "$test_file"
    done
}

# Generate test report
generate_report() {
    local report_file="$RESULTS_DIR/test_report.txt"
    
    echo "Generating test report: $report_file"
    
    cat > "$report_file" << EOF
Claude Model Switcher - Test Report
Generated: $(date)

TEST SUMMARY:
=============
Total Tests: $TESTS_TOTAL
Passed: $TESTS_PASSED
Failed: $TESTS_FAILED
Skipped: $TESTS_SKIPPED

PASS RATE: $(( TESTS_TOTAL > 0 ? TESTS_PASSED * 100 / TESTS_TOTAL : 0 ))%

EOF

    if [ $TESTS_FAILED -gt 0 ]; then
        echo "RESULT: FAILED" >> "$report_file"
    else
        echo "RESULT: PASSED" >> "$report_file"
    fi
    
    echo "Test report generated: $report_file"
}

# Display test summary
display_summary() {
    echo ""
    echo -e "${BLUE}ğŸ“Š TEST SUMMARY${NC}"
    echo "================"
    echo "Total Tests: $TESTS_TOTAL"
    echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
    echo -e "Failed: ${RED}$TESTS_FAILED${NC}"
    echo -e "Skipped: ${YELLOW}$TESTS_SKIPPED${NC}"
    
    if [ $TESTS_TOTAL -gt 0 ]; then
        local pass_rate=$((TESTS_PASSED * 100 / TESTS_TOTAL))
        echo "Pass Rate: $pass_rate%"
    fi
    
    echo ""
    
    if [ $TESTS_FAILED -gt 0 ]; then
        echo -e "${RED}âŒ TESTS FAILED${NC}"
        return 1
    else
        echo -e "${GREEN}âœ… ALL TESTS PASSED${NC}"
        return 0
    fi
}

# Cleanup test environment
test_cleanup() {
    echo -e "${BLUE}ğŸ§¹ Cleaning up test environment${NC}"
    
    # Remove temporary files
    rm -rf "$TEMP_DIR"/*
    
    echo "Cleanup completed"
}

# Main test runner function
run_tests() {
    local target="${1:-all}"
    
    test_init
    
    case "$target" in
        "all")
            run_test_directory "$TEST_DIR/unit"
            run_test_directory "$TEST_DIR/integration"
            run_test_directory "$TEST_DIR/bdd"
            ;;
        "unit")
            run_test_directory "$TEST_DIR/unit"
            ;;
        "integration")
            run_test_directory "$TEST_DIR/integration"
            ;;
        "bdd")
            run_test_directory "$TEST_DIR/bdd"
            ;;
        *)
            if [ -f "$target" ]; then
                run_test_file "$target"
            elif [ -d "$target" ]; then
                run_test_directory "$target"
            else
                echo -e "${RED}âŒ Unknown test target: $target${NC}"
                return 1
            fi
            ;;
    esac
    
    generate_report
    display_summary
    local result=$?
    
    test_cleanup
    
    return $result
}

# Help function
show_help() {
    cat << EOF
Test Runner - TDD/BDD Framework for Claude Model Switcher

USAGE:
    $0 [TARGET]

TARGETS:
    all           Run all tests (unit + integration + bdd)
    unit          Run unit tests only
    integration   Run integration tests only
    bdd           Run BDD tests only
    <file>        Run a specific test file
    <directory>   Run all tests in a directory

EXAMPLES:
    $0                          # Run all tests
    $0 unit                     # Run unit tests
    $0 tests/unit/test_logger.sh # Run specific test file

TEST FILE NAMING:
    test_*.sh                   # Test files must start with 'test_'

ASSERTION FUNCTIONS:
    assert_success              # Command should succeed
    assert_failure              # Command should fail
    assert_equals               # String equality
    assert_file_exists          # File exists
    assert_dir_exists           # Directory exists
    assert_contains             # String contains substring
    skip_test                   # Skip a test

BDD FUNCTIONS:
    describe                    # Test suite description
    context                     # Test context
    it                          # Test case description

SETUP/TEARDOWN:
    setup                       # Run before each test
    teardown                    # Run after each test
    setup_all                   # Run once before all tests
    teardown_all                # Run once after all tests
EOF
}

# Main execution
main() {
    local command="${1:-all}"
    
    case "$command" in
        "help"|"--help"|"-h")
            show_help
            ;;
        *)
            run_tests "$command"
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

`claude-model-switcher/tests/unit/test_logger.sh`:

```sh
#!/bin/bash

# Unit Tests for Logger Module

# Setup test environment
setup_all() {
    # Create temporary log directory for testing
    TEST_LOG_DIR="$TEMP_DIR/logs"
    mkdir -p "$TEST_LOG_DIR"
    
    # Set test configuration before sourcing logger
    export LOG_DIR="$TEST_LOG_DIR"
    export LOG_FILE="$TEST_LOG_DIR/test.log"
    export LOG_LEVEL="DEBUG"
    export USE_EMOJIS="true"
    
    # Source the logger module after setting environment
    source "$PROJECT_DIR/lib/core/logger.sh"
    
    # Initialize logger
    logger_init
    
    # Verify initialization
    if [ ! -f "$LOG_FILE" ]; then
        touch "$LOG_FILE"
    fi
    
    # Export variables for test assertions
    export TEST_LOG_DIR
}

teardown_all() {
    # Clean up test logs
    rm -rf "$TEST_LOG_DIR"
}

# Test logger initialization
describe "Logger Module - Initialization"

context "When initializing logger"

it "should create log directory"
assert_dir_exists "Log directory should be created" "$TEST_LOG_DIR"

it "should create log file"
assert_file_exists "Log file should be created" "$LOG_FILE"

it "should set global variables"
assert_equals "LOGGER_FILE should be set" "$LOG_FILE" "$LOGGER_FILE"
assert_equals "LOGGER_LEVEL should be set" "DEBUG" "$LOGGER_LEVEL"

# Test logging functions
describe "Logger Module - Logging Functions"

context "When logging messages"

it "should log debug messages"
log_debug "Test debug message"
assert_success "Debug message should be logged" "grep 'Test debug message' '$LOG_FILE'"

it "should log info messages"
log_info "Test info message"
assert_success "Info message should be logged" "grep 'Test info message' '$LOG_FILE'"

it "should log warning messages"
log_warn "Test warning message"
assert_success "Warning message should be logged" "grep 'Test warning message' '$LOG_FILE'"

it "should log error messages"
log_error "Test error message"
assert_success "Error message should be logged" "grep 'Test error message' '$LOG_FILE'"

it "should log success messages"
log_success "Test success message"
assert_success "Success message should be logged" "grep 'Test success message' '$LOG_FILE'"

# Test log levels
describe "Logger Module - Log Levels"

context "When log level is INFO"

it "should not log debug messages when level is INFO"
export LOGGER_LEVEL="INFO"
log_debug "Debug message that should not appear"
assert_failure "Debug message should not be logged at INFO level" "grep 'Debug message that should not appear' '$LOG_FILE'"

it "should log info messages when level is INFO"
log_info "Info message that should appear"
assert_success "Info message should be logged at INFO level" "grep 'Info message that should appear' '$LOG_FILE'"

# Test log formatting
describe "Logger Module - Formatting"

context "When logging with timestamps"

it "should include timestamps in log file"
log_info "Timestamp test message"
assert_success "Log should contain timestamp" "grep '\\[.*\\] \\[INFO\\] Timestamp test message' '$LOG_FILE'"

# Test utility functions
describe "Logger Module - Utility Functions"

context "When using utility functions"

it "should create log separators"
log_separator "-" 10
assert_success "Log separator should be created" "grep -- '-----------*' '$LOG_FILE'"

it "should create log headers"
log_header "Test Header"
assert_success "Log header should be created" "grep 'Test Header' '$LOG_FILE'"
```

`claude-model-switcher/tests/unit/test_validator.sh`:

```sh
#!/bin/bash

# Unit Tests for Validator Module

setup_all() {
    # Initialize logger for testing first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise in tests
    export USE_EMOJIS="false"  # Reduce noise in test output
    mkdir -p "$LOG_DIR"
    
    # Source required modules in correct order
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Now source validator after logger is initialized
    source "$PROJECT_DIR/lib/core/validator.sh"
}

# Test model alias validation
describe "Validator Module - Model Alias Validation"

context "When validating model aliases"

it "should accept valid aliases"
assert_success "Valid alias 'kimi' should pass" "validate_model_alias 'kimi'"
assert_success "Valid alias 'glm4' should pass" "validate_model_alias 'glm4'"
assert_success "Valid alias 'my-model' should pass" "validate_model_alias 'my-model'"
assert_success "Valid alias 'model_123' should pass" "validate_model_alias 'model_123'"

it "should reject invalid aliases"
assert_failure "Empty alias should fail" "validate_model_alias ''"
assert_failure "Alias with spaces should fail" "validate_model_alias 'my model'"
assert_failure "Alias with special chars should fail" "validate_model_alias 'model@123'"
assert_failure "Too long alias should fail" "validate_model_alias 'this_is_a_very_long_model_alias_name'"

# Test provider name validation
describe "Validator Module - Provider Validation"

context "When validating provider names"

it "should accept valid providers"
export AVAILABLE_PROVIDERS="moonshot zhipu openai"
assert_success "Valid provider 'moonshot' should pass" "validate_provider_name 'moonshot'"
assert_success "Valid provider 'zhipu' should pass" "validate_provider_name 'zhipu'"

it "should reject invalid providers"
assert_failure "Empty provider should fail" "validate_provider_name ''"
assert_failure "Unknown provider should fail" "validate_provider_name 'unknown'"

# Test API key validation
describe "Validator Module - API Key Validation"

context "When validating API keys"

it "should accept valid API keys"
assert_success "Valid generic API key should pass" "validate_api_key 'sk-1234567890abcdef1234567890abcdef12345678'"
assert_success "Long API key should pass" "validate_api_key '1234567890abcdef1234567890abcdef12345678901234567890'"

it "should reject invalid API keys"
assert_failure "Empty API key should fail" "validate_api_key ''"
assert_failure "Too short API key should fail" "validate_api_key '123'"

# Test URL validation
describe "Validator Module - URL Validation"

context "When validating URLs"

it "should accept valid URLs"
assert_success "HTTPS URL should pass" "validate_url 'https://api.example.com'"
assert_success "HTTP URL should pass" "validate_url 'http://api.example.com'"
assert_success "URL with port should pass" "validate_url 'https://api.example.com:8080'"
assert_success "URL with path should pass" "validate_url 'https://api.example.com/v1/api'"

it "should reject invalid URLs"
assert_failure "Empty URL should fail" "validate_url ''"
assert_failure "Invalid protocol should fail" "validate_url 'ftp://example.com'"
assert_failure "No protocol should fail" "validate_url 'example.com'"
assert_failure "Invalid format should fail" "validate_url 'https://'"

# Test version validation
describe "Validator Module - Version Validation"

context "When validating version strings"

it "should accept valid versions"
assert_success "Semantic version should pass" "validate_version '1.0.0'"
assert_success "Version with pre-release should pass" "validate_version '1.0.0-alpha'"
assert_success "Version with build should pass" "validate_version '1.0.0-alpha.1'"

it "should reject invalid versions"
assert_failure "Empty version should fail" "validate_version ''"
assert_failure "Invalid format should fail" "validate_version '1.0'"
assert_failure "Non-numeric should fail" "validate_version 'v1.0.0'"

# Test file path validation
describe "Validator Module - File Path Validation"

context "When validating file paths"

it "should accept valid file paths"
assert_success "Absolute path should pass" "validate_file_path '/tmp/test.txt'"
assert_success "Relative path should pass" "validate_file_path 'config/app.conf'"

it "should reject invalid file paths"
assert_failure "Empty path should fail" "validate_file_path ''"

it "should check file existence when required"
# Create a test file
touch "$TEMP_DIR/existing_file.txt"
assert_success "Existing file should pass existence check" "validate_file_path '$TEMP_DIR/existing_file.txt' true"
assert_failure "Non-existing file should fail existence check" "validate_file_path '$TEMP_DIR/missing_file.txt' true"
```
```

`claude-model-switcher/config/app.conf`:

```conf
# Claude Model Switcher Application Configuration
# Version: 5.0.0 (Modular Architecture)
# This file contains all application-level configurations

# Application Metadata
APP_NAME="Claude Model Switcher"
APP_VERSION="5.0.0"
APP_DESCRIPTION="Robust installer and manager for Claude Code with multi-model support"

# Directory Structure
SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
CONFIG_DIR="$SWITCHER_DIR/config"
LIB_DIR="$SWITCHER_DIR/lib"
MEMORY_DIR="$SWITCHER_DIR/memory"
LOG_DIR="$SWITCHER_DIR/logs"
BACKUP_DIR="$SWITCHER_DIR/backups"

# Configuration Files
MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
PROVIDERS_CONFIG_FILE="$CONFIG_DIR/providers.conf"
USER_CONFIG_FILE="$CONFIG_DIR/user.conf"
MCP_CONFIG_FILE="$CONFIG_DIR/mcp.json"

# Shell Integration
SHELL_CONFIG_MARKER="# CLAUDE_CODE_MODEL_MANAGER_V5"
SHELL_CONFIG_END_MARKER="# END_OF_CLAUDE_CONFIG"

# Node.js Configuration
NODE_MIN_VERSION="18"
NVM_VERSION="v0.39.7"
NVM_INSTALL_URL="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh"

# Claude Code Configuration
CLAUDE_PACKAGE="@anthropic-ai/claude-code"
CLAUDE_DEFAULT_TEMPERATURE="0.6"
CLAUDE_DEFAULT_TIMEOUT="300000"

# Logging Configuration
LOG_LEVEL="INFO"  # DEBUG, INFO, WARN, ERROR
LOG_FILE="$LOG_DIR/installer.log"
LOG_MAX_SIZE="10M"
LOG_BACKUP_COUNT="5"

# Safety and Backup Configuration
ENABLE_BACKUPS="true"
BACKUP_RETENTION_DAYS="30"
ATOMIC_OPERATIONS="true"

# Feature Flags
ENABLE_DUAL_MODEL_SUPPORT="true"
ENABLE_TEMPERATURE_CONTROL="true"
ENABLE_TIMEOUT_CONTROL="true"
ENABLE_MEMORY_TRACKING="true"
ENABLE_SHELL_HOOKS="true"

# UI Configuration
USE_EMOJIS="true"
PROGRESS_BAR_WIDTH="50"
TABLE_WIDTH="110"


```

`claude-model-switcher/config/mcp.json`:

```json
{
  "mcpServers": {
    "jina-mcp-server": {
      "type": "sse",
      "url": "https://mcp.jina.ai/sse",
      "headers": {
        "Authorization": "Bearer ${JINA_API_KEY}",
        "X-Retain-Images": "none" ,
        "X-Return-Format": "markdown"
      }
    },
    "filesystem": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "${HOME}/Documents", "${HOME}/Desktop"]
    },
    "github": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "brave-search": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-brave-search"],
      "env": {
        "BRAVE_API_KEY": "${BRAVE_API_KEY}"
      }
    }
  }
}
```

`claude-model-switcher/config/models.conf`:

```conf
# Claude Model Switcher Model Configuration
# This file defines all available AI models and their properties
# Requires Bash 4.0+ for associative arrays

# Associative arrays to hold model properties
# (Arrays are declared in config_loader.sh before sourcing this file)

# --- Moonshot Models ---

# Model: Kimi K2 Turbo Preview
MODEL_PROVIDERS["kimi"]="moonshot"
MODEL_API_NAMES["kimi"]="kimi-k2-0711-preview"
MODEL_SMALL_FAST_NAMES["kimi"]="kimi-k2-0711-preview"
MODEL_CONTEXTS["kimi"]="128K tokens (Main & Fast)"
MODEL_DESCRIPTIONS["kimi"]="Moonshot Kimi K2 - Advanced reasoning and long context"
MODEL_CAPABILITIES["kimi"]="text,reasoning,code"

# --- Zhipu GLM Models ---

# Model: GLM-4.5 Series
MODEL_PROVIDERS["glm4"]="zhipu"
MODEL_API_NAMES["glm4"]="glm-4.5"
MODEL_SMALL_FAST_NAMES["glm4"]="glm-4.5-flash"
MODEL_CONTEXTS["glm4"]="32K tokens (Main) / 128K tokens (Fast)"
MODEL_DESCRIPTIONS["glm4"]="Zhipu GLM-4.5 - Balanced performance with fast variant"
MODEL_CAPABILITIES["glm4"]="text,reasoning,code,multimodal"

# --- DeepSeek Models ---

# Model: DeepSeek-V3.1 (Chat Mode)
MODEL_PROVIDERS["deepseek"]="deepseek"
MODEL_API_NAMES["deepseek"]="deepseek-chat"
MODEL_SMALL_FAST_NAMES["deepseek"]="deepseek-chat"
MODEL_CONTEXTS["deepseek"]="128K tokens (Main & Fast)"
MODEL_DESCRIPTIONS["deepseek"]="DeepSeek-V3.1 - Advanced reasoning with 128K context and function calling"
MODEL_CAPABILITIES["deepseek"]="text,reasoning,code,function-calling"

# --- Example Future Models (Commented) ---

# OpenAI GPT-4
# MODEL_PROVIDERS["gpt4"]="openai"
# MODEL_API_NAMES["gpt4"]="gpt-4"
# MODEL_SMALL_FAST_NAMES["gpt4"]="gpt-3.5-turbo"
# MODEL_CONTEXTS["gpt4"]="8K tokens (Main) / 4K tokens (Fast)"
# MODEL_DESCRIPTIONS["gpt4"]="OpenAI GPT-4 - Most capable model"
# MODEL_CAPABILITIES["gpt4"]="text,reasoning,code"

# Anthropic Claude
# MODEL_PROVIDERS["claude"]="anthropic"
# MODEL_API_NAMES["claude"]="claude-3-opus"
# MODEL_SMALL_FAST_NAMES["claude"]="claude-3-sonnet"
# MODEL_CONTEXTS["claude"]="200K tokens (Main) / 200K tokens (Fast)"
# MODEL_DESCRIPTIONS["claude"]="Anthropic Claude 3 - Excellent reasoning"
# MODEL_CAPABILITIES["claude"]="text,reasoning,code,analysis"

# Model Registry
# List of all available model aliases (used for validation and iteration)
AVAILABLE_MODELS="kimi glm4 deepseek"

# Default Model Settings
DEFAULT_MODEL="kimi"
FALLBACK_MODEL="glm4"

# Model Categories
TEXT_MODELS="kimi glm4 deepseek"
CODE_MODELS="kimi glm4 deepseek"
MULTIMODAL_MODELS="glm4"
REASONING_MODELS="kimi glm4 deepseek"
FUNCTION_CALLING_MODELS="deepseek"


```

`claude-model-switcher/config/providers.conf`:

```conf
# Claude Model Switcher Provider Configuration
# This file defines all supported AI model providers

# Provider Configuration Format:
# PROVIDER_<NAME>_BASE_URL="base_url"
# PROVIDER_<NAME>_AUTH_TYPE="bearer|api_key"
# PROVIDER_<NAME>_DESCRIPTION="description"

# Moonshot Provider Configuration
PROVIDER_MOONSHOT_BASE_URL="https://api.moonshot.cn/anthropic/"
PROVIDER_MOONSHOT_AUTH_TYPE="bearer"
PROVIDER_MOONSHOT_DESCRIPTION="Moonshot AI - Kimi series models"
PROVIDER_MOONSHOT_SUPPORTED_MODELS="kimi-k2-turbo-preview"

# Zhipu GLM Provider Configuration
PROVIDER_ZHIPU_BASE_URL="https://open.bigmodel.cn/api/anthropic"
PROVIDER_ZHIPU_AUTH_TYPE="bearer"
PROVIDER_ZHIPU_DESCRIPTION="Zhipu AI - GLM series models"
PROVIDER_ZHIPU_SUPPORTED_MODELS="glm-4.5,glm-4.5-flash"

# OpenAI Provider Configuration (Example for future extension)
PROVIDER_OPENAI_BASE_URL="https://api.openai.com/v1"
PROVIDER_OPENAI_AUTH_TYPE="bearer"
PROVIDER_OPENAI_DESCRIPTION="OpenAI - GPT series models"
PROVIDER_OPENAI_SUPPORTED_MODELS="gpt-4,gpt-3.5-turbo"

# DeepSeek Provider Configuration
PROVIDER_DEEPSEEK_BASE_URL="https://api.deepseek.com/anthropic"
PROVIDER_DEEPSEEK_AUTH_TYPE="bearer"
PROVIDER_DEEPSEEK_DESCRIPTION="DeepSeek - DeepSeek-V3.1 series models with Anthropic API compatibility"
PROVIDER_DEEPSEEK_SUPPORTED_MODELS="deepseek-chat"

# Anthropic Provider Configuration (Example for future extension)
PROVIDER_ANTHROPIC_BASE_URL="https://api.anthropic.com"
PROVIDER_ANTHROPIC_AUTH_TYPE="api_key"
PROVIDER_ANTHROPIC_DESCRIPTION="Anthropic - Claude series models"
PROVIDER_ANTHROPIC_SUPPORTED_MODELS="claude-3-opus,claude-3-sonnet"

# Provider Registry
# List of all available providers (used for validation and iteration)
AVAILABLE_PROVIDERS="moonshot zhipu deepseek"

# Default Provider Settings
DEFAULT_PROVIDER="moonshot"
FALLBACK_PROVIDER="zhipu"


```

`claude-model-switcher/docs/claude-code-cli-reference.md`:

```md
# Claude Code CLI Reference Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/cli-reference*
*Download date: 2025-08-21*

---

## CLI commands

| Command | Description | Example |
|---------|-------------|---------|
| `claude` | Start interactive REPL | `claude` |
| `claude "query"` | Start REPL with initial prompt | `claude "explain this project"` |
| `claude -p "query"` | Query via SDK, then exit | `claude -p "explain this function"` |
| `cat file | claude -p "query"` | Process piped content | `cat logs.txt | claude -p "explain"` |
| `claude -c` | Continue most recent conversation | `claude -c` |
| `claude -c -p "query"` | Continue via SDK | `claude -c -p "Check for type errors"` |
| `claude -r "<session-id>" "query"` | Resume session by ID | `claude -r "abc123" "Finish this PR"` |
| `claude update` | Update to latest version | `claude update` |
| `claude mcp` | Configure Model Context Protocol (MCP) servers | See the [Claude Code MCP documentation](https://docs.anthropic.com/en/docs/claude-code/mcp). |

## CLI flags

Customize Claude Code's behavior with these command-line flags:

| Flag | Description | Example |
|------|-------------|---------|
| `--add-dir` | Add additional working directories for Claude to access (validates each path exists as a directory) | `claude --add-dir ../apps ../lib` |
| `--allowedTools` | A list of tools that should be allowed without prompting the user for permission, in addition to [settings.json](https://docs.anthropic.com/en/docs/claude-code/settings) files | `"Bash(git log:*)" "Bash(git diff:*)" "Read"` |
| `--disallowedTools` | A list of tools that should be disallowed without prompting the user for permission, in addition to [settings.json](https://docs.anthropic.com/en/docs/claude-code/settings) files | `"Bash(git log:*)" "Bash(git diff:*)" "Edit"` |
| `--print`, `-p` | Print response without interactive mode (see [SDK documentation](https://docs.anthropic.com/en/docs/claude-code/sdk) for programmatic usage details) | `claude -p "query"` |
| `--append-system-prompt` | Append to system prompt (only with `--print`) | `claude --append-system-prompt "Custom instruction"` |
| `--output-format` | Specify output format for print mode (options: `text`, `json`, `stream-json`) | `claude -p "query" --output-format json` |
| `--input-format` | Specify input format for print mode (options: `text`, `stream-json`) | `claude -p --output-format json --input-format stream-json` |
| `--verbose` | Enable verbose logging, shows full turn-by-turn output (helpful for debugging in both print and interactive modes) | `claude --verbose` |
| `--max-turns` | Limit the number of agentic turns in non-interactive mode | `claude -p --max-turns 3 "query"` |
| `--model` | Sets the model for the current session with an alias for the latest model (`sonnet` or `opus`) or a model's full name | `claude --model claude-sonnet-4-20250514` |
| `--permission-mode` | Begin in a specified [permission mode](https://docs.anthropic.com/en/docs/claude-code/iam#permission-modes) | `claude --permission-mode plan` |
| `--permission-prompt-tool` | Specify an MCP tool to handle permission prompts in non-interactive mode | `claude -p --permission-prompt-tool mcp_auth_tool "query"` |
| `--resume` | Resume a specific session by ID, or by choosing in interactive mode | `claude --resume abc123 "query"` |
| `--continue` | Load the most recent conversation in the current directory | `claude --continue` |
| `--dangerously-skip-permissions` | Skip permission prompts (use with caution) | `claude --dangerously-skip-permissions` |

For detailed information about print mode (`-p`) including output formats, streaming, verbose logging, and programmatic usage, see the [SDK documentation](https://docs.anthropic.com/en/docs/claude-code/sdk).

## Advanced CLI Usage

### Multiple Directories

```bash
# Add multiple directories for Claude to access
claude --add-dir ../shared-components ../utils ./src

# Use with project-specific contexts
claude --add-dir ../../common-libraries
```

### Tool Permission Management

```bash
# Allow specific git operations without prompting
claude --allowedTools "Bash(git log:*)" "Bash(git diff:*)" "Bash(git status)" "Read"

# Disallow potentially dangerous operations
claude --disallowedTools "Bash(rm:*)" "Bash(mv:*)" "WebFetch"

# Combine allowed and disallowed tools
claude --allowedTools "Read,Write,Edit" --disallowedTools "Bash(curl:*)"
```

### Output Format Examples

```bash
# JSON output for programmatic processing
claude -p "Analyze this code" --output-format json

# Streaming JSON for real-time processing
claude -p "Process this large file" --output-format stream-json

# Text output (default)
claude -p "Explain this concept" --output-format text
```

### Session Management

```bash
# Continue the most recent conversation
claude --continue

# Continue with additional query
claude --continue -p "Now add error handling"

# Resume specific session
claude --resume "abc123-def456" "Complete the implementation"

# List available sessions (interactive mode)
claude --resume
```

### Model Selection

```bash
# Use model aliases
claude --model sonnet
claude --model opus

# Use specific model versions
claude --model claude-sonnet-4-20250514
claude --model claude-opus-4-1

# Combine with other flags
claude --model sonnet --max-turns 5 -p "Implement this feature"
```

### Permission Modes

```bash
# Plan mode - read only analysis
claude --permission-mode plan

# Accept edits mode - auto-approve file changes
claude --permission-mode acceptEdits

# Bypass permissions - use with extreme caution
claude --dangerously-skip-permissions
```

### System Prompt Customization

```bash
# Add custom instructions to system prompt
claude -p "Review this code" --append-system-prompt "Focus on security vulnerabilities and performance issues"

# Multiple custom instructions
claude -p "Refactor this function" --append-system-prompt "Use functional programming patterns. Include comprehensive error handling."
```

## Input/Output Format Examples

### Standard Text Input/Output

```bash
# Basic query
claude -p "What does this function do?"

# Piped input
cat function.py | claude -p "Explain this code"

# File input
claude -p "$(cat config.json)" "Parse this configuration"
```

### JSON Input/Output

```bash
# JSON output for parsing
RESULT=$(claude -p "Generate a summary" --output-format json)
echo "$RESULT" | jq -r '.result'

# Streaming JSON input
echo '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Analyze this data"}]}}' | \
  claude -p --output-format stream-json --input-format stream-json
```

## Debugging and Development

### Verbose Mode

```bash
# Enable verbose logging for debugging
claude --verbose

# Verbose with specific query
claude -p "Debug this issue" --verbose

# Verbose session continuation
claude --continue --verbose
```

### Development Flags

```bash
# Limit turns for testing
claude -p --max-turns 2 "Simple task"

# Skip permissions for development (use cautiously)
claude --dangerously-skip-permissions -p "Make these changes"

# Test with specific model
claude --model claude-haiku-4-1 -p "Quick test"
```

## Configuration Files

### CLI Configuration in Settings

You can also set CLI preferences in your `settings.json` file:

```json
{
  "model": "claude-sonnet-4-20250514",
  "maxTurns": 5,
  "verbose": false,
  "permissionMode": "acceptEdits",
  "allowedTools": ["Read", "Write", "Edit", "Bash(git diff:*)"]
}
```

### Environment Variables

Set environment variables for global CLI behavior:

```bash
# Set default model
export ANTHROPIC_MODEL=claude-sonnet-4-20250514

# Enable verbose logging
export CLAUDE_VERBOSE=1

# Set default max turns
export CLAUDE_MAX_TURNS=3
```

## Batch Processing

### Multiple Queries

```bash
# Process multiple files
for file in src/*.py; do
    echo "Processing $file"
    claude -p "Add type hints to $(basename $file)" < "$file"
done

# Batch with different models
echo "Review with Sonnet" | claude --model sonnet -p "Code review"
echo "Review with Haiku" | claude --model haiku -p "Quick check"
```

### Automated Workflows

```bash
# Pre-commit hook example
#!/bin/bash
FILES=$(git diff --cached --name-only --diff-filter=AM | grep -E '\.(py|js|ts)$')
if [ -n "$FILES" ]; then
    echo "$FILES" | claude -p "Review these staged files for issues"
fi
```

## Error Handling

### Common Error Scenarios

```bash
# Handle authentication errors
claude -p "test" 2>&1 | grep -q "authentication" && echo "Please login first"

# Handle timeout issues
timeout 30 claude -p "Complex task" || echo "Operation timed out"

# Retry failed operations
for i in {1..3}; do
    claude -p "Retry operation" && break || sleep 1
done
```

### Exit Codes

```bash
# Check exit codes for scripting
if claude -p "Test this"; then
    echo "Success"
else
    echo "Failed with exit code $?"
fi

# Use in CI/CD pipelines
claude -p "Validate configuration" || exit 1
```

## Performance Optimization

### Resource Management

```bash
# Limit output tokens for faster responses
export CLAUDE_CODE_MAX_OUTPUT_TOKENS=1000

# Use smaller model for simple tasks
claude --model haiku -p "Quick analysis"

# Cache expensive operations
claude -p "Analyze once" --output-format json > analysis.json
```

### Parallel Processing

```bash
# Run multiple Claude instances in parallel
(
    claude -p "Analyze module A" < module_a.py &
    claude -p "Analyze module B" < module_b.py &
    wait
)
```

## Integration Examples

### Git Integration

```bash
# Git alias for Claude review
git config --global alias.review '!f() { git diff --cached | claude -p "Review staged changes"; }; f'

# Use in git workflow
git add .
git review
git commit -m "Changes reviewed by Claude"
```

### IDE Integration

```bash
# VS Code task
{
    "label": "Claude Code Review",
    "type": "shell",
    "command": "claude",
    "args": ["-p", "Review the current file: ${file}"],
    "presentation": {
        "echo": true,
        "reveal": "always",
        "focus": false,
        "panel": "new"
    }
}
```

### CI/CD Pipeline

```yaml
# GitHub Actions example
- name: Claude Code Review
  run: |
    git diff origin/main...HEAD | claude -p "Review these changes for issues" --output-format json > review.json
    echo "Review complete"
```

## Best Practices

### Security

- Never use `--dangerously-skip-permissions` in production
- Use specific tool allowlists rather than broad permissions
- Review Claude's suggestions before applying them
- Keep API keys and sensitive data out of CLI history

### Performance

- Use appropriate models for task complexity (Haiku for simple, Sonnet/Opus for complex)
- Limit output tokens when not needed
- Cache results of expensive operations
- Use parallel processing for independent tasks

### Reliability

- Handle errors and timeouts gracefully
- Use exit codes for automation scripts
- Test CLI commands in development before production
- Monitor resource usage and costs

### Maintainability

- Use configuration files for consistent settings
- Document custom CLI usage in project README
- Use meaningful aliases and shortcuts
- Keep CLI scripts version controlled

## Troubleshooting

### Common Issues

1. **Authentication errors**
   ```bash
   claude login  # Re-authenticate
   ```

2. **Permission denied**
   ```bash
   claude --allowedTools "Read,Write"  # Add necessary tools
   ```

3. **Timeout issues**
   ```bash
   timeout 60 claude -p "task"  # Increase timeout
   ```

4. **Model not found**
   ```bash
   claude --model sonnet  # Use model alias
   ```

### Debug Commands

```bash
# Check Claude Code version
claude --version

# Verify installation
which claude

# Check configuration
claude config list

# Test basic functionality
claude -p "Hello, world!"
```

## See Also

- [Interactive mode](https://docs.anthropic.com/en/docs/claude-code/interactive-mode) - Shortcuts, input modes, and interactive features
- [Slash commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands) - Interactive session commands
- [Quickstart guide](https://docs.anthropic.com/en/docs/claude-code/quickstart) - Getting started with Claude Code
- [Common workflows](https://docs.anthropic.com/en/docs/claude-code/common-workflows) - Advanced workflows and patterns
- [Settings](https://docs.anthropic.com/en/docs/claude-code/settings) - Configuration options
- [SDK documentation](https://docs.anthropic.com/en/docs/claude-code/sdk) - Programmatic usage and integrations
- [Status line configuration](https://docs.anthropic.com/en/docs/claude-code/statusline) - Custom status line setup

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-github-actions.md`:

```md
# Claude Code GitHub Actions Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/github-actions*
*Download date: 2025-08-21*

---

## Overview

Claude Code GitHub Actions brings AI-powered automation to your GitHub workflow. With a simple `@claude` mention in any PR or issue, Claude can analyze your code, create pull requests, implement features, and fix bugs - all while following your project's standards.

- **Instant PR creation**: Describe what you need, and Claude creates a complete PR with all necessary changes
- **Automated code implementation**: Turn issues into working code with a single command
- **Follows your standards**: Claude respects your `CLAUDE.md` guidelines and existing code patterns
- **Simple setup**: Get started in minutes with our installer and API key
- **Secure by default**: Your code stays on Github's runners

## What can Claude do?

Claude Code provides powerful GitHub Actions that transform how you work with code:

### Claude Code Action

This GitHub Action allows you to run Claude Code within your GitHub Actions workflows. You can use this to build any custom workflow on top of Claude Code.

[View repository â†’](https://github.com/anthropics/claude-code-action)

### Claude Code Action (Base)

The foundation for building custom GitHub workflows with Claude. This extensible framework gives you full access to Claude's capabilities for creating tailored automation.

[View repository â†’](https://github.com/anthropics/claude-code-base-action)

## Setup

### Quick setup

The easiest way to set up this action is through Claude Code in the terminal. Just open claude and run `/install-github-app`.

This command will guide you through setting up the GitHub app and required secrets.

### Manual setup

If the `/install-github-app` command fails or you prefer manual setup, please follow these manual setup instructions:

1. **Install the Claude GitHub app** to your repository: https://github.com/apps/claude
2. **Add ANTHROPIC_API_KEY** to your repository secrets ([Learn how to use secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions))
3. **Copy the workflow file** from [examples/claude.yml](https://github.com/anthropics/claude-code-action/blob/main/examples/claude.yml) into your repository's `.github/workflows/`

## Example use cases

Claude Code GitHub Actions can help you with a variety of tasks. For complete working examples, see the [examples directory](https://github.com/anthropics/claude-code-action/tree/main/examples).

### Turn issues into PRs

In an issue comment:
```
@claude Implement user authentication with JWT tokens
```

Claude will analyze the issue, write the code, and create a PR for review.

### Get implementation help

In a PR comment:
```
@claude How should I implement this feature?
```

Claude will analyze your code and provide specific implementation guidance.

### Fix bugs quickly

In an issue:
```
@claude Fix the memory leak in the image processing function
```

Claude will locate the bug, implement a fix, and create a PR.

## Best practices

### CLAUDE.md configuration

Create a `CLAUDE.md` file in your repository root to define code style guidelines, review criteria, project-specific rules, and preferred patterns. This file guides Claude's understanding of your project standards.

### Security considerations

Always use GitHub Secrets for API keys:

- Add your API key as a repository secret named `ANTHROPIC_API_KEY`
- Reference it in workflows: `anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}`
- Limit action permissions to only what's necessary
- Review Claude's suggestions before merging

Always use GitHub Secrets (e.g., `${{ secrets.ANTHROPIC_API_KEY }}`) rather than hardcoding API keys directly in your workflow files.

### Optimizing performance

Use issue templates to provide context, keep your `CLAUDE.md` concise and focused, and configure appropriate timeouts for your workflows.

### CI costs

When using Claude Code GitHub Actions, be aware of the associated costs:

**GitHub Actions costs:**
- Claude Code runs on GitHub-hosted runners, which consume your GitHub Actions minutes
- See [GitHub's billing documentation](https://docs.github.com/en/billing/managing-billing-for-your-products/managing-billing-for-github-actions/about-billing-for-github-actions) for detailed pricing and minute limits

**API costs:**
- Each Claude interaction consumes API tokens based on the length of prompts and responses
- Token usage varies by task complexity and codebase size
- See [Claude's pricing page](https://www.anthropic.com/api) for current token rates

**Cost optimization tips:**
- Use specific `@claude` commands to reduce unnecessary API calls
- Configure appropriate `max_turns` limits to prevent excessive iterations
- Set reasonable `timeout_minutes` to avoid runaway workflows
- Consider using GitHub's concurrency controls to limit parallel runs

## Configuration examples

For ready-to-use workflow configurations for different use cases, including:

- Basic workflow setup for issue and PR comments
- Automated code reviews on pull requests
- Custom implementations for specific needs

Visit the [examples directory](https://github.com/anthropics/claude-code-action/tree/main/examples) in the Claude Code Action repository.

## Using with AWS Bedrock & Google Vertex AI

For enterprise environments, you can use Claude Code GitHub Actions with your own cloud infrastructure. This approach gives you control over data residency and billing while maintaining the same functionality.

### Prerequisites

Before setting up Claude Code GitHub Actions with cloud providers, you need:

#### For Google Cloud Vertex AI:
1. A Google Cloud Project with Vertex AI enabled
2. Workload Identity Federation configured for GitHub Actions
3. A service account with the required permissions
4. A GitHub App (recommended) or use the default GITHUB_TOKEN

#### For AWS Bedrock:
1. An AWS account with Amazon Bedrock enabled
2. GitHub OIDC Identity Provider configured in AWS
3. An IAM role with Bedrock permissions
4. A GitHub App (recommended) or use the default GITHUB_TOKEN

### 1. Create GitHub App

Create a GitHub App at https://github.com/settings/apps/new with these permissions:

**Repository permissions:**
- Contents: Read & write
- Issues: Read & write
- Pull requests: Read & write

**Subscribe to events:**
- Issue comments
- Pull request comments
- Issues
- Pull requests

### 2. Configure Cloud Authentication

#### For Google Cloud Vertex AI:

Follow the [Google Cloud Workload Identity Federation documentation](https://cloud.google.com/iam/docs/workload-identity-federation) to set up identity federation between GitHub and Google Cloud.

#### For AWS Bedrock:

Follow the [AWS documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html) to configure OIDC identity provider and create an IAM role with Bedrock access.

### 3. Set up GitHub Secrets

Configure these secrets in your repository settings:

**For AWS Bedrock:**
| Secret Name | Description |
|-------------|-------------|
| `AWS_ROLE_TO_ASSUME` | ARN of the IAM role for Bedrock access |
| `APP_ID` | Your GitHub App ID (from app settings) |
| `APP_PRIVATE_KEY` | The private key you generated for your GitHub App |

**For Google Cloud Vertex AI:**
| Secret Name | Description |
|-------------|-------------|
| `GCP_WORKLOAD_IDENTITY_PROVIDER` | Workload identity provider resource name |
| `GCP_SERVICE_ACCOUNT` | Service account email with Vertex AI access |
| `APP_ID` | Your GitHub App ID (from app settings) |
| `APP_PRIVATE_KEY` | The private key you generated for your GitHub App |

### 4. Create workflow files

Create GitHub Actions workflow files that integrate with your cloud provider. The examples below show complete configurations for both AWS Bedrock and Google Vertex AI:

**AWS Bedrock Example:**
```yaml
name: Claude Code with AWS Bedrock

on:
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

jobs:
  claude:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        aws-region: us-east-1

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate GitHub App token
      uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ secrets.APP_ID }}
        private-key: ${{ secrets.APP_PRIVATE_KEY }}

    - name: Run Claude Code
      uses: anthropics/claude-code-action@v1
      with:
        github_token: ${{ steps.app-token.outputs.token }}
        provider: bedrock
        max_turns: 5
        timeout_minutes: 30
```

**Google Cloud Vertex AI Example:**
```yaml
name: Claude Code with Google Vertex AI

on:
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review_comment:
    types: [created, edited]

jobs:
  claude:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write

    steps:
    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate GitHub App token
      uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ secrets.APP_ID }}
        private-key: ${{ secrets.APP_PRIVATE_KEY }}

    - name: Run Claude Code
      uses: anthropics/claude-code-action@v1
      with:
        github_token: ${{ steps.app-token.outputs.token }}
        provider: vertex
        max_turns: 5
        timeout_minutes: 30
```

## Troubleshooting

### Claude not responding to @claude commands

Verify the GitHub App is installed correctly, check that workflows are enabled, ensure API key is set in repository secrets, and confirm the comment contains `@claude` (not `/claude`).

### CI not running on Claude's commits

Ensure you're using the GitHub App or custom app (not Actions user), check workflow triggers include the necessary events, and verify app permissions include CI triggers.

### Authentication errors

Confirm API key is valid and has sufficient permissions. For Bedrock/Vertex, check credentials configuration and ensure secrets are named correctly in workflows.

## Advanced configuration

### Action parameters

The Claude Code Action supports these key parameters:

| Parameter | Description | Required |
|-----------|-------------|----------|
| `prompt` | The prompt to send to Claude | Yes* |
| `prompt_file` | Path to file containing prompt | Yes* |
| `anthropic_api_key` | Anthropic API key | Yes** |
| `max_turns` | Maximum conversation turns | No |
| `timeout_minutes` | Execution timeout | No |

*Either `prompt` or `prompt_file` required  
**Required for direct Anthropic API, not for Bedrock/Vertex

### Alternative integration methods

While the `/install-github-app` command is the recommended approach, you can also:

- **Custom GitHub App**: For organizations needing branded usernames or custom authentication flows. Create your own GitHub App with required permissions (contents, issues, pull requests) and use the [actions/create-github-app-token](https://github.com/actions/create-github-app-token) action to generate tokens in your workflows.

- **Manual GitHub Actions**: Direct workflow configuration for maximum flexibility

- **MCP Configuration**: Dynamic loading of Model Context Protocol servers

See the [Claude Code Action repository](https://github.com/anthropics/claude-code-action) for detailed documentation.

### Customizing Claude's behavior

You can configure Claude's behavior in two ways:

1. **CLAUDE.md**: Define coding standards, review criteria, and project-specific rules in a `CLAUDE.md` file at the root of your repository. Claude will follow these guidelines when creating PRs and responding to requests. Check out our [Memory documentation](https://docs.anthropic.com/en/docs/claude-code/memory) for more details.

2. **Custom prompts**: Use the `prompt` parameter in the workflow file to provide workflow-specific instructions. This allows you to customize Claude's behavior for different workflows or tasks.

Claude will follow these guidelines when creating PRs and responding to requests.

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-hooks-guide.md`:

```md
# Claude Code Hooks Guide Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/hooks-guide*
*Download date: 2025-08-21*

---

## Overview

Claude Code hooks are user-defined shell commands that execute at various points in Claude Code's lifecycle. Hooks provide deterministic control over Claude Code's behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them.

Example use cases for hooks include:

- **Notifications**: Customize how you get notified when Claude Code is awaiting your input or permission to run something.
- **Automatic formatting**: Run `prettier` on .ts files, `gofmt` on .go files, etc. after every file edit.
- **Logging**: Track and count all executed commands for compliance or debugging.
- **Feedback**: Provide automated feedback when Claude Code produces code that does not follow your codebase conventions.
- **Custom permissions**: Block modifications to production files or sensitive directories.

By encoding these rules as hooks rather than prompting instructions, you turn suggestions into app-level code that executes every time it is expected to run.

## Hook Events Overview

Claude Code provides several hook events that run at different points in the workflow:

- **PreToolUse**: Runs before tool calls (can block them)
- **PostToolUse**: Runs after tool calls complete
- **UserPromptSubmit**: Runs when the user submits a prompt, before Claude processes it
- **Notification**: Runs when Claude Code sends notifications
- **Stop**: Runs when Claude Code finishes responding
- **Subagent Stop**: Runs when subagent tasks complete
- **PreCompact**: Runs before Claude Code is about to run a compact operation
- **SessionStart**: Runs when Claude Code starts a new session or resumes an existing session

Each event receives different data and can control Claude's behavior in different ways.

## Quickstart

In this quickstart, you'll add a hook that logs the shell commands that Claude Code runs.

### Prerequisites

Install `jq` for JSON processing in the command line.

### Step 1: Open hooks configuration

Run the `/hooks` [slash command](https://docs.anthropic.com/en/docs/claude-code/slash-commands) and select the `PreToolUse` hook event.

`PreToolUse` hooks run before tool calls and can block them while providing Claude feedback on what to do differently.

### Step 2: Add a matcher

Select `+ Add new matcherâ€¦` to run your hook only on Bash tool calls.

Type `Bash` for the matcher.

### Step 3: Add the hook

Select `+ Add new hookâ€¦` and enter this command:

```bash
echo "$(date): $CLAUDE_HOOK_TOOL_INPUT" >> ~/.claude/command_log.txt
```

### Step 4: Save your configuration

For storage location, select `User settings` since you're logging to your home directory. This hook will then apply to all projects, not just your current project.

Then press Esc until you return to the REPL. Your hook is now registered!

### Step 5: Verify your hook

Run `/hooks` again or check `~/.claude/settings.json` to see your configuration:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matchers": ["Bash"],
        "command": "echo \"$(date): $CLAUDE_HOOK_TOOL_INPUT\" >> ~/.claude/command_log.txt"
      }
    ]
  }
}
```

### Step 6: Test your hook

Ask Claude to run a simple command like `ls` and check your log file:

```bash
# Ask Claude: "Run ls"
cat ~/.claude/command_log.txt
```

You should see entries like:

```
2025-08-21T14:30:15Z: {"command":"ls","cwd":"/path/to/project"}
```

## More Examples

### Code Formatting Hook

Automatically format TypeScript files after editing:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matchers": ["Write", "MultiEdit"],
        "command": "if [[ \"$CLAUDE_HOOK_TOOL_OUTPUT\" == *\".ts\" ]]; then cd \"$CLAUDE_HOOK_CWD\" && npx prettier --write \"$CLAUDE_HOOK_TOOL_OUTPUT\"; fi"
      }
    ]
  }
}
```

### Markdown Formatting Hook

Automatically fix missing language tags and formatting issues in markdown files:

Create `.claude/hooks/markdown_formatter.py` with this content:

```python
#!/usr/bin/env python3
import json
import sys
import re
from pathlib import Path

def format_markdown(file_path):
    """Format markdown files with proper language tags and spacing"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Add language tags to unlabeled code blocks
        def add_language_tags(match):
            code_content = match.group(2)
            # Simple language detection
            if any(keyword in code_content.lower() for keyword in ['def ', 'import ', 'class ', 'if __name__']):
                language = 'python'
            elif any(keyword in code_content for keyword in ['function', 'const ', 'let ', '=>']):
                language = 'javascript'
            elif any(keyword in code_content for keyword in ['<div', '<script', 'function']):
                language = 'html'
            else:
                language = 'text'
            return f"```{language}\n{code_content}\n```"
        
        # Replace unlabeled code blocks
        content = re.sub(r'```(\w*)\n(.*?)\n```', add_language_tags, content, flags=re.DOTALL)
        
        # Fix excessive blank lines (more than 2 consecutive)
        content = re.sub(r'\n{3,}', '\n\n', content)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
            
    except Exception as e:
        print(f"Error formatting {file_path}: {e}", file=sys.stderr)

if __name__ == "__main__":
    # Read hook data from stdin
    hook_data = json.loads(sys.stdin.read())
    
    # Get file path from tool output
    tool_output = hook_data.get('tool_output', '{}')
    output_data = json.loads(tool_output) if tool_output else {}
    
    file_path = output_data.get('path', '')
    
    # Only process markdown files
    if file_path.endswith(('.md', '.mdx')):
        format_markdown(file_path)
```

Make the script executable:

```bash
chmod +x .claude/hooks/markdown_formatter.py
```

Then add to your hooks configuration:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matchers": ["Write", "MultiEdit"],
        "command": "python3 .claude/hooks/markdown_formatter.py"
      }
    ]
  }
}
```

This hook automatically:

- Detects programming languages in unlabeled code blocks
- Adds appropriate language tags for syntax highlighting
- Fixes excessive blank lines while preserving code content
- Only processes markdown files (`.md`, `.mdx`)

### Custom Notification Hook

Get desktop notifications when Claude needs input:

```json
{
  "hooks": {
    "Notification": [
      {
        "matchers": ["*"],
        "command": "if command -v notify-send >/dev/null 2>&1; then notify-send 'Claude Code' \"$CLAUDE_HOOK_NOTIFICATION_MESSAGE\"; fi"
      }
    ]
  }
}
```

### File Protection Hook

Block edits to sensitive files:

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matchers": ["Write", "MultiEdit", "Edit"],
        "command": "echo '$CLAUDE_HOOK_TOOL_INPUT' | jq -r '.path // empty' | grep -E '^(prod/|production/|\\.env\\.)' && echo 'BLOCKED: Cannot modify production files' >&2 && exit 1 || exit 0"
      }
    ]
  }
}
```

## Hook Environment Variables

Hooks have access to several environment variables that provide context about the current operation:

### General Variables
- `CLAUDE_HOOK_CWD`: Current working directory
- `CLAUDE_HOOK_SESSION_ID`: Current session identifier
- `CLAUDE_HOOK_EVENT`: The hook event that triggered execution

### Tool-Specific Variables
- `CLAUDE_HOOK_TOOL_NAME`: Name of the tool being called
- `CLAUDE_HOOK_TOOL_INPUT`: Input parameters for the tool (JSON string)
- `CLAUDE_HOOK_TOOL_OUTPUT`: Output from the tool (JSON string, for PostToolUse)

### User Interaction Variables
- `CLAUDE_HOOK_USER_PROMPT`: The user's submitted prompt
- `CLAUDE_HOOK_NOTIFICATION_MESSAGE`: Notification message content

### Session Variables
- `CLAUDE_HOOK_COMPACT_THRESHOLD`: Token threshold for compact operations
- `CLAUDE_HOOK_SUBAGENT_NAME`: Name of the subagent (if applicable)

## Hook Return Codes

Hooks can control Claude Code's behavior through their exit codes:

- **Exit code 0**: Success - allow the operation to continue
- **Exit code 1**: Block the operation (for PreToolUse hooks)
- **Exit code 2**: Provide feedback to Claude and retry
- **Other codes**: Treated as errors

## Hook Security Considerations

- **Input validation**: Always validate and sanitize hook inputs
- **Path safety**: Be careful with file paths to prevent directory traversal attacks
- **Command injection**: Avoid executing user-provided strings directly
- **Permissions**: Run hooks with appropriate user permissions
- **Logging**: Consider logging hook executions for audit purposes

## Best Practices

1. **Keep hooks simple**: Complex hooks are harder to debug and maintain
2. **Use absolute paths**: Avoid relying on current working directory
3. **Handle errors gracefully**: Use try/catch or error checking
4. **Test thoroughly**: Test hooks with various scenarios and edge cases
5. **Document your hooks**: Add comments explaining what each hook does
6. **Version control**: Store hook configurations and scripts in version control
7. **Performance**: Consider the performance impact of hooks, especially for frequent operations

## Troubleshooting

### Common Issues

1. **Hook not executing**: Check matchers and event types
2. **Permission errors**: Ensure hook scripts are executable
3. **Path issues**: Use absolute paths in hook configurations
4. **Environment variables**: Verify variable names and availability
5. **JSON parsing**: Ensure proper JSON formatting in tool inputs/outputs

### Debugging Techniques

1. **Add logging**: Insert echo statements to trace hook execution
2. **Test manually**: Run hook commands outside of Claude Code
3. **Check configuration**: Verify JSON syntax in settings files
4. **Monitor logs**: Check Claude Code logs for hook-related errors
5. **Isolate issues**: Test hooks one at a time to identify problems

## Learn more

- For reference documentation on hooks, see [Hooks reference](https://docs.anthropic.com/en/docs/claude-code/hooks).
- For comprehensive security best practices and safety guidelines, see [Security Considerations](https://docs.anthropic.com/en/docs/claude-code/hooks#security-considerations) in the hooks reference documentation.
- For troubleshooting steps and debugging techniques, see [Debugging](https://docs.anthropic.com/en/docs/claude-code/hooks#debugging) in the hooks reference documentation.

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-hooks.md`:

```md
# Hooks reference

This page provides reference documentation for implementing hooks in Claude Code.

## Configuration

Claude Code hooks are configured in your [settings files](/en/docs/claude-code/settings):

- `~/.claude/settings.json` - User settings
- `.claude/settings.json` - Project settings
- `.claude/settings.local.json` - Local project settings (not committed)
- Enterprise managed policy settings

### Structure

Hooks are organized by matchers, where each matcher can have multiple hooks:

```json
{
  "hooks": {
    "EventName": [
      {
        "matcher": "ToolPattern",
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/prompt-validator.py"
          }
        ]
      }
    ]
  }
}

Matcher: Pattern to match tool names, case-sensitive (only applicable for PreToolUse and PostToolUse)
Simple strings match exactly: Write matches only the Write tool
Supports regex: Edit|Write or Notebook.*
Use * to match all tools. You can also use empty string ("") or leave matcher blank.
Hooks: Array of commands to execute when the pattern matches
type: Currently only "command" is supported
command: The bash command to execute (can use $CLAUDE_PROJECT_DIR environment variable)
timeout: (Optional) How long a command should run, in seconds, before canceling that specific command.

For events like UserPromptSubmit, Notification, Stop, and SubagentStop that donâ€™t use matchers, you can omit the matcher field:

{
  "hooks": {
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/prompt-validator.py"
          }
        ]
      }
    ]
  }
}

Project-Specific Hook Scripts

You can use the environment variable CLAUDE_PROJECT_DIR (only available when Claude Code spawns the hook command) to reference scripts stored in your project, ensuring they work regardless of Claudeâ€™s current directory:

{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "command": "$CLAUDE_PROJECT_DIR/.claude/hooks/check-style.sh"
          }
        ]
      }
    ]
  }
}

Hook Events
PreToolUse

Runs after Claude creates tool parameters and before processing the tool call.

Common matchers:

Task - Subagent tasks (see subagents documentation)
Bash - Shell commands
Glob - File pattern matching
Grep - Content search
Read - File reading
Edit, MultiEdit - File editing
Write - File writing
WebFetch, WebSearch - Web operations
PostToolUse

Runs immediately after a tool completes successfully.

Recognizes the same matcher values as PreToolUse.

Notification

Runs when Claude Code sends notifications. Notifications are sent when:

Claude needs your permission to use a tool. Example: â€œClaude needs your permission to use Bashâ€
The prompt input has been idle for at least 60 seconds. â€œClaude is waiting for your inputâ€
UserPromptSubmit

Runs when the user submits a prompt, before Claude processes it. This allows you to add additional context based on the prompt/conversation, validate prompts, or block certain types of prompts.

Stop

Runs when the main Claude Code agent has finished responding. Does not run if the stoppage occurred due to a user interrupt.

SubagentStop

Runs when a Claude Code subagent (Task tool call) has finished responding.

PreCompact

Runs before Claude Code is about to run a compact operation.

Matchers:

manual - Invoked from /compact
auto - Invoked from auto-compact (due to full context window)
SessionStart

Runs when Claude Code starts a new session or resumes an existing session (which currently does start a new session under the hood). Useful for loading in development context like existing issues or recent changes to your codebase.

Matchers:

startup - Invoked from startup
resume - Invoked from -r, -c, or /resume
clear - Invoked from /clear
Hook Input

Hooks receive JSON data via stdin containing session information and event-specific data:

{
  // Common fields
  session_id: string,
  transcript_path: string, // Path to conversation JSON
  cwd: string              // The current working directory when the hook is invoked
  
  // Event-specific fields
  hook_event_name: string,
  ...
}

PreToolUse Input

The exact schema for tool_input depends on the tool.

{
  "session_id": "abc123",
  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "cwd": "/Users/",
  "hook_event_name": "PreToolUse",
  "tool_name": "",
  "tool_input": {
    "file_path": "/path/to/file.txt",
    "content": ""
  }
}

PostToolUse Input

The exact schema for tool_input and tool_response depends on the tool.

{
  "session_id": "abc123",
  "transcript_path": "/Users/.../.claude/projects/.../00893aaf-19fa-41d2-8238-13269b9b3ca0.jsonl",
  "cwd": "/Users/",
  "hook_event_name": "",
  "tool_name": "",
  "tool_input":{
    "... ... ..."
   },
   ...
}

Notification Input
{
   ...
}

UserPromptSubmit Input
{
   ...
}

Stop and SubagentStop Input

sstop_hook_active == true. Check this value or process the transcript to prevent Claude Code from running indefinitely.

{
   ...
}

PreCompact Input

For manual, custom_instructions comes from what the user passes into /compact. For auto, custom_instructions is empty.

{
   ...
}

SessionStart Input
{
   ...
}

Hook Output

There are two ways for hooks to return output back to Claude Code. The output communicates whether to block and any feedback that should be shown to Claude and the user.

Simple: Exit Code

Hooks communicate status through exit codes, stdout, and stderr:

Field	Description
Exit code	Exit code: If successful, returns code zero; otherwise blocks tool call and shows stderr to Claude
Exit code	Exit code: If failed, returns code two; blocks tool call and shows stderr to user
Other exit codes	Non-blocking errors show stderr to user

Reminder: Claude Code does not see stdout if the exit code is zero, except for the UserPromptSubmit hook where stdout is injected as context.

Exit Code Behavior Table
Hook Event	Behavior
PreToolUse	Blocks tool call, shows stderr to Claude
PostToolUse	Shows stderr to Claude (tool already ran)
Notification	N/A; shows stderr to user only
UserPromptSubmit	Blocks prompt processing; erases prompt; shows stderr to user only
Stop	Blocks stoppage; shows stderr to Claude
SubagentStop	Blocks stoppage; shows stderr to Claude subagent
PreCompact	N/A; shows stderr to user only
SessionStart	N/A; shows stderr to user only
Advanced: JSON Output

Hooks can return structured JSON in stdout for more sophisticated control:

Common JSON Fields

All hook types can include these optional fields:

{
	"continue":
		boolean,
	// Whether Claudie must continue after hook execution (default: true)
	"stopReason":
		String,
	// Message shown when continue is false 
}


If continue is false, Claudie stops processing after the hooks run.

For PreToolUse:
For PostToolUse:
For UserPromptSubmit:
For Stop:
For SubagentStop:
In all cases:
"continue" = false" takes precedence over anyâ€œdecisionâ€:â€œblockâ€` output.
"stopReason" accompanies "continue" with a reason shown to Claudie.
"decision" follows "request"
"reason" follows "request"
PreToolUse Decision Control

<pre>{</pre>

<pre> hookSpecificOutput:</pre>

<pre> {</pre>

<pre> hookEventName:</pre>

<pre> String,</pre>

<pre> permissionDecision:</pre>

<pre> String,</pre>

<pre> permissionDecisionReason:</pre>

<pre> String</pre>

<pre> },</pre>

<pre> decision:</pre>

<pre> String,</pre>

<pre> reason:</pre>

<pre> String</pre>

<pre>}</pre>

PostToolUse Decision Control

<pre>{</pre>

<pre> decision:</pre>

<pre> String,</pre>

<pre> reason:</pre>

<pre> String</pre>

<pre>}</pre>

UserPromptSubmit Decision Control

<pre>{</pre>

<pre> discision:</pre>

<pre> String,</pre>

<pre> reason:</pre>

<pre> String,</pre>

<pre> hookSpecificOutput:</pre>

<pre> {</pre>

/pre>

Stop and SubagentStop Decision Control

<p>{</p>

<p>â€œdecisionâ€:

pString,</p>

<p>â€œreasonâ€:

pString</p>

<p>}</p>

SessionStart Decision Control

<p>{</p>

<p>â€œhookSpecificOutputâ€:

p{</p>

<p>â€œhookEventNameâ€>

pString,</p>

<p>â€œadditionalContextâ€>

pString</p>

<p>}</p>

<p>}</p>

Exit Code Example: Bash Command Validation
#!/usr/bin/env python3  
import json  
import sys  
import re  
import sys  

# Define validation rules as a list of (regex pattern, message) tuples  
VALIDATION_RULES = [  
    ("r'\bgrep\b(?!.*\\.|)", 
	   "\"Use 'rg' (ripgrep) instead of 'grep' for better performance and features\","),  
    ("r'\bfind\s+\S+\s+-name\b", 
	   "\"Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance\",")  
]

def validate_command(command):
    issues = []
    
    # Validate command's arguments   
    for pattern,message in VALIDATION_RULES:
        if re.search(pattern, command):
            issues.append(message)
        
	return issues
    
try:
    input_data = json.load(sys.stdin)
except json.JSONDecodeError as e:
	print(f"Error: Invalid JSON input:\n{e}", file=sys.stderr)
	sys.exit(1)

tool_name = input_data.get("tool_name", "")
tool_input = input_data.get("tool_input", {})
command = tool_input.get("command", "")

if tool_name != "" :	
	sys.exit(1)

# Validate command   
issues = validate_command(command)

if issues :
	for message in issues:
		print(f"{message}", file=sys.stderr)
	sys.exit(2)

JSON Output Example: UserPromptSubmit with Approval
#!/usr/bin/env python3  
import json  
import sys  

# Load input from stdin   
try:
	input_data = json.load(sys.stdin)
except json.JSONDecodeError as e:
	print(f"Error: Invalid JSON input:\n{e}", file=sys.stderr)
	sys.exit(1)

tool_name = input_data.get("tool_name", "")
tool_input = input_data.get("tool_input", {})

# Example: Auto-approved file writes   
if tool_name == "":
	file_path = tool_input.get("file_path", "")
	if file_path.endswith(("md","mdx","txt","json")):
		
		output = {			
			'decision': 'approve',						
			'reason': f"Documentation file auto-approved",					
			"suppressOutput":
			 True				   
	}

	print(json.dumps(output))	
	sys.exit(0)


sys.exit(0)

```

`claude-model-switcher/docs/claude-code-interactive-mode.md`:

```md
# Claude Code Interactive Mode Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/interactive-mode*
*Download date: 2025-08-21*

---

## Keyboard shortcuts

### General controls

| Shortcut | Description | Context |
|----------|-------------|---------|
| `Ctrl+C` | Cancel current input or generation | Standard interrupt |
| `Ctrl+D` | Exit Claude Code session | EOF signal |
| `Ctrl+L` | Clear terminal screen | Keeps conversation history |
| `Up/Down arrows` | Navigate command history | Recall previous inputs |
| `Esc` + `Esc` | Edit previous message | Double-escape to modify |

### Multiline input

| Method | Shortcut | Context |
|--------|----------|---------|
| Quick escape | `\` + `Enter` | Works in all terminals |
| macOS default | `Option+Enter` | Default on macOS |
| Terminal setup | `Shift+Enter` | After `/terminal-setup` |
| Control sequence | `Ctrl+J` | Line feed character for multiline |
| Paste mode | Paste directly | For code blocks, logs |

### Quick commands

| Shortcut | Description | Notes |
|----------|-------------|-------|
| `#` at start | Memory shortcut - add to CLAUDE.md | Prompts for file selection |
| `/` at start | Slash command | See [slash commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands) |

## Vim mode

Enable vim-style editing with `/vim` command or configure permanently via `/config`.

### Mode switching

| Command | Action | From mode |
|----------|---------|-----------|
| `Esc` | Enter NORMAL mode | INSERT |
| `i` | Insert before cursor | NORMAL |
| `I` | Insert at beginning of line | NORMAL |
| `a` | Insert after cursor | NORMAL |
| `A` | Insert at end of line | NORMAL |
| `o` | Open line below | NORMAL |
| `O` | Open line above | NORMAL |

### Navigation (NORMAL mode)

| Command | Action |
|----------|---------|
| `h`/`j`/`k`/`l` | Move left/down/up/right |
| `w` | Next word |
| `e` | End of word |
| `b` | Previous word |
| `0` | Beginning of line |
| `$` | End of line |
| `^` | First non-blank character |
| `gg` | Beginning of input |
| `G` | End of input |

### Editing (NORMAL mode)

| Command | Action |
|----------|---------|
| `x` | Delete character |
| `dd` | Delete line |
| `D` | Delete to end of line |
| `dw`/`de`/`db` | Delete word/to end/back |
| `cc` | Change line |
| `C` | Change to end of line |
| `cw`/`ce`/`cb` | Change word/to end/back |
| `.` | Repeat last change |

## Command history

Claude Code maintains command history for the current session:

- History is stored per working directory
- Cleared with `/clear` command
- Use Up/Down arrows to navigate (see keyboard shortcuts above)
- **Ctrl+R**: Reverse search through history (if supported by terminal)
- **Note**: History expansion (`!`) is disabled by default

## Session Management

### Starting a Session

```bash
# Start new session
claude

# Start with initial prompt
claude "Explain this project"

# Continue most recent conversation
claude --continue

# Resume specific session
claude --resume "session-id-here"
```

### Session Features

- **Persistent context**: Maintains conversation history
- **Working directory awareness**: Remembers project context
- **Memory integration**: Loads CLAUDE.md files automatically
- **Tool state**: Maintains tool permissions and MCP server connections

### Ending a Session

```bash
# Graceful exit
Ctrl+D

# Cancel current operation
Ctrl+C

# Clear and exit
/clear
Ctrl+D
```

## Input Modes

### Standard Input Mode

- **Single line**: Default for most queries
- **Multiline**: Use escape sequences for longer inputs
- **Code blocks**: Paste directly or use multiline mode

### Advanced Input Features

#### Multiline Input Methods

1. **Backslash + Enter**: `\` followed by Enter
2. **Option+Enter**: macOS default
3. **Shift+Enter**: After terminal setup
4. **Ctrl+J**: Line feed character

#### Code Block Handling

```python
# Paste code blocks directly
def example_function():
    return "Hello, World!"

# Claude will automatically detect and format
```

#### Large Text Input

```bash
# Use file redirection for large inputs
claude -p "$(cat large_file.txt)" "Analyze this content"

# Or use pipes
cat large_file.txt | claude -p "Process this data"
```

## Navigation and Editing

### Cursor Movement

- **Arrow keys**: Navigate through input
- **Home/End**: Jump to start/end of line
- **Ctrl+Left/Right**: Word navigation (in supported terminals)

### Text Editing

- **Backspace/Delete**: Remove characters
- **Ctrl+U**: Delete to beginning of line
- **Ctrl+K**: Delete to end of line
- **Ctrl+W**: Delete previous word

### Selection and Clipboard

- **Shift+Arrows**: Select text (in supported terminals)
- **Ctrl+Shift+C**: Copy selection
- **Ctrl+Shift+V**: Paste clipboard

## Interactive Features

### Real-time Feedback

- **Typing indicators**: Shows when Claude is processing
- **Progress indicators**: Displays during long operations
- **Streaming output**: See responses as they're generated
- **Error messages**: Clear error reporting and suggestions

### Conversation Context

- **Message history**: Scroll through previous exchanges
- **Context indicators**: Shows current model and session info
- **Memory status**: Displays loaded CLAUDE.md files
- **Tool usage**: Shows which tools are being used

### Customization Options

#### Prompt Customization

```bash
# Add memory during conversation
# This will be added to CLAUDE.md
Use 2-space indentation for Python files

# Use system prompts
/append-system-prompt "Focus on security aspects"
```

#### Mode Switching

```bash
# Switch permission modes
/permission-mode plan
/permission-mode acceptEdits

# Toggle features
/vim  # Enable vim mode
/verbose  # Enable verbose logging
```

## Advanced Interactive Features

### Subagent Integration

```bash
# Use specialized subagents
Ask the code-reviewer to check this function
Use the data-scientist to analyze these results
```

### MCP Tool Usage

```bash
# Interact with MCP servers
Check Sentry for recent errors
Query the database for user information
```

### Multi-turn Conversations

```bash
# Build on previous context
Now add error handling to that function
What are the security implications?
Create tests for this code
```

## Troubleshooting Interactive Mode

### Common Issues

1. **Multiline input not working**
   - Try `\` + `Enter`
   - Run `/terminal-setup` for Shift+Enter
   - Check terminal compatibility

2. **History not available**
   - Use Up/Down arrows
   - Check if `/clear` was used recently
   - Verify working directory permissions

3. **Vim mode not responding**
   - Press `Esc` to enter NORMAL mode
   - Check if vim mode is enabled (`/vim`)
   - Verify terminal key handling

### Debug Commands

```bash
# Check current session info
/session

# View loaded memories
/memory

# Check configuration
/config list

# Test terminal features
/terminal-setup

# Verify vim mode status
/vim
```

### Performance Issues

- **Slow response times**: Check network connectivity
- **High memory usage**: Clear conversation history with `/clear`
- **Terminal lag**: Reduce verbose logging or switch terminal

## Terminal Compatibility

### Supported Terminals

- **iTerm2** (macOS): Full feature support
- **Terminal.app** (macOS): Basic support
- **GNOME Terminal** (Linux): Good support
- **Konsole** (Linux): Good support
- **Windows Terminal**: Good support
- **Alacritty**: Excellent support
- **WezTerm**: Excellent support

### Terminal Setup

```bash
# Configure terminal for optimal experience
/terminal-setup

# This will:
# - Enable Shift+Enter for multiline
# - Configure key bindings
# - Test terminal capabilities
```

## Accessibility Features

### Keyboard Navigation

- **Full keyboard control**: Navigate without mouse
- **Consistent shortcuts**: Standard key combinations
- **Mode indicators**: Visual feedback for current mode

### Visual Feedback

- **High contrast modes**: Available through terminal themes
- **Clear status indicators**: Shows current state and mode
- **Error highlighting**: Visual distinction for errors

### Screen Reader Support

- **Structured output**: Compatible with screen readers
- **Status announcements**: Important changes are announced
- **Error reporting**: Clear error messages for assistive technologies

## Best Practices

### Efficient Usage

1. **Use keyboard shortcuts**: Learn common shortcuts for faster interaction
2. **Leverage history**: Use Up/Down arrows to repeat similar commands
3. **Organize conversations**: Use `/clear` between unrelated topics
4. **Customize settings**: Configure vim mode and other preferences

### Productivity Tips

1. **Template commands**: Save common queries for reuse
2. **Batch operations**: Use multiple related queries in sequence
3. **Context maintenance**: Keep related work in single sessions
4. **Memory management**: Use `#` shortcut for frequent instructions

### Collaboration Features

1. **Session sharing**: Share session IDs with team members
2. **Consistent configurations**: Use project-level settings.json
3. **Memory standardization**: Use CLAUDE.md for team guidelines
4. **Tool coordination**: Configure MCP servers for team workflows

## Integration with Other Tools

### IDE Integration

```bash
# Use from VS Code integrated terminal
# Features work seamlessly with IDE workflows

# Configure VS Code tasks for common operations
# See IDE integration documentation
```

### Git Integration

```bash
# Use in git workflows
git add .
claude "Review staged changes"
git commit -m "Changes reviewed by Claude"
```

### CI/CD Integration

```bash
# Use in automated pipelines
claude -p "Validate configuration" --output-format json
# Parse JSON output for CI decisions
```

## See Also

- [Slash commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands) - Interactive session commands
- [CLI reference](https://docs.anthropic.com/en/docs/claude-code/cli-reference) - Command-line flags and options
- [Settings](https://docs.anthropic.com/en/docs/claude-code/settings) - Configuration options
- [Memory management](https://docs.anthropic.com/en/docs/claude-code/memory) - Managing CLAUDE.md files
- [CLI reference](https://docs.anthropic.com/en/docs/claude-code/cli-reference) - Command-line interface documentation
- [Slash commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands) - Interactive commands reference

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-mcp.md`:

```md
# Claude Code MCP Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/mcp*
*Download date: 2025-08-21*

---

## Overview

Claude Code can connect to hundreds of external tools and data sources through the Model Context Protocol (MCP), an open-source standard for AI-tool integrations. MCP servers give Claude Code access to your tools, databases, and APIs.

## What you can do with MCP

With MCP servers connected, you can ask Claude Code to:

- **Implement features from issue trackers**: "Add the feature described in JIRA issue ENG-4521 and create a PR on GitHub."
- **Analyze monitoring data**: "Check Sentry and Statsig to check the usage of the feature described in ENG-4521."
- **Query databases**: "Find emails of 10 random users who used feature ENG-4521, based on our Postgres database."
- **Integrate designs**: "Update our standard email template based on the new Figma designs that were posted in Slack"
- **Automate workflows**: "Create Gmail drafts inviting these 10 users to a feedback session about the new feature."

## Popular MCP servers

Here are some commonly used MCP servers you can connect to Claude Code:

### Development & Testing Tools

**Sentry** - Monitor errors, debug production issues
```bash
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
```

**Socket** - Security analysis for dependencies
```bash
claude mcp add --transport http socket https://mcp.socket.dev/
```

**Hugging Face** - Provides access to Hugging Face Hub information and Gradio AI Applications
```bash
claude mcp add --transport http hugging-face https://huggingface.co/mcp
```

**Jam** - Debug faster with AI agents that can access Jam recordings like video, console logs, network requests, and errors
```bash
claude mcp add --transport http jam https://mcp.jam.dev/mcp
```

### Project Management & Documentation

**Asana** - Interact with your Asana workspace to keep projects on track
```bash
claude mcp add --transport sse asana https://mcp.asana.com/sse
```

**Atlassian** - Manage your Jira tickets and Confluence docs
```bash
claude mcp add --transport sse atlassian https://mcp.atlassian.com/v1/sse
```

**ClickUp** - Task management, project tracking
```bash
claude mcp add clickup --env CLICKUP_API_KEY=YOUR_KEY --env CLICKUP_TEAM_ID=YOUR_ID -- npx -y @hauptsache.net/clickup-mcp
```

**Intercom** - Access real-time customer conversations, tickets, and user data
```bash
claude mcp add --transport http intercom https://mcp.intercom.com/mcp
```

**Linear** - Integrate with Linear's issue tracking and project management
```bash
claude mcp add --transport sse linear https://mcp.linear.app/sse
```

**Notion** - Read docs, update pages, manage tasks
```bash
claude mcp add --transport http notion https://mcp.notion.com/mcp
```

**Box** - Ask questions about your enterprise content, get insights from unstructured data, automate content workflows
```bash
claude mcp add --transport http box https://mcp.box.com/
```

**Fireflies** - Extract valuable insights from meeting transcripts and summaries
```bash
claude mcp add --transport http fireflies https://api.fireflies.ai/mcp
```

**Monday.com** - Manage monday.com boards by creating items, updating columns, assigning owners, setting timelines, adding CRM activities, and writing summaries
```bash
claude mcp add --transport sse monday https://mcp.monday.com/sse
```

### Databases & Data Management

**Airtable** - Read/write records, manage bases and tables
```bash
claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx -y airtable-mcp-server
```

**Daloopa** - Supplies high quality fundamental financial data sourced from SEC Filings, investor presentations
```bash
claude mcp add --transport http daloopa https://mcp.daloopa.com/server/mcp
```

**HubSpot** - Access and manage HubSpot CRM data by fetching contacts, companies, and deals, and creating and updating records
```bash
claude mcp add --transport http hubspot https://mcp.hubspot.com/anthropic
```

### Payments & Commerce

**PayPal** - Integrate PayPal commerce capabilities, payment processing, transaction management
```bash
claude mcp add --transport http paypal https://mcp.paypal.com/mcp
```

**Plaid** - Analyze, troubleshoot, and optimize Plaid integrations. Banking data, financial account linking
```bash
claude mcp add --transport sse plaid https://api.dashboard.plaid.com/mcp/sse
```

**Square** - Use an agent to build on Square APIs. Payments, inventory, orders, and more
```bash
claude mcp add --transport sse square https://mcp.squareup.com/sse
```

**Stripe** - Payment processing, subscription management, and financial transactions
```bash
claude mcp add --transport http stripe https://mcp.stripe.com
```

### Design & Media

**Figma** - Access designs, export assets. Requires latest Figma Desktop with Dev Mode MCP Server. If you have an existing server at http://127.0.0.1:3845/sse, delete it first before adding the new one.
```bash
claude mcp add --transport http figma-dev-mode-mcp-server http://127.0.0.1:3845/mcp
```

**InVideo** - Build video creation capabilities into your applications
```bash
claude mcp add --transport sse invideo https://mcp.invideo.io/sse
```

**Canva** - Browse, summarize, autofill, and even generate new Canva designs directly from Claude
```bash
claude mcp add --transport http canva https://mcp.canva.com/mcp
```

### Infrastructure & DevOps

**Cloudflare** - Build applications, analyze traffic, monitor performance, and manage security settings through Cloudflare. Multiple services available. See documentation for specific server URLs. Claude Code can use the Cloudflare CLI if installed.

**Netlify** - Create, deploy, and manage websites on Netlify. Control all aspects of your site from creating secrets to enforcing access controls to aggregating form submissions
```bash
claude mcp add --transport http netlify https://netlify-mcp.netlify.app/mcp
```

**Stytch** - Configure and manage Stytch authentication services, redirect URLs, email templates, and workspace settings
```bash
claude mcp add --transport http stytch http://mcp.stytch.dev/mcp
```

**Vercel** - Vercel's official MCP server, allowing you to search and navigate documentation, manage projects and deployments, and analyze deployment logsâ€”all in one place
```bash
claude mcp add --transport http vercel https://mcp.vercel.com/
```

### Automation & Integration

**Workato** - Access any application, workflows or data via Workato, made accessible for AI. MCP servers are programmatically generated

**Zapier** - Connect to nearly 8,000 apps through Zapier's automation platform. Generate a user-specific URL at mcp.zapier.com

## Installing MCP servers

MCP servers can be configured in three different ways depending on your needs:

### Option 1: Add a local stdio server

Stdio servers run as local processes on your machine. They're ideal for tools that need direct system access or custom scripts.

### Option 2: Add a remote SSE server

SSE (Server-Sent Events) servers provide real-time streaming connections. Many cloud services use this for live updates.

### Option 3: Add a remote HTTP server

HTTP servers use standard request/response patterns. Most REST APIs and web services use this transport.

### Managing your servers

Once configured, you can manage your MCP servers with these commands:

- `claude mcp list` - List all configured servers
- `claude mcp remove <server-name>` - Remove a server
- `claude mcp reset` - Reset all MCP configurations
- `claude mcp status` - Check server status

## MCP installation scopes

MCP servers can be configured at three different scope levels, each serving distinct purposes for managing server accessibility and sharing. Understanding these scopes helps you determine the best way to configure servers for your specific needs.

### Local scope

Local-scoped servers represent the default configuration level and are stored in your project-specific user settings. These servers remain private to you and are only accessible when working within the current project directory. This scope is ideal for personal development servers, experimental configurations, or servers containing sensitive credentials that shouldn't be shared.

### Project scope

Project-scoped servers enable team collaboration by storing configurations in a `.mcp.json` file at your project's root directory. This file is designed to be checked into version control, ensuring all team members have access to the same MCP tools and services. When you add a project-scoped server, Claude Code automatically creates or updates this file with the appropriate configuration structure.

The resulting `.mcp.json` file follows a standardized format:

```json
{
  "mcpServers": {
    "sentry": {
      "command": "npx",
      "args": ["-y", "@sentry/mcp-server"],
      "env": {
        "SENTRY_AUTH_TOKEN": "${SENTRY_AUTH_TOKEN}"
      }
    },
    "slack": {
      "transport": "sse",
      "url": "https://mcp.slack.com/sse"
    }
  }
}
```

For security reasons, Claude Code prompts for approval before using project-scoped servers from `.mcp.json` files. If you need to reset these approval choices, use the `claude mcp reset-project-choices` command.

### User scope

User-scoped servers provide cross-project accessibility, making them available across all projects on your machine while remaining private to your user account. This scope works well for personal utility servers, development tools, or services you frequently use across different projects.

### Choosing the right scope

Select your scope based on:

- **Local scope**: Personal servers, experimental configurations, or sensitive credentials specific to one project
- **Project scope**: Team-shared servers, project-specific tools, or services required for collaboration
- **User scope**: Personal utilities needed across multiple projects, development tools, or frequently-used services

### Scope hierarchy and precedence

MCP server configurations follow a clear precedence hierarchy. When servers with the same name exist at multiple scopes, the system resolves conflicts by prioritizing local-scoped servers first, followed by project-scoped servers, and finally user-scoped servers. This design ensures that personal configurations can override shared ones when needed.

### Environment variable expansion in `.mcp.json`

Claude Code supports environment variable expansion in `.mcp.json` files, allowing teams to share configurations while maintaining flexibility for machine-specific paths and sensitive values like API keys.

**Supported syntax:**
- `${VAR}` - Expands to the value of environment variable `VAR`
- `${VAR:-default}` - Expands to `VAR` if set, otherwise uses `default`

**Expansion locations:** Environment variables can be expanded in:
- `command` - The server executable path
- `args` - Command-line arguments
- `env` - Environment variables passed to the server
- `url` - For SSE/HTTP server types
- `headers` - For SSE/HTTP server authentication

**Example with variable expansion:**
```json
{
  "mcpServers": {
    "postgres": {
      "command": "${POSTGRES_CLIENT_PATH:-psql}",
      "args": ["-h", "${DB_HOST:-localhost}", "-U", "${DB_USER}"],
      "env": {
        "PGPASSWORD": "${DB_PASSWORD}"
      }
    }
  }
}
```

If a required environment variable is not set and has no default value, Claude Code will fail to parse the config.

## Practical examples

### Example: Monitor errors with Sentry

1. **Add the Sentry MCP server:**
```bash
claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
```

2. **Configure authentication:**
```bash
export SENTRY_AUTH_TOKEN="your-token-here"
```

3. **Use in conversation:**
```
Check Sentry for any new errors related to the payment processing feature
```

### Example: Query databases with PostgreSQL

1. **Add a PostgreSQL MCP server:**
```bash
claude mcp add postgres --command psql --args "-h localhost -U user" --env PGPASSWORD="${DB_PASSWORD}"
```

2. **Query the database:**
```
Find all users who signed up in the last 30 days and their email addresses
```

## Authenticate with remote MCP servers

Many cloud-based MCP servers require authentication. Claude Code supports OAuth 2.0 for secure connections.

### OAuth 2.0 Authentication Flow

1. **Initiate authentication:**
```bash
claude mcp auth <server-name>
```

2. **Complete authentication in browser**
3. **Server is now authenticated and ready to use**

### API Key Authentication

For servers that use API keys:

1. **Set environment variable:**
```bash
export API_KEY="your-api-key-here"
```

2. **Add server with authentication:**
```bash
claude mcp add <server-name> --env API_KEY="${API_KEY}"
```

## Add MCP servers from JSON configuration

If you have a JSON configuration for an MCP server, you can add it directly:

1. **Create configuration file:**
```json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["server.js"],
      "env": {
        "API_KEY": "your-key"
      }
    }
  }
}
```

2. **Import the configuration:**
```bash
claude mcp import --file config.json --scope project
```

## Import MCP servers from Claude Desktop

If you've already configured MCP servers in Claude Desktop, you can import them:

1. **List available servers:**
```bash
claude mcp import --list-claude-desktop
```

2. **Import specific server:**
```bash
claude mcp import --from-claude-desktop <server-name> --scope user
```

3. **Import all servers:**
```bash
claude mcp import --from-claude-desktop --all --scope project
```

## Use Claude Code as an MCP server

You can use Claude Code itself as an MCP server that other applications can connect to:

1. **Start Claude Code as MCP server:**
```bash
claude --mcp-server
```

2. **Configure in Claude Desktop:**
```json
{
  "mcpServers": {
    "claude-code": {
      "command": "claude",
      "args": ["--mcp-server"]
    }
  }
}
```

## Use MCP resources

MCP servers can expose resources that you can reference using @ mentions, similar to how you reference files.

### Reference MCP resources

1. **List available resources:**
```bash
claude mcp resources
```

2. **Reference a resource:**
```
Analyze the @sentry:project/my-project resource
```

3. **Get resource details:**
```
Show me details about @notion:page/1234567890
```

### Reference MCP resources

Some MCP servers expose resources that can be referenced using @ mentions:

- **Database records**: `@postgres:users/123`
- **Project management**: `@jira:ticket/PROJ-123`
- **Documentation**: `@notion:page/my-page`
- **Monitoring**: `@sentry:project/my-project`

## Use MCP prompts as slash commands

MCP servers can expose prompts that become available as slash commands in Claude Code.

### Execute MCP prompts

1. **List available prompts:**
```bash
claude mcp prompts
```

2. **Execute a prompt:**
```bash
claude /prompt-name "your input here"
```

3. **Execute with parameters:**
```bash
claude /deploy "my-feature" --environment staging
```

### Available MCP prompts

Different MCP servers expose different prompts:

- **Project management**: `/create-ticket`, `/update-status`
- **Deployment**: `/deploy`, `/rollback`
- **Documentation**: `/create-doc`, `/update-page`
- **Monitoring**: `/check-health`, `/get-metrics`

## MCP Best Practices

### Security

- **Use environment variables** for sensitive credentials
- **Limit server permissions** to only what's necessary
- **Review server configurations** before committing to version control
- **Use appropriate scopes** to control access

### Performance

- **Monitor server performance** and resource usage
- **Use caching** where appropriate for frequently accessed data
- **Configure timeouts** for long-running operations
- **Consider connection limits** for remote servers

### Configuration Management

- **Use version control** for project-scoped configurations
- **Document server dependencies** and requirements
- **Test configurations** in development environments
- **Use environment variable expansion** for flexible configurations

### Troubleshooting

- **Check server status** with `claude mcp status`
- **Review logs** for connection or authentication issues
- **Test server connectivity** independently
- **Verify environment variables** are properly set

## Advanced MCP Features

### Dynamic Server Loading

Some MCP servers support dynamic loading of additional capabilities:

```bash
claude mcp add <server-name> --dynamic-load
```

### Server Groups

Organize related servers into groups for easier management:

```bash
claude mcp group create "development" --servers postgres,redis,local-dev
claude mcp group create "production" --servers sentry,datadog,monitoring
```

### Custom Transports

For specialized requirements, you can define custom transport configurations:

```bash
claude mcp add custom-server --transport custom --config transport-config.json
```

## MCP Server Development

If you need to develop your own MCP servers:

1. **Use the MCP SDK**: https://modelcontextprotocol.io/quickstart/server
2. **Follow MCP specifications**: Ensure compliance with the protocol
3. **Test thoroughly**: Validate with Claude Code and other MCP clients
4. **Document your server**: Provide clear installation and usage instructions

## Related Documentation

- [Model Context Protocol](https://modelcontextprotocol.io/introduction) - Official MCP documentation
- [MCP SDK](https://modelcontextprotocol.io/quickstart/server) - Server development guide
- [GitHub Actions](https://docs.anthropic.com/en/docs/claude-code/github-actions) - CI/CD integration
- [Troubleshooting](https://docs.anthropic.com/en/docs/claude-code/troubleshooting) - Common issues and solutions

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-memory.md`:

```md
# Claude Code Memory Management Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/memory*
*Download date: 2025-08-21*

---

## Overview

Claude Code can remember your preferences across sessions, like style guidelines and common commands in your workflow.

## Determine memory type

Claude Code offers four memory locations in a hierarchical structure, each serving a different purpose:

| Memory Type | Location | Purpose | Use Case Examples | Shared With |
|-------------|----------|---------|-------------------|-------------|
| **Enterprise policy** | macOS: `/Library/Application Support/ClaudeCode/CLAUDE.md`<br>Linux: `/etc/claude-code/CLAUDE.md`<br>Windows: `C:\ProgramData\ClaudeCode\CLAUDE.md` | Organization-wide instructions managed by IT/DevOps | Company coding standards, security policies, compliance requirements | All users in organization |
| **Project memory** | `./CLAUDE.md` | Team-shared instructions for the project | Project architecture, coding standards, common workflows | Team members via source control |
| **User memory** | `~/.claude/CLAUDE.md` | Personal preferences for all projects | Code styling preferences, personal tooling shortcuts | Just you (all projects) |
| **Project memory (local)** | `./CLAUDE.local.md` | Personal project-specific preferences | *(Deprecated, see below)* Your sandbox URLs, preferred test data | Just you (current project) |

All memory files are automatically loaded into Claude Code's context when launched. Files higher in the hierarchy take precedence and are loaded first, providing a foundation that more specific memories build upon.

## CLAUDE.md imports

CLAUDE.md files can import additional files using `@path/to/import` syntax. The following example imports 3 files:

```markdown
# Project Guidelines

@./architectural-principles.md
@../shared/coding-standards.md
@~/.claude/personal-preferences.md

## Project Overview

This project follows the architectural principles defined in our imported files...
```

Both relative and absolute paths are allowed. In particular, importing files in user's home dir is a convenient way for your team members to provide individual instructions that are not checked into the repository. Previously `CLAUDE.local.md` served a similar purpose, but is now deprecated in favor of imports since they work better across multiple git worktrees.

To avoid potential collisions, imports are not evaluated inside markdown code spans and code blocks.

Imported files can recursively import additional files, with a max-depth of 5 hops. You can see what memory files are loaded by running `/memory` command.

## How Claude looks up memories

Claude Code reads memories recursively: starting in the cwd, Claude Code recurses up to (but not including) the root directory `/` and reads any CLAUDE.md or CLAUDE.local.md files it finds. This is especially convenient when working in large repositories where you run Claude Code in `foo/bar/`, and have memories in both `foo/CLAUDE.md` and `foo/bar/CLAUDE.md`.

Claude will also discover CLAUDE.md nested in subtrees under your current working directory. Instead of loading them at launch, they are only included when Claude reads files in those subtrees.

## Quickly add memories with the `#` shortcut

The fastest way to add a memory is to start your input with the `#` character:

```
# Use 2-space indentation for Python files
```

You'll be prompted to select which memory file to store this in.

## Directly edit memories with `/memory`

Use the `/memory` slash command during a session to open any memory file in your system editor for more extensive additions or organization.

## Set up project memory

Suppose you want to set up a CLAUDE.md file to store important project information, conventions, and frequently used commands.

Bootstrap a CLAUDE.md for your codebase with the following command:

```bash
claude memory init
```

This will create a comprehensive CLAUDE.md file with sections for:

- Project overview and architecture
- Coding standards and style guidelines
- Common commands and workflows
- Testing practices
- Deployment procedures
- Team collaboration guidelines

Example generated CLAUDE.md:

```markdown
# Project Memory

## Project Overview
This is a [project type] project that [main purpose].

## Architecture
- Frontend: [technologies used]
- Backend: [technologies used]
- Database: [database type]
- Deployment: [deployment method]

## Coding Standards

### General
- Use [indentation style] indentation
- Follow [naming convention]
- Maximum line length: [number] characters

### Language-Specific
- [Language 1]: [specific rules]
- [Language 2]: [specific rules]

## Common Commands

### Development
```bash
# Start development server
npm run dev

# Run tests
npm test

# Build project
npm run build
```

### Database
```bash
# Run migrations
npm run migrate

# Access database
npm run db:shell
```

### Deployment
```bash
# Deploy to staging
npm run deploy:staging

# Deploy to production
npm run deploy:prod
```

## Testing
- Write unit tests for all new features
- Maintain [test coverage]% test coverage
- Use [testing framework] for testing

## Code Review
- All PRs must be reviewed by at least [number] team members
- Use [code review tool] for automated checks
- Follow [PR template] for pull requests

## Documentation
- Update documentation for all new features
- Use [documentation format]
- Keep documentation in sync with code changes
```

## Organization-level memory management

Enterprise organizations can deploy centrally managed CLAUDE.md files that apply to all users.

To set up organization-level memory management:

1. **Create the enterprise memory file** in the appropriate location for your operating system:

   - **macOS**: `/Library/Application Support/ClaudeCode/CLAUDE.md`
   - **Linux/WSL**: `/etc/claude-code/CLAUDE.md`
   - **Windows**: `C:\ProgramData\ClaudeCode\CLAUDE.md`

2. **Deploy via your configuration management system** (MDM, Group Policy, Ansible, etc.) to ensure consistent distribution across all developer machines.

Example enterprise CLAUDE.md:

```markdown
# Enterprise Development Standards

## Security Requirements
- All code must pass security scanning before deployment
- Use approved libraries from our artifact registry
- Follow our secure coding guidelines
- Report security vulnerabilities through our designated channels

## Compliance Standards
- Adhere to [industry standards] for data handling
- Maintain proper audit trails for all operations
- Follow our data retention policies
- Use approved encryption methods for sensitive data

## Development Tools
- Use [IDE] with our approved plugins
- Configure [linting tool] with our enterprise rules
- Use [version control] with our branching strategy
- Follow our build and deployment pipeline

## Communication
- Use [communication platform] for team discussions
- Follow our meeting protocols and documentation standards
- Use our project management tools for task tracking
- Participate in regular code reviews and knowledge sharing

## Training and Resources
- Complete required security training annually
- Attend regular development best practices workshops
- Use our internal knowledge base for reference
- Participate in mentoring and skill development programs
```

## Memory best practices

### Be Specific
- **Good**: "Use 2-space indentation for Python files and 4-space for JavaScript files"
- **Bad**: "Format code properly"

- **Good**: "Run tests with `npm test` before committing changes"
- **Bad**: "Test your code"

### Use Structure to Organize
Format each individual memory as a bullet point and group related memories under descriptive markdown headings:

```markdown
## Python Development
- Use 2-space indentation
- Follow PEP 8 naming conventions
- Include type hints for all function parameters
- Write docstrings for all public functions

## Database Operations
- Use parameterized queries to prevent SQL injection
- Always close database connections in finally blocks
- Use connection pooling for better performance
- Log all database operations for audit purposes

## Git Workflow
- Create feature branches from main
- Use descriptive branch names (feature/your-name/feature-description)
- Keep commits small and focused
- Include ticket numbers in commit messages
```

### Review Periodically
Update memories as your project evolves to ensure Claude is always using the most up to date information and context.

### Use Hierarchical Organization
Leverage the memory hierarchy effectively:

- **Enterprise level**: Company-wide policies and standards
- **Project level**: Project-specific architecture and workflows
- **User level**: Personal preferences and shortcuts
- **Local level**: (Deprecated) Use imports instead

### Import Related Files
Use imports to organize large memory files and share common configurations:

```markdown
# Project Memory

@./architecture.md
@./coding-standards.md
@../shared/company-policies.md
@~/.claude/personal-shortcuts.md

## Project-Specific Guidelines
[Project-specific content here]
```

### Avoid Redundancy
Don't repeat the same information across multiple memory files. Use imports to reference shared content instead.

### Use Clear, Actionable Language
Write memories as clear instructions that Claude can follow:

- **Good**: "Always run `npm test` before committing changes"
- **Bad**: "Testing is important"

### Version Control Important Memories
Check project-level CLAUDE.md files into version control to ensure team consistency:

```bash
git add CLAUDE.md
git commit -m "Add project memory guidelines"
```

### Test Memory Effectiveness
Regularly test if Claude is following your memories correctly:

1. Ask Claude to perform tasks that should use your memories
2. Verify the output follows your guidelines
3. Update memories if Claude isn't following them correctly

## Memory Commands Reference

### `/memory` - Manage Memory Files
```bash
# List all memory files
/memory list

# Open a specific memory file
/memory open ~/.claude/CLAUDE.md

# Show loaded memories
/memory show

# Check memory status
/memory status
```

### `/memory init` - Initialize Project Memory
```bash
# Create a new CLAUDE.md with template
/memory init

# Create with specific template
/memory init --template python-webapp
```

### `/memory import` - Manage Imports
```bash
# Add an import to current memory
/memory import ./shared-standards.md

# Remove an import
/memory import --remove ./deprecated-rules.md

# List all imports
/memory import --list
```

### `/memory validate` - Check Memory Files
```bash
# Validate current memory files
/memory validate

# Check for conflicts
/memory validate --check-conflicts

# Validate imports
/memory validate --imports
```

## Memory File Format

### Basic Structure
```markdown
# Memory Title

## Category 1
- Specific instruction 1
- Specific instruction 2
- Specific instruction 3

## Category 2
- Another instruction 1
- Another instruction 2

@path/to/imported-file.md

## Project-Specific Content
[Content specific to this project]
```

### Advanced Features
```markdown
# Advanced Project Memory

## Import Standards
@../company/standards.md
@./team-guidelines.md
@~/.claude/personal-config.md

## Environment Configuration
- Use Node.js version 18.x
- Set NODE_ENV=development for local development
- Use .env files for environment variables
- Never commit .env files to version control

## Development Workflow
1. Create feature branch from main
2. Make changes following coding standards
3. Run tests and linting
4. Commit changes with descriptive messages
5. Push branch and create pull request
6. Address review feedback
7. Merge to main after approval

## Code Quality Standards
- Maintain 90%+ test coverage
- All code must pass ESLint rules
- Use Prettier for code formatting
- Write comprehensive documentation
- Follow semantic versioning

## Common Commands
```bash
# Development
npm run dev          # Start development server
npm run test         # Run all tests
npm run test:watch   # Run tests in watch mode

# Database
npm run db:migrate   # Run database migrations
npm run db:seed      # Seed database with test data
npm run db:reset     # Reset database to clean state

# Deployment
npm run build        # Build for production
npm run deploy:staging  # Deploy to staging
npm run deploy:prod     # Deploy to production
```
```

## Troubleshooting Memory Issues

### Memory Not Loading
1. Check file locations are correct
2. Verify file permissions
3. Use `/memory status` to see loaded files
4. Check for syntax errors in memory files

### Conflicting Memories
1. Use `/memory validate --check-conflicts`
2. Review memory hierarchy precedence
3. Remove or update conflicting entries
4. Use imports to share common content

### Performance Issues
1. Limit memory file size (keep under 100KB)
2. Use imports to split large files
3. Remove outdated or redundant memories
4. Use `/memory validate` to check for issues

## Integration with Other Features

### Subagents
Memory files are automatically available to subagents, ensuring consistent behavior across specialized AI assistants.

### MCP Servers
Memory configurations can reference MCP server settings and usage guidelines.

### Hooks
Memory files can define custom hook behaviors and automation rules.

### Settings
Memory files work alongside JSON settings to provide both structured configuration and natural language guidance.

## Migration from CLAUDE.local.md

The `CLAUDE.local.md` approach is deprecated in favor of imports. To migrate:

1. **Create import structure**:
   ```markdown
   # CLAUDE.md
   
   @~/.claude/personal-config.md
   @./team-guidelines.md
   
   ## Project Content
   [Existing project content]
   ```

2. **Move personal content** to `~/.claude/personal-config.md`

3. **Move shared content** to appropriate shared files

4. **Delete CLAUDE.local.md** after migration

## See Also

- [Terminal configuration](https://docs.anthropic.com/en/docs/claude-code/terminal-config) - Terminal setup and customization
- [Status line configuration](https://docs.anthropic.com/en/docs/claude-code/statusline) - Status line display options
- [Settings](https://docs.anthropic.com/en/docs/claude-code/settings) - JSON configuration options
- [Identity and Access Management](https://docs.anthropic.com/en/docs/claude-code/iam) - Permission and access control

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-sdk.md`:

```md
# Claude Code SDK Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/sdk*
*Download date: 2025-08-21*

---

## Overview

Build custom AI agents with the Claude Code SDK

## Why use the Claude Code SDK?

The Claude Code SDK provides all the building blocks you need to build production-ready agents:

- **Optimized Claude integration**: Automatic prompt caching and performance optimizations
- **Rich tool ecosystem**: File operations, code execution, web search, and MCP extensibility
- **Advanced permissions**: Fine-grained control over agent capabilities
- **Production essentials**: Built-in error handling, session management, and monitoring

## What can you build with the SDK?

Here are some example agent types you can create:

**Coding agents:**
- SRE agents that diagnose and fix production issues
- Security review bots that audit code for vulnerabilities
- Oncall engineering assistants that triage incidents
- Code review agents that enforce style and best practices

**Business agents:**
- Legal assistants that review contracts and compliance
- Finance advisors that analyze reports and forecasts
- Customer support agents that resolve technical issues
- Content creation assistants for marketing teams

The SDK is currently available in TypeScript and Python, with a command line interface (CLI) for quick prototyping.

## Quick start

Get your first agent running in under 5 minutes:

### 1. Install the SDK

**Command line:**
```bash
npm install -g @anthropic-ai/claude-code
```

**TypeScript:**
```bash
npm install -g @anthropic-ai/claude-code
```

**Python:**
```bash
pip install claude-code-sdk
npm install -g @anthropic-ai/claude-code  # Required dependency

# Optional for interactive development:
pip install ipython
```

### 2. Set your API key

Get your API key from the Anthropic Console and set the `ANTHROPIC_API_KEY` environment variable:

```bash
export ANTHROPIC_API_KEY="your-api-key-here"
```

### 3. Create your first agent

**Command line:**
```bash
# Create a simple legal assistant
claude -p "Review this contract clause for potential issues: 'The party agrees to unlimited liability...'" \
  --append-system-prompt "You are a legal assistant. Identify risks and suggest improvements."
```

**TypeScript:**
```typescript
// legal-agent.ts
import { query } from "@anthropic-ai/claude-code";

// Create a simple legal assistant
for await (const message of query({
  prompt: "Review this contract clause for potential issues: 'The party agrees to unlimited liability...'",
  options: {
    systemPrompt: "You are a legal assistant. Identify risks and suggest improvements.",
    maxTurns: 2
  }
})) {
  if (message.type === "result") {
    console.log(message.result);
  }
}
```

**Python:**
```python
# legal-agent.py
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def main():
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are a legal assistant. Identify risks and suggest improvements.",
            max_turns=2
        )
    ) as client:
        # Send the query
        await client.query(
            "Review this contract clause for potential issues: 'The party agrees to unlimited liability...'"
        )
        
        # Stream the response
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        print(block.text, end='', flush=True)

if __name__ == "__main__":
    asyncio.run(main())
```

### 4. Run the agent

**Command line:**
Copy and paste the command above directly into your terminal.

**TypeScript:**
1. Set up project:
```bash
npm init -y
npm install @anthropic-ai/claude-code tsx
```

2. Add `"type": "module"` to your package.json

3. Save the code above as `legal-agent.ts`, then run:
```bash
npx tsx legal-agent.ts
```

**Python:**
Save the code above as `legal-agent.py`, then run:
```bash
python legal-agent.py
```

For IPython/Jupyter notebooks, you can run the code directly in a cell:
```python
await main()
```

Each example above creates a working agent that will:
- Analyze the prompt using Claude's reasoning capabilities
- Plan a multi-step approach to solve the problem
- Execute actions using tools like file operations, bash commands, and web search
- Provide actionable recommendations based on the analysis

## Core usage

### Overview

The Claude Code SDK allows you to interface with Claude Code in non-interactive mode from your applications.

**Command line:**

**Prerequisites:**
- Node.js 18+
- `@anthropic-ai/claude-code` from NPM

**Basic usage:**
The primary command-line interface to Claude Code is the `claude` command. Use the `--print` (or `-p`) flag to run in non-interactive mode and print the final result:

```bash
claude -p "Analyze system performance" \
  --append-system-prompt "You are a performance engineer" \
  --allowedTools "Bash,Read,WebSearch" \
  --permission-mode acceptEdits \
  --cwd /path/to/project
```

**Configuration:**
The SDK leverages all the CLI options available in Claude Code. Here are the key ones for SDK usage:

| Flag | Description | Example |
|------|-------------|---------|
| `--print`, `-p` | Run in non-interactive mode | `claude -p "query"` |
| `--output-format` | Specify output format (`text`, `json`, `stream-json`) | `claude -p --output-format json` |
| `--resume`, `-r` | Resume a conversation by session ID | `claude --resume abc123` |
| `--continue`, `-c` | Continue the most recent conversation | `claude --continue` |
| `--verbose` | Enable verbose logging | `claude --verbose` |
| `--append-system-prompt` | Append to system prompt (only with `--print`) | `claude --append-system-prompt "Custom instruction"` |
| `--allowedTools` | Space-separated list of allowed tools, or string of comma-separated list of allowed tools | `claude --allowedTools mcp__slack mcp__filesystem` `claude --allowedTools "Bash(npm install),mcp__filesystem"` |
| `--disallowedTools` | Space-separated list of denied tools, or string of comma-separated list of denied tools | `claude --disallowedTools mcp__splunk mcp__github` `claude --disallowedTools "Bash(git commit),mcp__github"` |
| `--mcp-config` | Load MCP servers from a JSON file | `claude --mcp-config servers.json` |
| `--permission-prompt-tool` | MCP tool for handling permission prompts (only with `--print`) | `claude --permission-prompt-tool mcp__auth__prompt` |

For a complete list of CLI options and features, see the CLI reference documentation.

**TypeScript:**

**Prerequisites:**
- Node.js 18+
- `@anthropic-ai/claude-code` from NPM

**Basic usage:**
The primary interface via the TypeScript SDK is the `query` function, which returns an async iterator that streams messages as they arrive:

```typescript
import { query } from "@anthropic-ai/claude-code";

for await (const message of query({
  prompt: "Analyze system performance",
  abortController: new AbortController(),
  options: {
    maxTurns: 5,
    systemPrompt: "You are a performance engineer",
    allowedTools: ["Bash", "Read", "WebSearch"]
  }
})) {
  if (message.type === "result") {
    console.log(message.result);
  }
}
```

**Configuration:**
The TypeScript SDK accepts all arguments supported by the command line, as well as the following additional options:

| Argument | Description | Default |
|----------|-------------|---------|
| `abortController` | Abort controller | `new AbortController()` |
| `cwd` | Current working directory | `process.cwd()` |
| `executable` | Which JavaScript runtime to use | `node` when running with Node.js, `bun` when running with Bun |
| `executableArgs` | Arguments to pass to the executable | `[]` |
| `pathToClaudeCodeExecutable` | Path to the Claude Code executable | Executable that ships with `@anthropic-ai/claude-code` |
| `permissionMode` | Permission mode for the session | `"default"` (options: `"default"`, `"acceptEdits"`, `"plan"`, `"bypassPermissions"`) |

**Python:**

**Prerequisites:**
- Python 3.10+
- `claude-code-sdk` from PyPI
- Node.js 18+
- `@anthropic-ai/claude-code` from NPM

For interactive development, use IPython: `pip install ipython`

**Basic usage:**
The Python SDK provides two primary interfaces:

1. **The `ClaudeSDKClient` class (Recommended)**
   Best for streaming responses, multi-turn conversations, and interactive applications:

```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def main():
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are a performance engineer",
            allowed_tools=["Bash", "Read", "WebSearch"],
            max_turns=5
        )
    ) as client:
        await client.query("Analyze system performance")
        
        # Stream responses
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        print(block.text, end='', flush=True)

# Run as script
asyncio.run(main())

# Or in IPython/Jupyter: await main()
```

The SDK also supports passing structured messages and image inputs:

```python
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async with ClaudeSDKClient() as client:
    # Text message
    await client.query("Analyze this code for security issues")
    
    # Message with image reference (image will be read by Claude's Read tool)
    await client.query("Explain what's shown in screenshot.png")
    
    # Multiple messages in sequence
    messages = [
        "First, analyze the architecture diagram in diagram.png",
        "Now suggest improvements based on the diagram",
        "Finally, generate implementation code"
    ]
    
    for msg in messages:
        await client.query(msg)
        async for response in client.receive_response():
            # Process each response
            pass

# The SDK handles image files through Claude's built-in Read tool
# Supported formats: PNG, JPG, PDF, and other common formats
```

The Python examples on this page use `asyncio`, but you can also use `anyio`.

2. **The `query` function**
   For simple, one-shot queries:

```python
from claude_code_sdk import query, ClaudeCodeOptions

async for message in query(
    prompt="Analyze system performance",
    options=ClaudeCodeOptions(system_prompt="You are a performance engineer")
):
    if type(message).__name__ == "ResultMessage":
        print(message.result)
```

**Configuration:**
As the Python SDK accepts all arguments supported by the command line through the `ClaudeCodeOptions` class.

## Authentication

### Anthropic API key

For basic authentication, retrieve an Anthropic API key from the Anthropic Console and set the `ANTHROPIC_API_KEY` environment variable, as demonstrated in the Quick start.

### Third-party API credentials

The SDK also supports authentication via third-party API providers:

- **Amazon Bedrock**: Set `CLAUDE_CODE_USE_BEDROCK=1` environment variable and configure AWS credentials
- **Google Vertex AI**: Set `CLAUDE_CODE_USE_VERTEX=1` environment variable and configure Google Cloud credentials

For detailed configuration instructions for third-party providers, see the Amazon Bedrock and Google Vertex AI documentation.

## Multi-turn conversations

For multi-turn conversations, you can resume conversations or continue from the most recent session:

**Command line:**
```bash
# Continue the most recent conversation
claude --continue "Now refactor this for better performance"

# Resume a specific conversation by session ID
claude --resume 550e8400-e29b-41d4-a716-446655440000 "Update the tests"

# Resume in non-interactive mode
claude --resume 550e8400-e29b-41d4-a716-446655440000 "Fix all linting issues" --no-interactive
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

// Continue most recent conversation
for await (const message of query({
  prompt: "Now refactor this for better performance",
  options: { continueSession: true }
})) {
  if (message.type === "result") console.log(message.result);
}

// Resume specific session
for await (const message of query({
  prompt: "Update the tests",
  options: { 
    resumeSessionId: "550e8400-e29b-41d4-a716-446655440000",
    maxTurns: 3
  }
})) {
  if (message.type === "result") console.log(message.result);
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions, query

# Method 1: Using ClaudeSDKClient for persistent conversations
async def multi_turn_conversation():
    async with ClaudeSDKClient() as client:
        # First query
        await client.query("Let's refactor the payment module")
        async for msg in client.receive_response():
            # Process first response
            pass
        
        # Continue in same session
        await client.query("Now add comprehensive error handling")
        async for msg in client.receive_response():
            # Process continuation
            pass
        
        # The conversation context is maintained throughout

# Method 2: Using query function with session management
async def resume_session():
    # Continue most recent conversation
    async for message in query(
        prompt="Now refactor this for better performance",
        options=ClaudeCodeOptions(continue_conversation=True)
    ):
        if type(message).__name__ == "ResultMessage":
            print(message.result)

    # Resume specific session
    async for message in query(
        prompt="Update the tests", 
        options=ClaudeCodeOptions(
            resume="550e8400-e29b-41d4-a716-446655440000",
            max_turns=3
        )
    ):
        if type(message).__name__ == "ResultMessage":
            print(message.result)

# Run the examples
asyncio.run(multi_turn_conversation())
```

## Using Plan Mode

Plan Mode allows Claude to analyze code without making modifications, useful for code reviews and planning changes.

**Command line:**
```bash
claude -p "Review this code" --permission-mode plan
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

for await (const message of query({
  prompt: "Your prompt here",
  options: {
    permissionMode: 'plan'
  }
})) {
  if (message.type === "result") {
    console.log(message.result);
  }
}
```

**Python:**
```python
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async with ClaudeSDKClient(
    options=ClaudeCodeOptions(permission_mode='plan')
) as client:
    await client.query("Your prompt here")
```

Plan Mode restricts editing, file creation, and command execution. See permission modes for details.

## Custom system prompts

System prompts define your agent's role, expertise, and behavior. This is where you specify what kind of agent you're building:

**Command line:**
```bash
# SRE incident response agent
claude -p "API is down, investigate" \
  --append-system-prompt "You are an SRE expert. Diagnose issues systematically and provide actionable solutions."

# Legal document review agent  
claude -p "Review this contract" \
  --append-system-prompt "You are a corporate lawyer. Identify risks, suggest improvements, and ensure compliance."

# Append to default system prompt
claude -p "Refactor this function" \
  --append-system-prompt "Always include comprehensive error handling and unit tests."
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

// SRE incident response agent
for await (const message of query({
  prompt: "API is down, investigate",
  options: {
    systemPrompt: "You are an SRE expert. Diagnose issues systematically and provide actionable solutions.",
    maxTurns: 3
  }
})) {
  if (message.type === "result") console.log(message.result);
}

// Append to default system prompt
for await (const message of query({
  prompt: "Refactor this function",
  options: {
    appendSystemPrompt: "Always include comprehensive error handling and unit tests.",
    maxTurns: 2
  }
})) {
  if (message.type === "result") console.log(message.result);
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def specialized_agents():
    # SRE incident response agent with streaming
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are an SRE expert. Diagnose issues systematically and provide actionable solutions.",
            max_turns=3
        )
    ) as sre_agent:
        await sre_agent.query("API is down, investigate")
        
        # Stream the diagnostic process
        async for message in sre_agent.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        print(block.text, end='', flush=True)
    
    # Legal review agent with custom prompt
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            append_system_prompt="Always include comprehensive error handling and unit tests.",
            max_turns=2
        )
    ) as dev_agent:
        await dev_agent.query("Refactor this function")
        
        # Collect full response
        full_response = []
        async for message in dev_agent.receive_response():
            if type(message).__name__ == "ResultMessage":
                print(message.result)

asyncio.run(specialized_agents())
```

## Advanced Usage

### Custom tools via MCP

The Model Context Protocol (MCP) lets you give your agents custom tools and capabilities. This is crucial for building specialized agents that need domain-specific integrations.

**Example agent tool configurations:**
```json
{
  "mcpServers": {
    "slack": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-slack"],
      "env": {"SLACK_TOKEN": "your-slack-token"}
    },
    "jira": {
      "command": "npx", 
      "args": ["-y", "@modelcontextprotocol/server-jira"],
      "env": {"JIRA_TOKEN": "your-jira-token"}
    },
    "database": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {"DB_CONNECTION_STRING": "your-db-url"}
    }
  }
}
```

**Usage examples:**

**Command line:**
```bash
# SRE agent with monitoring tools
claude -p "Investigate the payment service outage" \
  --mcp-config sre-tools.json \
  --allowedTools "mcp__datadog,mcp__pagerduty,mcp__kubernetes" \
  --append-system-prompt "You are an SRE. Use monitoring data to diagnose issues."

# Customer support agent with CRM access
claude -p "Help resolve customer ticket #12345" \
  --mcp-config support-tools.json \
  --allowedTools "mcp__zendesk,mcp__stripe,mcp__user_db" \
  --append-system-prompt "You are a technical support specialist."
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

// SRE agent with monitoring tools
for await (const message of query({
  prompt: "Investigate the payment service outage",
  options: {
    mcpConfig: "sre-tools.json",
    allowedTools: ["mcp__datadog", "mcp__pagerduty", "mcp__kubernetes"],
    systemPrompt: "You are an SRE. Use monitoring data to diagnose issues.",
    maxTurns: 4
  }
})) {
  if (message.type === "result") console.log(message.result);
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def mcp_enabled_agent():
    # Legal agent with document access and streaming
    # Note: Configure your MCP servers as needed
    mcp_servers = {
        # Example configuration - uncomment and configure as needed:
        # "docusign": {
        #     "command": "npx",
        #     "args": ["-y", "@modelcontextprotocol/server-docusign"],
        #     "env": {"API_KEY": "your-key"}
        # }
    }
    
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            mcp_servers=mcp_servers,
            allowed_tools=["mcp__docusign", "mcp__compliance_db"],
            system_prompt="You are a corporate lawyer specializing in contract review.",
            max_turns=4
        )
    ) as client:
        await client.query("Review this contract for compliance risks")
        
        # Monitor tool usage and responses
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'type'):
                        if block.type == 'tool_use':
                            print(f"\n[Using tool: {block.name}]\n")
                        elif hasattr(block, 'text'):
                            print(block.text, end='', flush=True)
                    elif hasattr(block, 'text'):
                        print(block.text, end='', flush=True)
            
            if type(message).__name__ == "ResultMessage":
                print(f"\n\nReview complete. Total cost: ${message.total_cost_usd:.4f}")

asyncio.run(mcp_enabled_agent())
```

When using MCP tools, you must explicitly allow them using the `--allowedTools` flag. MCP tool names follow the pattern `mcp__<serverName>__<toolName>` where:

- `serverName` is the key from your MCP configuration file
- `toolName` is the specific tool provided by that server

This security measure ensures that MCP tools are only used when explicitly permitted.

If you specify just the server name (i.e., `mcp__<serverName>`), all tools from that server will be allowed.

Glob patterns (e.g., `mcp__go*`) are not supported.

### Custom permission prompt tool

Optionally, use `--permission-prompt-tool` to pass in an MCP tool that we will use to check whether or not the user grants the model permissions to invoke a given tool. When the model invokes a tool the following happens:

1. We first check permission settings: all settings.json files, as well as `--allowedTools` and `--disallowedTools` passed into the SDK; if one of these allows or denies the tool call, we proceed with the tool call
2. Otherwise, we invoke the MCP tool you provided in `--permission-prompt-tool`

The `--permission-prompt-tool` MCP tool is passed the tool name and input, and must return a JSON-stringified payload with the result. The payload must be one of:

```typescript
// tool call is allowed
{
  "behavior": "allow",
  "updatedInput": {...}, // updated input, or just return back the original input
}

// tool call is denied
{
  "behavior": "deny",
  "message": "..." // human-readable string explaining why the permission was denied
}
```

**Implementation examples:**

**Command line:**
```bash
# Use with your MCP server configuration
claude -p "Analyze and fix the security issues" \
  --permission-prompt-tool mcp__security__approval_prompt \
  --mcp-config security-tools.json \
  --allowedTools "Read,Grep" \
  --disallowedTools "Bash(rm*),Write"

# With custom permission rules
claude -p "Refactor the codebase" \
  --permission-prompt-tool mcp__custom__permission_check \
  --mcp-config custom-config.json \
  --output-format json
```

**TypeScript:**
```typescript
const server = new McpServer({
  name: "Test permission prompt MCP Server",
  version: "0.0.1",
});

server.tool(
  "approval_prompt",
  'Simulate a permission check - approve if the input contains "allow", otherwise deny',
  {
    tool_name: z.string().describe("The name of the tool requesting permission"),
    input: z.object({}).passthrough().describe("The input for the tool"),
    tool_use_id: z.string().optional().describe("The unique tool use request ID"),
  },
  async ({ tool_name, input }) => {
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            JSON.stringify(input).includes("allow")
              ? {
                  behavior: "allow",
                  updatedInput: input,
                }
              : {
                  behavior: "deny",
                  message: "Permission denied by test approval_prompt tool",
                }
          ),
        },
      ],
    };
  }
);

// Use in SDK
import { query } from "@anthropic-ai/claude-code";

for await (const message of query({
  prompt: "Analyze the codebase",
  options: {
    permissionPromptTool: "mcp__test-server__approval_prompt",
    mcpConfig: "my-config.json",
    allowedTools: ["Read", "Grep"]
  }
})) {
  if (message.type === "result") console.log(message.result);
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def use_permission_prompt():
    """Example using custom permission prompt tool"""
    
    # MCP server configuration
    mcp_servers = {
        # Example configuration - uncomment and configure as needed:
        # "security": {
        #     "command": "npx",
        #     "args": ["-y", "@modelcontextprotocol/server-security"],
        #     "env": {"API_KEY": "your-key"}
        # }
    }
    
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            permission_prompt_tool_name="mcp__security__approval_prompt",  # Changed from permission_prompt_tool
            mcp_servers=mcp_servers,
            allowed_tools=["Read", "Grep"],
            disallowed_tools=["Bash(rm*)", "Write"],
            system_prompt="You are a security auditor"
        )
    ) as client:
        await client.query("Analyze and fix the security issues")
        
        # Monitor tool usage and permissions
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'type'):  # Added check for 'type' attribute
                        if block.type == 'tool_use':
                            print(f"[Tool: {block.name}] ", end='')
                    if hasattr(block, 'text'):
                        print(block.text, end='', flush=True)
            
            # Check for permission denials in error messages
            if type(message).__name__ == "ErrorMessage":
                if hasattr(message, 'error') and "Permission denied" in str(message.error):
                    print(f"\nâš ï¸ Permission denied: {message.error}")

# Example MCP server implementation (Python)
# This would be in your MCP server code
async def approval_prompt(tool_name: str, input: dict, tool_use_id: str = None):
    """Custom permission prompt handler"""
    # Your custom logic here
    if "allow" in str(input):
        return json.dumps({
            "behavior": "allow",
            "updatedInput": input
        })
    else:
        return json.dumps({
            "behavior": "deny",
            "message": f"Permission denied for {tool_name}"
        })

asyncio.run(use_permission_prompt())
```

Usage notes:
- Use `updatedInput` to tell the model that the permission prompt mutated its input; otherwise, set `updatedInput` to the original input, as in the example above. For example, if the tool shows a file edit diff to the user and lets them edit the diff manually, the permission prompt tool should return that updated edit.
- The payload must be JSON-stringified

## Output formats

The SDK supports multiple output formats:

### Text output (default)

**Command line:**
```bash
claude -p "Explain file src/components/Header.tsx"
# Output: This is a React component showing...
```

**TypeScript:**
```typescript
// Default text output
for await (const message of query({
  prompt: "Explain file src/components/Header.tsx"
})) {
  if (message.type === "result") {
    console.log(message.result);
    // Output: This is a React component showing...
  }
}
```

**Python:**
```python
# Default text output with streaming
async with ClaudeSDKClient() as client:
    await client.query("Explain file src/components/Header.tsx")
    
    # Stream text as it arrives
    async for message in client.receive_response():
        if hasattr(message, 'content'):
            for block in message.content:
                if hasattr(block, 'text'):
                    print(block.text, end='', flush=True)
                    # Output streams in real-time: This is a React component showing...
```

### JSON output

Returns structured data including metadata:

**Command line:**
```bash
claude -p "How does the data layer work?" --output-format json
```

**TypeScript:**
```typescript
// Collect all messages for JSON-like access
const messages = [];
for await (const message of query({
  prompt: "How does the data layer work?"
})) {
  messages.push(message);
}

// Access result message with metadata
const result = messages.find(m => m.type === "result");
console.log({
  result: result.result,
  cost: result.total_cost_usd,
  duration: result.duration_ms
});
```

**Python:**
```python
# Collect all messages with metadata
async with ClaudeSDKClient() as client:
    await client.query("How does the data layer work?")
    
    messages = []
    result_data = None
    
    async for message in client.receive_messages():
        messages.append(message)
        
        # Capture result message with metadata
        if type(message).__name__ == "ResultMessage":
            result_data = {
                "result": message.result,
                "cost": message.total_cost_usd,
                "duration": message.duration_ms,
                "num_turns": message.num_turns,
                "session_id": message.session_id
            }
            break
    
    print(result_data)
```

Response format:
```json
{
  "type": "result",
  "subtype": "success",
  "total_cost_usd": 0.003,
  "is_error": false,
  "duration_ms": 1234,
  "duration_api_ms": 800,
  "num_turns": 6,
  "result": "The response text here...",
  "session_id": "abc123"
}
```

### Streaming JSON output

Streams each message as it is received:

**Command line:**
```bash
$ claude -p "Build an application" --output-format stream-json
```

Each conversation begins with an initial `init` system message, followed by a list of user and assistant messages, followed by a final `result` system message with stats. Each message is emitted as a separate JSON object.

## Message schema

Messages returned from the JSON API are strictly typed according to the following schema:

```typescript
type SDKMessage =
  // An assistant message
  | {
      type: "assistant";
      message: Message; // from Anthropic SDK
      session_id: string;
    }

  // A user message
  | {
      type: "user";
      message: MessageParam; // from Anthropic SDK
      session_id: string;
    }

  // Emitted as the last message
  | {
      type: "result";
      subtype: "success";
      duration_ms: float;
      duration_api_ms: float;
      is_error: boolean;
      num_turns: int;
      result: string;
      session_id: string;
      total_cost_usd: float;
    }

  // Emitted as the last message, when we've reached the maximum number of turns
  | {
      type: "result";
      subtype: "error_max_turns" | "error_during_execution";
      duration_ms: float;
      duration_api_ms: float;
      is_error: boolean;
      num_turns: int;
      session_id: string;
      total_cost_usd: float;
    }

  // Emitted as the first message at the start of a conversation
  | {
      type: "system";
      subtype: "init";
      apiKeySource: string;
      cwd: string;
      session_id: string;
      tools: string[];
      mcp_servers: {
        name: string;
        status: string;
      }[];
      model: string;
      permissionMode: "default" | "acceptEdits" | "bypassPermissions" | "plan";
    };
```

We will soon publish these types in a JSONSchema-compatible format. We use semantic versioning for the main Claude Code package to communicate breaking changes to this format.

`Message` and `MessageParam` types are available in Anthropic SDKs. For example, see the Anthropic TypeScript and Python SDKs.

## Input formats

The SDK supports multiple input formats:

### Text input (default)

**Command line:**
```bash
# Direct argument
claude -p "Explain this code"

# From stdin
echo "Explain this code" | claude -p
```

**TypeScript:**
```typescript
// Direct prompt
for await (const message of query({
  prompt: "Explain this code"
})) {
  if (message.type === "result") console.log(message.result);
}

// From variable
const userInput = "Explain this code";
for await (const message of query({ prompt: userInput })) {
  if (message.type === "result") console.log(message.result);
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient

async def process_inputs():
    async with ClaudeSDKClient() as client:
        # Text input
        await client.query("Explain this code")
        async for message in client.receive_response():
            # Process streaming response
            pass
        
        # Image input (Claude will use Read tool automatically)
        await client.query("What's in this diagram? screenshot.png")
        async for message in client.receive_response():
            # Process image analysis
            pass
        
        # Multiple inputs with mixed content
        inputs = [
            "Analyze the architecture in diagram.png",
            "Compare it with best practices",
            "Generate improved version"
        ]
        
        for prompt in inputs:
            await client.query(prompt)
            async for message in client.receive_response():
                # Process each response
                pass

asyncio.run(process_inputs())
```

### Streaming JSON input

A stream of messages provided via `stdin` where each message represents a user turn. This allows multiple turns of a conversation without re-launching the `claude` binary and allows providing guidance to the model while it is processing a request.

Each message is a JSON 'User message' object, following the same format as the output message schema. Messages are formatted using the jsonl format where each line of input is a complete JSON object. Streaming JSON input requires `-p` and `--output-format stream-json`.

Currently this is limited to text-only user messages.

```bash
$ echo '{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Explain this code"}]}}' | claude -p --output-format=stream-json --input-format=stream-json --verbose
```

## Agent integration examples

### SRE incident response bot

**Command line:**
```bash
#!/bin/bash

# Automated incident response agent
investigate_incident() {
    local incident_description="$1"
    local severity="${2:-medium}"
    
    claude -p "Incident: $incident_description (Severity: $severity)" \
      --append-system-prompt "You are an SRE expert. Diagnose the issue, assess impact, and provide immediate action items." \
      --output-format json \
      --allowedTools "Bash,Read,WebSearch,mcp__datadog" \
      --mcp-config monitoring-tools.json
}

# Usage
investigate_incident "Payment API returning 500 errors" "high"
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

// Automated incident response agent
async function investigateIncident(
  incidentDescription: string, 
  severity = "medium"
) {
  const messages = [];
  
  for await (const message of query({
    prompt: `Incident: ${incidentDescription} (Severity: ${severity})`,
    options: {
      systemPrompt: "You are an SRE expert. Diagnose the issue, assess impact, and provide immediate action items.",
      maxTurns: 6,
      allowedTools: ["Bash", "Read", "WebSearch", "mcp__datadog"],
      mcpConfig: "monitoring-tools.json"
    }
  })) {
    messages.push(message);
  }
  
  return messages.find(m => m.type === "result");
}

// Usage
const result = await investigateIncident("Payment API returning 500 errors", "high");
console.log(result.result);
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def investigate_incident(incident_description: str, severity: str = "medium"):
    """Automated incident response agent with real-time streaming"""
    
    # MCP server configuration for monitoring tools
    mcp_servers = {
        # Example configuration - uncomment and configure as needed:
        # "datadog": {
        #     "command": "npx",
        #     "args": ["-y", "@modelcontextprotocol/server-datadog"],
        #     "env": {"API_KEY": "your-datadog-key", "APP_KEY": "your-app-key"}
        # }
    }
    
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are an SRE expert. Diagnose the issue, assess impact, and provide immediate action items.",
            max_turns=6,
            allowed_tools=["Bash", "Read", "WebSearch", "mcp__datadog"],
            mcp_servers=mcp_servers
        )
    ) as client:
        # Send the incident details
        prompt = f"Incident: {incident_description} (Severity: {severity})"
        print(f"ğŸš¨ Investigating: {prompt}\n")
        await client.query(prompt)
        
        # Stream the investigation process
        investigation_log = []
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'type'):
                        if block.type == 'tool_use':
                            print(f"[{block.name}] ", end='')
                    if hasattr(block, 'text'):
                        text = block.text
                        print(text, end='', flush=True)
                        investigation_log.append(text)
            
            # Capture final result
            if type(message).__name__ == "ResultMessage":
                return {
                    'analysis': ''.join(investigation_log),
                    'cost': message.total_cost_usd,
                    'duration_ms': message.duration_ms
                }

# Usage
result = await investigate_incident("Payment API returning 500 errors", "high")
print(f"\n\nInvestigation complete. Cost: ${result['cost']:.4f}")
```

### Automated security review

**Command line:**
```bash
# Security audit agent for pull requests
audit_pr() {
    local pr_number="$1"
    
    gh pr diff "$pr_number" | claude -p \
      --append-system-prompt "You are a security engineer. Review this PR for vulnerabilities, insecure patterns, and compliance issues." \
      --output-format json \
      --allowedTools "Read,Grep,WebSearch"
}

# Usage and save to file
audit_pr 123 > security-report.json
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";
import { execSync } from "child_process";

async function auditPR(prNumber: number) {
  // Get PR diff
  const prDiff = execSync(`gh pr diff ${prNumber}`, { encoding: 'utf8' });
  
  const messages = [];
  for await (const message of query({
    prompt: prDiff,
    options: {
      systemPrompt: "You are a security engineer. Review this PR for vulnerabilities, insecure patterns, and compliance issues.",
      maxTurns: 3,
      allowedTools: ["Read", "Grep", "WebSearch"]
    }
  })) {
    messages.push(message);
  }
  
  return messages.find(m => m.type === "result");
}

// Usage
const report = await auditPR(123);
console.log(JSON.stringify(report, null, 2));
```

**Python:**
```python
import subprocess
import asyncio
import json
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def audit_pr(pr_number: int):
    """Security audit agent for pull requests with streaming feedback"""
    # Get PR diff
    pr_diff = subprocess.check_output(
        ["gh", "pr", "diff", str(pr_number)], 
        text=True
    )
    
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are a security engineer. Review this PR for vulnerabilities, insecure patterns, and compliance issues.",
            max_turns=3,
            allowed_tools=["Read", "Grep", "WebSearch"]
        )
    ) as client:
        print(f"ğŸ” Auditing PR #{pr_number}\n")
        await client.query(pr_diff)
        
        findings = []
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        # Stream findings as they're discovered
                        print(block.text, end='', flush=True)
                        findings.append(block.text)
            
            if type(message).__name__ == "ResultMessage":
                return {
                    'pr_number': pr_number,
                    'findings': ''.join(findings),
                    'metadata': {
                        'cost': message.total_cost_usd,
                        'duration': message.duration_ms,
                        'severity': 'high' if 'vulnerability' in ''.join(findings).lower() else 'medium'
                    }
                }

# Usage
report = await audit_pr(123)
print(f"\n\nAudit complete. Severity: {report['metadata']['severity']}")
print(json.dumps(report, indent=2))
```

### Multi-turn legal assistant

**Command line:**
```bash
# Legal document review with session persistence
session_id=$(claude -p "Start legal review session" --output-format json | jq -r '.session_id')

# Review contract in multiple steps
claude -p --resume "$session_id" "Review contract.pdf for liability clauses"
claude -p --resume "$session_id" "Check compliance with GDPR requirements" 
claude -p --resume "$session_id" "Generate executive summary of risks"
```

**TypeScript:**
```typescript
import { query } from "@anthropic-ai/claude-code";

async function legalReview() {
  // Start legal review session
  let sessionId: string;
  
  for await (const message of query({
    prompt: "Start legal review session",
    options: { maxTurns: 1 }
  })) {
    if (message.type === "system" && message.subtype === "init") {
      sessionId = message.session_id;
    }
  }
  
  // Multi-step review using same session
  const steps = [
    "Review contract.pdf for liability clauses",
    "Check compliance with GDPR requirements",
    "Generate executive summary of risks"
  ];
  
  for (const step of steps) {
    for await (const message of query({
      prompt: step,
      options: { resumeSessionId: sessionId, maxTurns: 2 }
    })) {
      if (message.type === "result") {
        console.log(`Step: ${step}`);
        console.log(message.result);
      }
    }
  }
}
```

**Python:**
```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

async def legal_review():
    """Legal document review with persistent session and streaming"""
    
    async with ClaudeSDKClient(
        options=ClaudeCodeOptions(
            system_prompt="You are a corporate lawyer. Provide detailed legal analysis.",
            max_turns=2
        )
    ) as client:
        # Multi-step review in same session
        steps = [
            "Review contract.pdf for liability clauses",
            "Check compliance with GDPR requirements", 
            "Generate executive summary of risks"
        ]
        
        review_results = []
        
        for step in steps:
            print(f"\nğŸ“‹ {step}\n")
            await client.query(step)
            
            step_result = []
            async for message in client.receive_response():
                if hasattr(message, 'content'):
                    for block in message.content:
                        if hasattr(block, 'text'):
                            text = block.text
                            print(text, end='', flush=True)
                            step_result.append(text)
                
                if type(message).__name__ == "ResultMessage":
                    review_results.append({
                        'step': step,
                        'analysis': ''.join(step_result),
                        'cost': message.total_cost_usd
                    })
        
        # Summary
        total_cost = sum(r['cost'] for r in review_results)
        print(f"\n\nâœ… Legal review complete. Total cost: ${total_cost:.4f}")
        return review_results

# Usage
results = await legal_review()
```

## Python-Specific Best Practices

### Key Patterns

```python
import asyncio
from claude_code_sdk import ClaudeSDKClient, ClaudeCodeOptions

# Always use context managers
async with ClaudeSDKClient() as client:
    await client.query("Analyze this code")
    async for msg in client.receive_response():
        # Process streaming messages
        pass

# Run multiple agents concurrently
async with ClaudeSDKClient() as reviewer, ClaudeSDKClient() as tester:
    await asyncio.gather(
        reviewer.query("Review main.py"),
        tester.query("Write tests for main.py")
    )

# Error handling
from claude_code_sdk import CLINotFoundError, ProcessError

try:
    async with ClaudeSDKClient() as client:
        # Your code here
        pass
except CLINotFoundError:
    print("Install CLI: npm install -g @anthropic-ai/claude-code")
except ProcessError as e:
    print(f"Process error: {e}")

# Collect full response with metadata
async def get_response(client, prompt):
    await client.query(prompt)
    text = []
    async for msg in client.receive_response():
        if hasattr(msg, 'content'):
            for block in msg.content:
                if hasattr(block, 'text'):
                    text.append(block.text)
        if type(msg).__name__ == "ResultMessage":
            return {'text': ''.join(text), 'cost': msg.total_cost_usd}
```

### IPython/Jupyter Tips

```python
# In Jupyter, use await directly in cells
client = ClaudeSDKClient()
await client.connect()
await client.query("Analyze data.csv")
async for msg in client.receive_response():
    print(msg)
await client.disconnect()

# Create reusable helper functions
async def stream_print(client, prompt):
    await client.query(prompt)
    async for msg in client.receive_response():
        if hasattr(msg, 'content'):
            for block in msg.content:
                if hasattr(block, 'text'):
                    print(block.text, end='', flush=True)
```

## Best practices

- **Use JSON output format** for programmatic parsing of responses:

```bash
# Parse JSON response with jq
result=$(claude -p "Generate code" --output-format json)
code=$(echo "$result" | jq -r '.result')
cost=$(echo "$result" | jq -r '.cost_usd')
```

- **Handle errors gracefully** - check exit codes and stderr:

```bash
if ! claude -p "$prompt" 2>error.log; then
    echo "Error occurred:" >&2
    cat error.log >&2
    exit 1
fi
```

- **Use session management** for maintaining context in multi-turn conversations

- **Consider timeouts** for long-running operations:

```bash
timeout 300 claude -p "$complex_prompt" || echo "Timed out after 5 minutes"
```

- **Respect rate limits** when making multiple requests by adding delays between calls

## Related resources

- [CLI usage and controls](https://docs.anthropic.com/en/docs/claude-code/cli-reference) - Complete CLI documentation
- [GitHub Actions integration](https://docs.anthropic.com/en/docs/claude-code/github-actions) - Automate your GitHub workflow with Claude
- [Common workflows](https://docs.anthropic.com/en/docs/claude-code/common-workflows) - Step-by-step guides for common use cases

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-settings.md`:

```md
# Claude Code Settings Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/settings*
*Download date: 2025-08-21*

---

## Overview

Claude Code offers a variety of settings to configure its behavior to meet your needs. You can configure Claude Code by running the `/config` command when using the interactive REPL.

## Settings files

The `settings.json` file is our official mechanism for configuring Claude Code through hierarchical settings:

- **User settings** are defined in `~/.claude/settings.json` and apply to all projects.
- **Project settings** are saved in your project directory:
  - `.claude/settings.json` for settings that are checked into source control and shared with your team
  - `.claude/settings.local.json` for settings that are not checked in, useful for personal preferences and experimentation. Claude Code will configure git to ignore `.claude/settings.local.json` when it is created.
- **For enterprise deployments of Claude Code**, we also support **enterprise managed policy settings**. These take precedence over user and project settings. System administrators can deploy policies to:
  - macOS: `/Library/Application Support/ClaudeCode/managed-settings.json`
  - Linux and WSL: `/etc/claude-code/managed-settings.json`
  - Windows: `C:\ProgramData\ClaudeCode\managed-settings.json`

### Example settings.json

```json
{
  "model": "claude-3-5-sonnet-20241022",
  "permissions": {
    "allow": ["Bash(git diff:*)", "Read(**/*)"],
    "ask": ["Bash(git push:*)"],
    "deny": ["WebFetch", "Read(./.env)", "Read(./secrets/**)"]
  },
  "env": {
    "NODE_ENV": "development"
  },
  "hooks": {
    "PostToolUse": {
      "Write": "npx prettier --write $CLAUDE_HOOK_TOOL_OUTPUT"
    }
  },
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh"
  },
  "enableAllProjectMcpServers": true,
  "cleanupPeriodDays": 30
}
```

## Available settings

`settings.json` supports a number of options:

| Key | Description | Example |
|------|-------------|---------|
| `apiKeyHelper` | Custom script, to be executed in `/bin/sh`, to generate an auth value. This value will be sent as `X-Api-Key` and `Authorization: Bearer` headers for model requests | `/bin/generate_temp_api_key.sh` |
| `cleanupPeriodDays` | How long to locally retain chat transcripts based on last activity date (default: 30 days) | `20` |
| `env` | Environment variables that will be applied to every session | `{"FOO": "bar"}` |
| `includeCoAuthoredBy` | Whether to include the `co-authored-by Claude` byline in git commits and pull requests (default: `true`) | `false` |
| `permissions` | See table below for structure of permissions. | |
| `hooks` | Configure custom commands to run before or after tool executions. See [hooks documentation](https://docs.anthropic.com/en/docs/claude-code/hooks-guide) | `{"PreToolUse": {"Bash": "echo 'Running command...'"}}` |
| `model` | Override the default model to use for Claude Code | `"claude-3-5-sonnet-20241022"` |
| `statusLine` | Configure a custom status line to display context. See [statusLine documentation](https://docs.anthropic.com/en/docs/claude-code/statusline) | `{"type": "command", "command": "~/.claude/statusline.sh"}` |
| `forceLoginMethod` | Use `claudeai` to restrict login to Claude.ai accounts, `console` to restrict login to Anthropic Console (API usage billing) accounts | `claudeai` |
| `enableAllProjectMcpServers` | Automatically approve all MCP servers defined in project `.mcp.json` files | `true` |
| `enabledMcpjsonServers` | List of specific MCP servers from `.mcp.json` files to approve | `["memory", "github"]` |
| `disabledMcpjsonServers` | List of specific MCP servers from `.mcp.json` files to reject | `["filesystem"]` |
| `awsAuthRefresh` | Custom script that modifies the `.aws` directory (see [advanced credential configuration](https://docs.anthropic.com/en/docs/claude-code/amazon-bedrock#advanced-credential-configuration)) | `aws sso login --profile myprofile` |
| `awsCredentialExport` | Custom script that outputs JSON with AWS credentials (see [advanced credential configuration](https://docs.anthropic.com/en/docs/claude-code/amazon-bedrock#advanced-credential-configuration)) | `/bin/generate_aws_grant.sh` |

### Permission settings

| Keys | Description | Example |
|------|-------------|---------|
| `allow` | Array of permission rules to allow tool use | `[ "Bash(git diff:*)" ]` |
| `ask` | Array of permission rules to ask for confirmation upon tool use. | `[ "Bash(git push:*)" ]` |
| `deny` | Array of permission rules to deny tool use. Use this to also exclude sensitive files from Claude Code access. | `[ "WebFetch", "Bash(curl:*)", "Read(./.env)", "Read(./secrets/**)" ]` |
| `additionalDirectories` | Additional working directories that Claude has access to | `[ "../docs/" ]` |
| `defaultMode` | Default permission mode when opening Claude Code | `"acceptEdits"` |
| `disableBypassPermissionsMode` | Set to `"disable"` to prevent `bypassPermissions` mode from being activated. See [managed policy settings](https://docs.anthropic.com/en/docs/claude-code/iam#enterprise-managed-policy-settings) | `"disable"` |

## Settings precedence

Settings are applied in order of precedence (highest to lowest):

1. **Enterprise managed policies** (`managed-settings.json`)
   - Deployed by IT/DevOps
   - Cannot be overridden

2. **Command line arguments**
   - Temporary overrides for a specific session

3. **Local project settings** (`.claude/settings.local.json`)
   - Personal project-specific settings

4. **Shared project settings** (`.claude/settings.json`)
   - Team-shared project settings in source control

5. **User settings** (`~/.claude/settings.json`)
   - Personal global settings

This hierarchy ensures that enterprise security policies are always enforced while still allowing teams and individuals to customize their experience.

## Key points about the configuration system

- **Memory files (CLAUDE.md)**: Contain instructions and context that Claude loads at startup
- **Settings files (JSON)**: Configure permissions, environment variables, and tool behavior
- **Slash commands**: Custom commands that can be invoked during a session with `/command-name`
- **MCP servers**: Extend Claude Code with additional tools and integrations
- **Precedence**: Higher-level configurations (Enterprise) override lower-level ones (User/Project)
- **Inheritance**: Settings are merged, with more specific settings adding to or overriding broader ones

## System prompt availability

System prompts can be configured at multiple levels:

- **Global system prompts**: In user settings (`~/.claude/settings.json`)
- **Project system prompts**: In project settings (`.claude/settings.json`)
- **Session system prompts**: Via command line arguments (`--system-prompt`)
- **CLAUDE.md**: Project-specific instructions and context

## Excluding sensitive files

To prevent Claude Code from accessing files containing sensitive information (e.g., API keys, secrets, environment files), use the `permissions.deny` setting in your `.claude/settings.json` file:

```json
{
  "permissions": {
    "deny": [
      "Read(./.env)",
      "Read(./secrets/**)",
      "Read(./config/**.secret)",
      "Bash(curl:*)",
      "WebFetch"
    ]
  }
}
```

This replaces the deprecated `ignorePatterns` configuration. Files matching these patterns will be completely invisible to Claude Code, preventing any accidental exposure of sensitive data.

## Subagent configuration

Claude Code supports custom AI subagents that can be configured at both user and project levels. These subagents are stored as Markdown files with YAML frontmatter:

- **User subagents**: `~/.claude/agents/` - Available across all your projects
- **Project subagents**: `.claude/agents/` - Specific to your project and can be shared with your team

Subagent files define specialized AI assistants with custom prompts and tool permissions. Learn more about creating and using subagents in the [subagents documentation](https://docs.anthropic.com/en/docs/claude-code/sub-agents).

## Environment variables

Claude Code supports the following environment variables to control its behavior:

| Variable | Purpose |
|----------|---------|
| `ANTHROPIC_API_KEY` | API key sent as `X-Api-Key` header, typically for the Claude SDK (for interactive usage, run `/login`) |
| `ANTHROPIC_AUTH_TOKEN` | Custom value for the `Authorization` header (the value you set here will be prefixed with `Bearer`) |
| `ANTHROPIC_CUSTOM_HEADERS` | Custom headers you want to add to the request (in `Name: Value` format) |
| `ANTHROPIC_MODEL` | Name of custom model to use (see [Model Configuration](https://docs.anthropic.com/en/docs/claude-code/bedrock-vertex-proxies#model-configuration)) |
| `ANTHROPIC_SMALL_FAST_MODEL` | Name of Haiku-class model for background tasks |
| `ANTHROPIC_SMALL_FAST_MODEL_AWS_REGION` | Override AWS region for the small/fast model when using Bedrock |
| `AWS_BEARER_TOKEN_BEDROCK` | Bedrock API key for authentication (see [Bedrock API keys](https://aws.amazon.com/blogs/machine-learning/accelerate-ai-development-with-amazon-bedrock-api-keys/)) |
| `BASH_DEFAULT_TIMEOUT_MS` | Default timeout for long-running bash commands |
| `BASH_MAX_TIMEOUT_MS` | Maximum timeout the model can set for long-running bash commands |
| `BASH_MAX_OUTPUT_LENGTH` | Maximum number of characters in bash outputs before they are middle-truncated |
| `CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR` | Return to the original working directory after each Bash command |
| `CLAUDE_CODE_API_KEY_HELPER_TTL_MS` | Interval in milliseconds at which credentials should be refreshed (when using `apiKeyHelper`) |
| `CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL` | Skip auto-installation of IDE extensions |
| `CLAUDE_CODE_MAX_OUTPUT_TOKENS` | Set the maximum number of output tokens for most requests |
| `CLAUDE_CODE_USE_BEDROCK` | Use [Bedrock](https://docs.anthropic.com/en/docs/claude-code/amazon-bedrock) |
| `CLAUDE_CODE_USE_VERTEX` | Use [Vertex](https://docs.anthropic.com/en/docs/claude-code/google-vertex-ai) |
| `CLAUDE_CODE_SKIP_BEDROCK_AUTH` | Skip AWS authentication for Bedrock (e.g., when using an LLM gateway) |
| `CLAUDE_CODE_SKIP_VERTEX_AUTH` | Skip Google authentication for Vertex (e.g., when using an LLM gateway) |
| `CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC` | Equivalent of setting `DISABLE_AUTOUPDATER`, `DISABLE_BUG_COMMAND`, `DISABLE_ERROR_REPORTING`, and `DISABLE_TELEMETRY` |
| `CLAUDE_CODE_DISABLE_TERMINAL_TITLE` | Set to `1` to disable automatic terminal title updates based on conversation context |
| `DISABLE_AUTOUPDATER` | Set to `1` to disable automatic updates. This takes precedence over the `autoUpdates` configuration setting. |
| `DISABLE_BUG_COMMAND` | Set to `1` to disable the `/bug` command |
| `DISABLE_COST_WARNINGS` | Set to `1` to disable cost warning messages |
| `DISABLE_ERROR_REPORTING` | Set to `1` to opt out of Sentry error reporting |
| `DISABLE_NON_ESSENTIAL_MODEL_CALLS` | Set to `1` to disable model calls for non-critical paths like flavor text |
| `DISABLE_TELEMETRY` | Set to `1` to opt out of Statsig telemetry (note that Statsig events do not include user data like code, file paths, or bash commands) |
| `HTTP_PROXY` | Specify HTTP proxy server for network connections |
| `HTTPS_PROXY` | Specify HTTPS proxy server for network connections |
| `MAX_THINKING_TOKENS` | Force a thinking for the model budget |
| `MCP_TIMEOUT` | Timeout in milliseconds for MCP server startup |
| `MCP_TOOL_TIMEOUT` | Timeout in milliseconds for MCP tool execution |
| `MAX_MCP_OUTPUT_TOKENS` | Maximum number of tokens allowed in MCP tool responses (default: 25000) |
| `USE_BUILTIN_RIPGREP` | Set to `0` to use system-installed `rg` instead of `rg` included with Claude Code |
| `VERTEX_REGION_CLAUDE_3_5_HAIKU` | Override region for Claude 3.5 Haiku when using Vertex AI |
| `VERTEX_REGION_CLAUDE_3_5_SONNET` | Override region for Claude Sonnet 3.5 when using Vertex AI |
| `VERTEX_REGION_CLAUDE_3_7_SONNET` | Override region for Claude 3.7 Sonnet when using Vertex AI |
| `VERTEX_REGION_CLAUDE_4_0_OPUS` | Override region for Claude 4.0 Opus when using Vertex AI |
| `VERTEX_REGION_CLAUDE_4_0_SONNET` | Override region for Claude 4.0 Sonnet when using Vertex AI |
| `VERTEX_REGION_CLAUDE_4_1_OPUS` | Override region for Claude 4.1 Opus when using Vertex AI |

## Configuration options

To manage your configurations, use the following commands:

- List settings: `claude config list`
- See a setting: `claude config get <key>`
- Change a setting: `claude config set <key> <value>`
- Push to a setting (for lists): `claude config add <key> <value>`
- Remove from a setting (for lists): `claude config remove <key> <value>`

By default `config` changes your project configuration. To manage your global configuration, use the `--global` (or `-g`) flag.

### Global configuration

To set a global configuration, use `claude config set -g <key> <value>`:

| Key | Description | Example |
|------|-------------|---------|
| `autoUpdates` | Whether to enable automatic updates (default: `true`). When enabled, Claude Code automatically downloads and installs updates in the background. Updates are applied when you restart Claude Code. | `false` |
| `preferredNotifChannel` | Where you want to receive notifications (default: `iterm2`) | `iterm2`, `iterm2_with_bell`, `terminal_bell`, or `notifications_disabled` |
| `theme` | Color theme | `dark`, `light`, `light-daltonized`, or `dark-daltonized` |
| `verbose` | Whether to show full bash and command outputs (default: `false`) | `true` |

## Tools available to Claude

Claude Code has access to a set of powerful tools that help it understand and modify your codebase:

| Tool | Description | Permission Required |
|------|-------------|-------------------|
| **Bash** | Executes shell commands in your environment | Yes |
| **Edit** | Makes targeted edits to specific files | Yes |
| **Glob** | Finds files based on pattern matching | No |
| **Grep** | Searches for patterns in file contents | No |
| **LS** | Lists files and directories | No |
| **MultiEdit** | Performs multiple edits on a single file atomically | Yes |
| **NotebookEdit** | Modifies Jupyter notebook cells | Yes |
| **NotebookRead** | Reads and displays Jupyter notebook contents | No |
| **Read** | Reads the contents of files | No |
| **Task** | Runs a sub-agent to handle complex, multi-step tasks | No |
| **TodoWrite** | Creates and manages structured task lists | No |
| **WebFetch** | Fetches content from a specified URL | Yes |
| **WebSearch** | Performs web searches with domain filtering | Yes |
| **Write** | Creates or overwrites files | Yes |

Permission rules can be configured using `/allowed-tools` or in [permission settings](https://docs.anthropic.com/en/docs/claude-code/iam#configuring-permissions).

### Extending tools with hooks

You can run custom commands before or after any tool executes using Claude Code hooks.

For example, you could automatically run a Python formatter after Claude modifies Python files, or prevent modifications to production configuration files by blocking Write operations to certain paths.

See [Claude Code hooks](https://docs.anthropic.com/en/docs/claude-code/hooks-guide) documentation for more details.

## Permission Configuration

### Permission Modes

Claude Code supports several permission modes that control how Claude interacts with your system:

- **default**: Requires explicit approval for potentially destructive operations
- **acceptEdits**: Automatically approves file edits but asks for other operations
- **plan**: Read-only mode, useful for code reviews and analysis
- **bypassPermissions**: Allows all operations (use with caution)

### Permission Rules

Permission rules use pattern matching to control tool access:

```json
{
  "permissions": {
    "allow": [
      "Read(**/*)",
      "Bash(git diff:*)",
      "Bash(git status)"
    ],
    "ask": [
      "Bash(git commit:*)",
      "Bash(git push:*)"
    ],
    "deny": [
      "Read(./.env)",
      "Read(./secrets/**)",
      "Bash(rm:*)",
      "Bash(curl:*)",
      "WebFetch"
    ]
  }
}
```

### Working Directories

Control which directories Claude can access:

```json
{
  "permissions": {
    "additionalDirectories": [
      "../docs/",
      "../shared/"
    ]
  }
}
```

## MCP Configuration

Model Context Protocol (MCP) servers can be configured in settings:

```json
{
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": ["memory", "github"],
  "disabledMcpjsonServers": ["filesystem"]
}
```

## Status Line Configuration

Customize the terminal status line to show context:

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh"
  }
}
```

Or use the built-in status line:

```json
{
  "statusLine": {
    "type": "builtin"
  }
}
```

## Model Configuration

Override the default model:

```json
{
  "model": "claude-3-5-sonnet-20241022"
}
```

## Environment Configuration

Set environment variables for all sessions:

```json
{
  "env": {
    "NODE_ENV": "development",
    "PYTHONPATH": "./src:./tests"
  }
}
```

## Hook Configuration

Configure custom hooks for tool events:

```json
{
  "hooks": {
    "PreToolUse": {
      "Write": "echo 'About to write to file'"
    },
    "PostToolUse": {
      "Bash": "echo 'Command completed'"
    }
  }
}
```

## Best Practices

### Security

- Use `deny` rules to protect sensitive files and directories
- Regularly review permission settings
- Use environment variables for sensitive credentials
- Enable audit logging for compliance requirements

### Performance

- Configure appropriate timeouts for long-running operations
- Use MCP servers for frequently accessed external data
- Limit file access patterns to improve performance
- Monitor resource usage with verbose logging

### Team Collaboration

- Share project settings in version control
- Use `.claude/settings.local.json` for personal preferences
- Document configuration choices for team members
- Regularly review and update shared configurations

### Enterprise Deployment

- Use managed policy settings for security compliance
- Deploy configurations across the organization
- Monitor and audit configuration changes
- Integrate with existing IT management systems

## Troubleshooting

### Common Issues

1. **Settings not applying**: Check settings precedence and ensure files are in correct locations
2. **Permission errors**: Review permission rules and ensure patterns are correctly formatted
3. **Environment variables not set**: Verify variable names and check if they're being overridden
4. **MCP servers not working**: Check server configurations and authentication

### Debug Commands

```bash
# List all settings
claude config list

# Check specific setting
claude config get permissions

# Verify file locations
ls -la ~/.claude/settings.json
ls -la .claude/settings.json

# Test permission rules
claude config test-permissions

# Check MCP server status
claude mcp status
```

### Configuration Validation

Claude Code validates settings files on startup and will report errors for:

- Invalid JSON syntax
- Unknown configuration keys
- Invalid permission rule patterns
- Missing required values
- Type mismatches

## See also

- [Identity and Access Management](https://docs.anthropic.com/en/docs/claude-code/iam#configuring-permissions) - Learn about Claude Code's permission system
- [IAM and access control](https://docs.anthropic.com/en/docs/claude-code/iam#enterprise-managed-policy-settings) - Enterprise policy management
- [Troubleshooting](https://docs.anthropic.com/en/docs/claude-code/troubleshooting#auto-updater-issues) - Solutions for common configuration issues
- [Analytics](https://docs.anthropic.com/en/docs/claude-code/analytics) - Usage monitoring and insights
- [Add Claude Code to your IDE](https://docs.anthropic.com/en/docs/claude-code/ide-integrations) - IDE integration setup

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-slash-commands.md`:

```md
# Slash commands

Control Claudeâ€™s behavior during an interactive session with slash commands.

## Built-in slash commands

| Command | Purpose |
| --- | --- |
| `/add-dir` | Add additional working directories |
| `agents` | Manage custom AI subagents for specialized tasks |
| `bug` | Report bugs (sends conversation to Anthropic) |
| `clear` | Clear conversation history |
| `compact [instructions]` | Compact conversation with optional focus instructions |
| `config` | View/modify configuration |
| `cost` | Show token usage statistics (see [cost tracking guide](/en/docs/claude-code/costs#using-the-cost-command) for subscription-specific details) |
| `doctor` | Checks the health of your Claude Code installation |
| `help` | Get usage help |
| `init` | Initialize project with CLAUDE.md guide |
| `login` | Switch Anthropic accounts |
| `logout` | Sign out from your Anthropic account |
| `mcp` | Manage MCP server connections and OAuth authentication |
| `memory` | Edit CLAUDE.md memory files |
| `model` | Select or change the AI model |
| `permissions` | View or update [permissions](/en/docs/claude-code/iam#configuring-permissions) |
| `pr_comments` | View pull request comments |
| `review` | Request code review |
| `status` | View account and system statuses |
| `terminal-setup` | Install Shift+Enter key binding for newlines (iTerm2 and VSCode only) |
| `vim` | Enter vim mode for alternating insert and command modes |

## Custom slash commands

Custom slash commands allow you to define frequently-used prompts as Markdown files that Claude Code can execute. Commands are organized by scope (project-specific or personal) and support namespacing through directory structures.

### Syntax

```plaintext
/<command-name> [arguments]

Parameters
Parameter	Description
<command-name>	Name derived from the Markdown filename (without .md)
[arguments]	Optional arguments passed to the command
Command types
Project commands

Commands stored in your repository and shared with your team. When listed in /help, these commands show â€œ(project)â€ after their description.

Location: .claude/commands/

In the following example, we create the /optimize command:

# Create a project command
mkdir -p .claude/commands
echo "Analyze this code for performance issues and suggest optimizations:" > .claude/commands/optimize.md

Personal commands

Commands available across all your projects. When listed in /help, these commands show â€œ(user)â€ after their description.

Location: ~/.claude/commands/

In the following example, we create the /security-review command:

# Create a personal command
mkdir -p ~/.claude/commands
echo "Review this code for security vulnerabilities:" > ~/.claude/commands/security-review.md

Features
Namespacing

Organize commands in subdirectories. The subdirectories are used for organization and appear in the command description, but they do not affect the command name itself. The description will show whether the command comes from the project directory (.<claude/commands) or the user-level directory (~/.claude/commands), along with the subdirectory name.

Conflicts between user and project level commands are not supported. Otherwise, multiple commands with the same base file name can coexist.

For example, a file at .claude/commands/frontend/component.md creates the command /component with description showing â€œ(project:frontend)â€.

Meanwhile, a file at ~/.claude/commands/component.md creates the command /component with description showing â€œ(user)`.

Arguments

Pass dynamic values to commands using the $ARGUMENTS placeholder.

For example:

# Command definition
echo 'Fix issue #$ARGUMENTS following our coding standards' > .claude/commands/fix-issue.md

# Usage
> /fix-issue 123

Bash command execution

Execute bash commands before the slash command runs using the ! prefix. The output is included in the command context. You must include allowed-tools with the Bash, but you can choose the specific bash commands to allow.

For example:

---
allowed-tools: Bash(git add:*), Bash(git status:*), Bash(git commit:)
description: Create a git commit
---

## Context

- Current git status: !{git status}
- Current git diff (staged and unstaged changes): !{git diff HEAD}
- Current branch: !{git branch --show-current}
- Recent commits: !{git log --oneline -10}

---

## Your task

Based on the above changes, create a single git commit.

File references

Include file contents in commands using the %@ prefix to reference files.

For example:

# Reference a specific file

Review the implementation in @src/utils/helpers.js

# Reference multiple files

Compare @src/old-version.js with @src/new-version.js

Thinking mode

Slash commands can trigger extended thinking by including extended thinking keywords.

Frontmatter

Command files support frontmatter, useful for specifying metadata about the command:

Frontmatter	Purpose	Default
allowed-tools	List of tools	Inherits from the conversation
argument-hint	The arguments expected	None
description	Brief description	Uses first line of prompt
model	Specific model string	Inherited from conversation

For example:

---
allowed-tools: Bash(git add:*), Bash(git status:*), Bash(git commit:)
argument-hint: [message]
description: Create a git commit
model: claude-3-5-haiku-20241022
---

An example command

MCP slash commands

MCP servers can expose prompts as slash commands that become available in Claude Code. These commands are dynamically discovered from connected MCP servers.

Command format

MCP commands follow this pattern:

/mcp_<server-name>_<prompt-name> [arguments]

Features
Dynamic discovery

MCP commands are automatically available when:

An MCP server is connected and active
The server exposes prompts through the MCP protocol
The prompts are successfully retrieved during connection
Arguments

MCP prompts can accept arguments defined by the server:

# Without arguments
> /mcp_<github>_list_prs 

# With arguments
> /mcp_<github>_pr_review 456 
> /mcp_<jira>_create_issue "Bug title" high 

Naming conventions
Server and prompt names are normalized
Spaces and special characters become underscores
Names are lowercased for consistency
Managing MCP connections

Use the /mcp command to:

View all configured MCP servers
Check connection status
Authenticate with OAuth-enabled servers
Clear authentication tokens
View available tools and prompts from each server
See also
Interactive mode - Shortcuts, input modes, and interactive features
CLI reference - Command-line flags and options
Settings - Configuration options
Memory management - Managing Claudeâ€™s memory across sessions

Interactive mode

Hooks reference
```

`claude-model-switcher/docs/claude-code-statusline.md`:

```md
# Claude Code Status Line Configuration Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/statusline*
*Download date: 2025-08-21*

---

## Overview

Create a custom status line for Claude Code to display contextual information.

Make Claude Code your own with a custom status line that displays at the bottom of the Claude Code interface, similar to how terminal prompts (PS1) work in shells like Oh-my-zsh.

## Create a custom status line

You can either:

- **Run `/statusline`** to ask Claude Code to help you set up a custom status line. By default, it will try to reproduce your terminal's prompt, but you can provide additional instructions about the behavior you want Claude Code, such as `/statusline show the model name in orange`

- **Directly add a `statusLine` command** to your `.claude/settings.json`:

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh",
    "padding": 0 // Optional: set to 0 to let status line go to edge
  }
}
```

## How it Works

- The status line is updated when the conversation messages update
- Updates run at most every 300ms
- The first line of stdout from your command becomes the status line text
- ANSI color codes are supported for styling your status line
- Claude Code passes contextual information about the current session (model, directories, etc.) as JSON to your script via stdin

## JSON Input Structure

Your status line command receives structured data via stdin in JSON format:

```json
{
  "hook_event_name": "Status",
  "session_id": "abc123...",
  "transcript_path": "/path/to/transcript.json",
  "cwd": "/current/working/directory",
  "model": {
    "id": "claude-opus-4-1",
    "display_name": "Opus"
  },
  "workspace": {
    "current_dir": "/current/working/directory",
    "project_dir": "/original/project/directory"
  },
  "version": "1.0.80",
  "output_style": {
    "name": "default"
  },
  "cost": {
    "total_cost_usd": 0.01234,
    "total_duration_ms": 45000,
    "total_api_duration_ms": 2300,
    "total_lines_added": 156,
    "total_lines_removed": 23
  }
}
```

## Example Scripts

### Simple Status Line

```bash
#!/bin/bash
# Read JSON input from stdin
input=$(cat)

# Extract values using jq
MODEL_DISPLAY=$(echo "$input" | jq -r '.model.display_name')
CURRENT_DIR=$(echo "$input" | jq -r '.workspace.current_dir')

echo "[$MODEL_DISPLAY] ğŸ“ ${CURRENT_DIR##*/}"
```

### Git-Aware Status Line

```bash
#!/bin/bash
# Read JSON input from stdin
input=$(cat)

# Extract values using jq
MODEL_DISPLAY=$(echo "$input" | jq -r '.model.display_name')
CURRENT_DIR=$(echo "$input" | jq -r '.workspace.current_dir')

# Show git branch if in a git repo
GIT_BRANCH=""
if git rev-parse --git-dir > /dev/null 2>&1; then
    BRANCH=$(git branch --show-current 2>/dev/null)
    if [ -n "$BRANCH" ]; then
        GIT_BRANCH=" | ğŸŒ¿ $BRANCH"
    fi
fi

echo "[$MODEL_DISPLAY] ğŸ“ ${CURRENT_DIR##*/}$GIT_BRANCH"
```

### Python Example

```python
#!/usr/bin/env python3
import json
import sys
import os

# Read JSON from stdin
data = json.load(sys.stdin)

# Extract values
model = data['model']['display_name']
current_dir = os.path.basename(data['workspace']['current_dir'])

# Check for git branch
git_branch = ""
if os.path.exists('.git'):
    try:
        with open('.git/HEAD', 'r') as f:
            ref = f.read().strip()
            if ref.startswith('ref: refs/heads/'):
                git_branch = f" | ğŸŒ¿ {ref.replace('ref: refs/heads/', '')}"
    except:
        pass

print(f"[{model}] ğŸ“ {current_dir}{git_branch}")
```

### Node.js Example

```javascript
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Read JSON from stdin
let input = '';
process.stdin.on('data', chunk => input += chunk);
process.stdin.on('end', () => {
    const data = JSON.parse(input);
    
    // Extract values
    const model = data.model.display_name;
    const currentDir = path.basename(data.workspace.current_dir);
    
    // Check for git branch
    let gitBranch = '';
    try {
        const headContent = fs.readFileSync('.git/HEAD', 'utf8').trim();
        if (headContent.startsWith('ref: refs/heads/')) {
            gitBranch = ` | ğŸŒ¿ ${headContent.replace('ref: refs/heads/', '')}`;
        }
    } catch (e) {
        // Not a git repo or can't read HEAD
    }
    
    console.log(`[${model}] ğŸ“ ${currentDir}${gitBranch}`);
});
```

### Helper Function Approach

For more complex bash scripts, you can create helper functions:

```bash
#!/bin/bash
# Read JSON input once
input=$(cat)

# Helper functions for common extractions
get_model_name() { echo "$input" | jq -r '.model.display_name'; }
get_current_dir() { echo "$input" | jq -r '.workspace.current_dir'; }
get_project_dir() { echo "$input" | jq -r '.workspace.project_dir'; }
get_version() { echo "$input" | jq -r '.version'; }
get_cost() { echo "$input" | jq -r '.cost.total_cost_usd'; }
get_duration() { echo "$input" | jq -r '.cost.total_duration_ms'; }
get_lines_added() { echo "$input" | jq -r '.cost.total_lines_added'; }
get_lines_removed() { echo "$input" | jq -r '.cost.total_lines_removed'; }

# Use the helpers
MODEL=$(get_model_name)
DIR=$(get_current_dir)
echo "[$MODEL] ğŸ“ ${DIR##*/}"
```

## Advanced Status Line Examples

### Cost-Aware Status Line

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')
COST=$(echo "$input" | jq -r '.cost.total_cost_usd')
DURATION=$(echo "$input" | jq -r '.cost.total_duration_ms')

# Format cost with color
if (( $(echo "$COST > 0.01" | bc -l) )); then
    COST_DISPLAY="\033[31m$$COST\033[0m"
else
    COST_DISPLAY="\033[32m$$COST\033[0m"
fi

echo "[$MODEL] ğŸ“ $DIR | ğŸ’°$COST_DISPLAY | â±ï¸ ${DURATION}ms"
```

### Environment-Aware Status Line

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')
PYTHON_VERSION=$(python3 --version 2>/dev/null | cut -d' ' -f2)
NODE_VERSION=$(node --version 2>/dev/null | cut -d'v' -f2)

ENV_INFO=""
if [ -n "$PYTHON_VERSION" ]; then
    ENV_INFO=" | ğŸ $PYTHON_VERSION"
fi
if [ -n "$NODE_VERSION" ]; then
    ENV_INFO="$ENV_INFO | ğŸŸ¢ $NODE_VERSION"
fi

echo "[$MODEL] ğŸ“ $DIR$ENV_INFO"
```

### MCP Server Status

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

# Check if MCP servers are configured
MCP_COUNT=$(echo "$input" | jq '.mcp_servers // [] | length')
MCP_INFO=""
if [ "$MCP_COUNT" -gt 0 ]; then
    MCP_INFO=" | ğŸ”Œ $MCP_COUNT MCP"
fi

echo "[$MODEL] ğŸ“ $DIR$MCP_INFO"
```

### Project Type Detection

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

PROJECT_TYPE=""
if [ -f "package.json" ]; then
    PROJECT_TYPE=" | ğŸ“¦ Node.js"
elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
    PROJECT_TYPE=" | ğŸ Python"
elif [ -f "Cargo.toml" ]; then
    PROJECT_TYPE=" | ğŸ¦€ Rust"
elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
    PROJECT_TYPE=" | â˜• Java"
elif [ -f "go.mod" ]; then
    PROJECT_TYPE=" | ğŸ”· Go"
fi

echo "[$MODEL] ğŸ“ $DIR$PROJECT_TYPE"
```

## Tips

- **Keep your status line concise** - it should fit on one line
- **Use emojis** (if your terminal supports them) and colors to make information scannable
- **Use `jq` for JSON parsing** in Bash (see examples above)
- **Test your script manually** by running it with mock JSON input: `echo '{"model":{"display_name":"Test"},"workspace":{"current_dir":"/test"}}' | ./statusline.sh`
- **Consider caching expensive operations** (like git status) if needed
- **Use appropriate colors** for different types of information (green for good, red for warnings, etc.)
- **Make it responsive** to different terminal widths

## Color and Styling

### ANSI Color Codes

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')
COST=$(echo "$input" | jq -r '.cost.total_cost_usd')

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Color cost based on amount
if (( $(echo "$COST > 0.05" | bc -l) )); then
    COST_COLOR=$RED
elif (( $(echo "$COST > 0.02" | bc -l) )); then
    COST_COLOR=$YELLOW
else
    COST_COLOR=$GREEN
fi

echo -e "${BOLD}${BLUE}[$MODEL]${NC} ğŸ“ $DIR | ğŸ’°${COST_COLOR}$$COST${NC}"
```

### Icon Usage

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

# Different icons for different models
case $MODEL in
    "Opus") MODEL_ICON="ğŸš€" ;;
    "Sonnet") MODEL_ICON="âš¡" ;;
    "Haiku") MODEL_ICON="ğŸŒ¸" ;;
    *) MODEL_ICON="ğŸ¤–" ;;
esac

echo "$MODEL_ICON [$MODEL] ğŸ“ $DIR"
```

## Performance Optimization

### Caching Expensive Operations

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

# Cache git branch info to avoid repeated git commands
CACHE_DIR="/tmp/claude-statusline"
CACHE_FILE="$CACHE_DIR/git-branch-$(echo $DIR | tr '/' '_').txt"

# Create cache directory if it doesn't exist
mkdir -p "$CACHE_DIR"

# Check cache age (5 minutes)
if [ -f "$CACHE_FILE" ] && [ $(find "$CACHE_FILE" -mmin -5 2>/dev/null) ]; then
    GIT_BRANCH=$(cat "$CACHE_FILE")
else
    GIT_BRANCH=""
    if git rev-parse --git-dir > /dev/null 2>&1; then
        BRANCH=$(git branch --show-current 2>/dev/null)
        if [ -n "$BRANCH" ]; then
            GIT_BRANCH=" | ğŸŒ¿ $BRANCH"
            echo "$GIT_BRANCH" > "$CACHE_FILE"
        fi
    fi
fi

echo "[$MODEL] ğŸ“ ${DIR##*/}$GIT_BRANCH"
```

### Minimal Version

```bash
#!/bin/bash
# Fast, minimal version for slow systems
read input
MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir' | cut -d'/' -f5)
echo "[$MODEL] $DIR"
```

## Troubleshooting

### Common Issues

1. **Status line doesn't appear**
   - Check that your script is executable: `chmod +x ~/.claude/statusline.sh`
   - Ensure your script outputs to stdout (not stderr)
   - Verify the path in your settings.json is correct

2. **Status line is blank**
   - Make sure your script outputs exactly one line
   - Check for errors in your script by running it manually
   - Verify JSON parsing is working correctly

3. **Colors not displaying**
   - Ensure your terminal supports ANSI color codes
   - Check that color codes are properly formatted
   - Test colors with a simple script: `echo -e "\033[31mRed\033[0m"`

4. **Performance issues**
   - Reduce complexity of your script
   - Add caching for expensive operations
   - Avoid external commands that are slow to execute

### Debug Commands

```bash
# Test your status line script manually
echo '{"model":{"display_name":"Test"},"workspace":{"current_dir":"/test"}}' | ~/.claude/statusline.sh

# Check if script is executable
ls -la ~/.claude/statusline.sh

# Verify settings.json configuration
cat ~/.claude/settings.json | jq '.statusLine'

# Test with real data (run during Claude Code session)
echo "Current session data:" > /tmp/statusline-debug.json
# Paste real JSON data and test
cat /tmp/statusline-debug.json | ~/.claude/statusline.sh
```

### Error Handling

```bash
#!/bin/bash
# Robust status line with error handling
set -euo pipefail

input=$(cat 2>/dev/null || echo '{}')

# Safe extraction with defaults
MODEL=$(echo "$input" | jq -r '.model.display_name // "Unknown"')
DIR=$(echo "$input" | jq -r '.workspace.current_dir // "/unknown"' | xargs basename)

echo "[$MODEL] ğŸ“ $DIR" 2>/dev/null || echo "[Claude] ğŸ“ unknown"
```

## Integration with Other Features

### Memory Integration

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

# Check for CLAUDE.md in current directory
MEMORY_INFO=""
if [ -f "CLAUDE.md" ]; then
    MEMORY_INFO=" | ğŸ“ CLAUDE.md"
fi

echo "[$MODEL] ğŸ“ $DIR$MEMORY_INFO"
```

### MCP Server Status

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')

# Count MCP servers from input
MCP_COUNT=$(echo "$input" | jq '.mcp_servers // [] | length')
MCP_INFO=""
if [ "$MCP_COUNT" -gt 0 ]; then
    MCP_INFO=" | ğŸ”Œ $MCP_COUNT servers"
fi

echo "[$MODEL] ğŸ“ $DIR$MCP_INFO"
```

## Configuration Options

### Settings.json Configuration

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline.sh",
    "padding": 0,
    "updateInterval": 300
  }
}
```

### Built-in Status Line

For a simple built-in status line without custom scripts:

```json
{
  "statusLine": {
    "type": "builtin"
  }
}
```

### Multiple Status Lines

You can create different status lines for different contexts:

```json
{
  "statusLine": {
    "type": "command",
    "command": "~/.claude/statusline-context-aware.sh"
  }
}
```

Then in your script:

```bash
#!/bin/bash
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name')
DIR=$(echo "$input" | jq -r '.workspace.current_dir | basename')
PROJECT_TYPE=$(echo "$input" | jq -r '.project_type // "unknown"')

case $PROJECT_TYPE in
    "node") PROJECT_ICON="ğŸ“¦" ;;
    "python") PROJECT_ICON="ğŸ" ;;
    "rust") PROJECT_ICON="ğŸ¦€" ;;
    *) PROJECT_ICON="ğŸ“" ;;
esac

echo "[$MODEL] $PROJECT_ICON $DIR"
```

## See Also

- [Memory management](https://docs.anthropic.com/en/docs/claude-code/memory) - Context and preference management
- [CLI reference](https://docs.anthropic.com/en/docs/claude-code/cli-reference) - Command-line interface documentation
- [Settings](https://docs.anthropic.com/en/docs/claude-code/settings) - Configuration options
- [Terminal configuration](https://docs.anthropic.com/en/docs/claude-code/terminal-config) - Terminal setup and customization

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-code-sub-agents.md`:

```md
# Claude Code Subagents Documentation

*Downloaded from: https://docs.anthropic.com/en/docs/claude-code/sub-agents*
*Download date: 2025-08-21*

---

## Overview

Custom subagents in Claude Code are specialized AI assistants that can be invoked to handle specific types of tasks. They enable more efficient problem-solving by providing task-specific configurations with customized system prompts, tools and a separate context window.

## What are subagents?

Subagents are pre-configured AI personalities that Claude Code can delegate tasks to. Each subagent:

- Has a specific purpose and expertise area
- Uses its own context window separate from the main conversation
- Can be configured with specific tools it's allowed to use
- Includes a custom system prompt that guides its behavior

When Claude Code encounters a task that matches a subagent's expertise, it can delegate that task to the specialized subagent, which works independently and returns results.

## Key benefits

- **Specialized expertise**: Each subagent focuses on a specific domain or task type
- **Context isolation**: Subagents use separate context windows, preserving main conversation context
- **Tool control**: Granular control over which tools each subagent can access
- **Improved performance**: Task-specific configurations lead to better results
- **Reusability**: Create once, use across multiple projects and conversations

## Quick start

To create your first subagent:

1. **Open the agents interface**: Use the `/agents` command in Claude Code
2. **Create new agent**: Follow the guided setup to define your subagent
3. **Configure tools**: Select which tools the subagent should have access to
4. **Test and refine**: Use the subagent and iterate on its configuration

## Subagent configuration

### File locations

Subagents are stored as Markdown files with YAML frontmatter in two possible locations:

| Type | Location | Scope | Priority |
|------|----------|-------|----------|
| **Project subagents** | `.claude/agents/` | Available in current project | Highest |
| **User subagents** | `~/.claude/agents/` | Available across all projects | Lower |

When subagent names conflict, project-level subagents take precedence over user-level subagents.

### File format

Each subagent is defined in a Markdown file with this structure:

```markdown
---
name: my-specialist
description: A specialist that handles specific tasks
tools: Read,Write,Bash,Grep
---

# System Prompt

You are a specialist assistant focused on [specific domain]. Your expertise includes:

- [Area 1]
- [Area 2]
- [Area 3]

## Guidelines

- Always follow these specific rules...
- Use these approaches...
- Consider these constraints...

## Examples

When asked to [task], you should:

1. First [step 1]
2. Then [step 2]
3. Finally [step 3]
```

### Configuration fields

| Field | Required | Description |
|------|----------|-------------|
| `name` | Yes | Unique identifier using lowercase letters and hyphens |
| `description` | Yes | Natural language description of the subagent's purpose |
| `tools` | No | Comma-separated list of specific tools. If omitted, inherits all tools from the main thread |

### Available tools

Subagents can be granted access to any of Claude Code's internal tools. See the [tools documentation](https://docs.anthropic.com/en/docs/claude-code/settings#tools-available-to-claude) for a complete list of available tools.

You have two options for configuring tools:

- **Omit the `tools` field** to inherit all tools from the main thread (default), including MCP tools
- **Specify individual tools** as a comma-separated list for more granular control (can be edited manually or via `/agents`)

**MCP Tools**: Subagents can access MCP tools from configured MCP servers. When the `tools` field is omitted, subagents inherit all MCP tools available to the main thread.

## Managing subagents

### Using the /agents command (Recommended)

The `/agents` command provides a comprehensive interface for subagent management:

This opens an interactive menu where you can:

- View all available subagents (built-in, user, and project)
- Create new subagents with guided setup
- Edit existing custom subagents, including their tool access
- Delete custom subagents
- See which subagents are active when duplicates exist
- **Easily manage tool permissions** with a complete list of available tools

### Direct file management

You can also manage subagents by working directly with their files:

**Create a subagent:**
```bash
# Create project-level subagent
mkdir -p .claude/agents
cat > .claude/agents/code-reviewer.md << 'EOF'
---
name: code-reviewer
description: Reviews code for quality, security, and best practices
tools: Read,Write,Bash,Grep,WebSearch
---

# Code Review Specialist

You are an expert code reviewer specializing in:

- Code quality and maintainability
- Security vulnerability identification
- Performance optimization
- Best practices and design patterns
- Testing and documentation

## Review Process

When reviewing code, always:

1. **Security First**: Identify potential security vulnerabilities
2. **Quality Assessment**: Check for code quality issues
3. **Performance**: Look for performance bottlenecks
4. **Best Practices**: Ensure adherence to coding standards
5. **Testing**: Verify adequate test coverage

## Output Format

Provide structured feedback with:
- Critical issues (must fix)
- Recommendations (should fix)
- Suggestions (nice to have)
- Positive feedback (what's done well)
EOF
```

**Edit a subagent:**
```bash
# Edit existing subagent
nano .claude/agents/code-reviewer.md
```

**List subagents:**
```bash
# List project subagents
ls -la .claude/agents/

# List user subagents
ls -la ~/.claude/agents/
```

## Using subagents effectively

### Automatic delegation

Claude Code proactively delegates tasks based on:

- The task description in your request
- The `description` field in subagent configurations
- Current context and available tools

**Example:**
```
User: "Please review this pull request for security issues"
Claude: [Detects security review task] â†’ Delegates to security-reviewer subagent
```

### Explicit invocation

Request a specific subagent by mentioning it in your command:

```
"Ask the code-reviewer to check this function"
"Use the data-scientist to analyze these results"
"Have the security-auditor review this configuration"
```

## Example subagents

### Code reviewer

```markdown
---
name: code-reviewer
description: Reviews code for quality, security, and best practices
tools: Read,Write,Bash,Grep,WebSearch
---

# Code Review Specialist

You are an expert code reviewer specializing in:

- Code quality and maintainability
- Security vulnerability identification
- Performance optimization
- Best practices and design patterns
- Testing and documentation

## Review Process

When reviewing code, always:

1. **Security First**: Identify potential security vulnerabilities
2. **Quality Assessment**: Check for code quality issues
3. **Performance**: Look for performance bottlenecks
4. **Best Practices**: Ensure adherence to coding standards
5. **Testing**: Verify adequate test coverage

## Output Format

Provide structured feedback with:
- Critical issues (must fix)
- Recommendations (should fix)
- Suggestions (nice to have)
- Positive feedback (what's done well)
```

### Debugger

```markdown
---
name: debugger
description: Diagnoses and helps fix bugs and issues in code
tools: Read,Write,Bash,Grep,Edit,MultiEdit
---

# Debugging Specialist

You are an expert debugger specializing in:

- Root cause analysis
- Bug reproduction and isolation
- Performance issue diagnosis
- Systematic troubleshooting
- Fix validation

## Debugging Approach

When debugging issues, follow this systematic approach:

1. **Understand the Problem**: Clearly identify symptoms and expected behavior
2. **Reproduce the Issue**: Create minimal reproduction cases
3. **Analyze the Code**: Examine relevant code paths and dependencies
4. **Identify Root Cause**: Find the underlying issue, not just symptoms
5. **Implement Fix**: Apply targeted, minimal changes
6. **Verify Solution**: Test that the fix resolves the issue

## Tools and Techniques

- Use logging and debugging tools effectively
- Break down complex problems into smaller components
- Consider edge cases and error conditions
- Verify fixes don't introduce new issues
```

### Data scientist

```markdown
---
name: data-scientist
description: Analyzes data, creates visualizations, and builds models
tools: Read,Write,Bash,Edit,MultiEdit,WebSearch
---

# Data Science Specialist

You are an expert data scientist specializing in:

- Data analysis and exploration
- Statistical analysis and hypothesis testing
- Machine learning model development
- Data visualization and reporting
- Experimental design and A/B testing

## Analysis Process

When working with data, always:

1. **Understand the Data**: Examine structure, quality, and characteristics
2. **Define Objectives**: Clarify what questions need to be answered
3. **Explore and Clean**: Handle missing values, outliers, and data quality issues
4. **Analyze**: Apply appropriate statistical methods and models
5. **Visualize**: Create clear, informative visualizations
6. **Interpret**: Provide actionable insights and recommendations

## Technical Skills

- Proficient in Python, R, SQL, and data analysis libraries
- Experience with various machine learning algorithms
- Strong statistical foundation
- Data visualization expertise
- Experimental design knowledge
```

## Best practices

- **Start with Claude-generated agents**: We highly recommend generating your initial subagent with Claude and then iterating on it to make it personally yours. This approach gives you the best results - a solid foundation that you can customize to your specific needs.

- **Design focused subagents**: Create subagents with single, clear responsibilities rather than trying to make one subagent do everything. This improves performance and makes subagents more predictable.

- **Write detailed prompts**: Include specific instructions, examples, and constraints in your system prompts. The more guidance you provide, the better the subagent will perform.

- **Limit tool access**: Only grant tools that are necessary for the subagent's purpose. This improves security and helps the subagent focus on relevant actions.

- **Version control**: Check project subagents into version control so your team can benefit from and improve them collaboratively.

## Advanced usage

### Chaining subagents

For complex workflows, you can chain multiple subagents:

```
User: "Build a complete data analysis pipeline"
Claude: 
1. [Data modeling] â†’ Delegates to data-scientist
2. [Code review] â†’ Delegates to code-reviewer  
3. [Testing] â†’ Delegates to test-automation
4. [Integration] â†’ Handles integration itself
```

### Dynamic subagent selection

Claude Code intelligently selects subagents based on context. Make your `description` fields specific and action-oriented for best results.

**Good descriptions:**
- "Reviews Python code for security vulnerabilities and compliance issues"
- "Analyzes JSON data structures and provides optimization recommendations"
- "Debugs JavaScript runtime errors and performance issues"

**Poor descriptions:**
- "Helps with code"
- "Data analysis"
- "General purpose assistant"

## Performance considerations

- **Context efficiency**: Agents help preserve main context, enabling longer overall sessions
- **Latency**: Subagents start off with a clean slate each time they are invoked and may add latency as they gather context that they require to do their job effectively.

## Related documentation

- [Slash commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands) - Learn about other built-in commands
- [Settings](https://docs.anthropic.com/en/docs/claude-code/settings) - Configure Claude Code behavior
- [Hooks](https://docs.anthropic.com/en/docs/claude-code/hooks) - Automate workflows with event handlers
- [Claude Code SDK](https://docs.anthropic.com/en/docs/claude-code/sdk) - Build custom AI agents

---

*This documentation was downloaded from Anthropic docs and saved locally for reference.*
```

`claude-model-switcher/docs/claude-hooks-fix-report.md`:

```md
# Claude Code Hooks ä¿®å¤æŠ¥å‘Š

## ä¿®å¤æ‘˜è¦

âœ… **å·²æˆåŠŸä¿®å¤** SessionStart Hook å’Œ StatusLine é…ç½®é—®é¢˜

## å…·ä½“ä¿®å¤å†…å®¹

### 1. SessionStart Hook æ ¼å¼ä¿®å¤
**é—®é¢˜**: 
- åŸå§‹æ ¼å¼ç¼ºå°‘å¿…è¦çš„ `matcher` å’Œ `hooks` æ•°ç»„ç»“æ„
- Hook æ— æ³•æ­£å¸¸è§¦å‘

**ä¿®å¤**:
- æ·»åŠ äº†æ­£ç¡®çš„ `matcher` å­—æ®µï¼ˆ`startup`, `resume`ï¼‰
- ä½¿ç”¨äº†æ–‡æ¡£ä¸­æŒ‡å®šçš„æ­£ç¡®åµŒå¥—ç»“æ„
- ä¸ºä¸åŒåœºæ™¯æä¾›äº†ä¸åŒçš„æ¶ˆæ¯

```json
{
  "matcher": "startup",
  "hooks": [
    {
      "type": "command",
      "command": "echo 'ğŸ¤– Session Started - ...'"
    }
  ]
}
```

### 2. StatusLine é…ç½®ä¼˜åŒ–
**é—®é¢˜**:
- åŸå§‹å‘½ä»¤åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å¤±è´¥
- ç¼ºå°‘é”™è¯¯å¤„ç†æœºåˆ¶

**ä¿®å¤**:
- æ·»åŠ äº†é”™è¯¯å¤„ç† (`2>/dev/null`)
- æä¾›äº†å¤‡ç”¨è·¯å¾„æ˜¾ç¤º (`|| echo '$PWD'`)
- ä¿®å¤äº† JSON è½¬ä¹‰å­—ç¬¦é—®é¢˜
- å¢å¼ºäº†å‘½ä»¤çš„å¥å£®æ€§

### 3. è°ƒè¯•åŠŸèƒ½å¢å¼º
**æ–°å¢**:
- Notification hook ç”¨äºè®°å½•é€šçŸ¥æ¶ˆæ¯
- åˆ›å»ºäº†æµ‹è¯•è„šæœ¬éªŒè¯åŠŸèƒ½
- æ·»åŠ äº†æ—¥å¿—è®°å½•æœºåˆ¶

## éªŒè¯ç»“æœ

âœ… **StatusLine å‘½ä»¤æµ‹è¯•é€šè¿‡**
- æ˜¾ç¤ºæ ¼å¼: `ç”¨æˆ·@ä¸»æœº:ç›®å½•è·¯å¾„`
- é¢œè‰²ç¼–ç æ­£å¸¸
- é”™è¯¯å¤„ç†æœ‰æ•ˆ

âœ… **Notification Hook æµ‹è¯•é€šè¿‡**
- æˆåŠŸè®°å½•é€šçŸ¥åˆ°æ—¥å¿—æ–‡ä»¶
- æ—¶é—´æˆ³æ ¼å¼æ­£ç¡®
- ç¯å¢ƒå˜é‡è¯»å–æ­£å¸¸

âœ… **JSON æ ¼å¼éªŒè¯é€šè¿‡**
- æ‰€æœ‰é…ç½®æ–‡ä»¶æ ¼å¼æ­£ç¡®
- è½¬ä¹‰å­—ç¬¦å¤„ç†æ­£ç¡®
- åµŒå¥—ç»“æ„ç¬¦åˆè§„èŒƒ

## å½“å‰åŠŸèƒ½çŠ¶æ€

- âœ… SessionStart hook (startup/resume)
- âœ… StatusLine æ˜¾ç¤ºä¼˜åŒ–
- âœ… Notification æ—¥å¿—è®°å½•
- âœ… MCP æœåŠ¡å™¨é…ç½®ä¿æŒä¸å˜
- âœ… é¡¹ç›®æƒé™é…ç½®ä¿æŒä¸å˜

## åç»­å»ºè®®

1. **é‡å¯ Claude Code** ä»¥ä½¿æ–°çš„ hook é…ç½®ç”Ÿæ•ˆ
2. **è§‚å¯Ÿå¯åŠ¨æ¶ˆæ¯** ç¡®è®¤ SessionStart hook æ­£å¸¸å·¥ä½œ
3. **æµ‹è¯• StatusLine** åœ¨ä¸åŒç›®å½•ä¸‹çš„æ˜¾ç¤ºæ•ˆæœ
4. **æ£€æŸ¥é€šçŸ¥æ—¥å¿—** éªŒè¯ Notification hook åŠŸèƒ½

## é…ç½®æ–‡ä»¶ä½ç½®

- å…¨å±€é…ç½®: `~/.claude/settings.json`
- é¡¹ç›®é…ç½®: `.claude/settings.local.json`
- é€šçŸ¥æ—¥å¿—: `~/.claude/notification_log.txt`

---
*ä¿®å¤å®Œæˆæ—¶é—´: $(date)*
*æµ‹è¯•çŠ¶æ€: å…¨éƒ¨é€šè¿‡*
```

`claude-model-switcher/docs/deepseek-anthropic-api.md`:

```md
# DeepSeek Anthropic API Documentation

*Downloaded from: https://api-docs.deepseek.com/guides/anthropic_api*
*Download date: 2025-08-21*

---

## Overview

To meet the demand for using the Anthropic API ecosystem, our API has added support for the Anthropic API format. With simple configuration, you can integrate the capabilities of DeepSeek into the Anthropic API ecosystem.

## Use DeepSeek in Claude Code

### 1. Install Claude Code

```bash
npm install -g @anthropic-ai/claude-code
```

### 2. Config Environment Variables

```bash
export ANTHROPIC_BASE_URL=https://api.deepseek.com/anthropic
export ANTHROPIC_AUTH_TOKEN=${YOUR_API_KEY}
export ANTHROPIC_MODEL=deepseek-chat
export ANTHROPIC_SMALL_FAST_MODEL=deepseek-chat
```

### 3. Enter the Project Directory, and Execute Claude Code

```bash
cd my-project
claude
```

## Invoke DeepSeek Model via Anthropic API

### 1. Install Anthropic SDK

```bash
pip install anthropic
```

### 2. Config Environment Variables

```bash
export ANTHROPIC_BASE_URL=https://api.deepseek.com/anthropic
export ANTHROPIC_API_KEY=${DEEPSEEK_API_KEY}
```

### 3. Invoke the API

```python
import anthropic

client = anthropic.Anthropic()
message = client.messages.create(
    model="deepseek-chat",
    max_tokens=1000,
    system="You are a helpful assistant.",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Hi, how are you?"
                }
            ]
        }
    ]
)
print(message.content)
```

## Anthropic API Compatibility Details

| Field | Support Status |
|-------|----------------|
| anthropic-beta | Ignored |
| anthropic-version | Ignored |
| x-api-key | Fully Supported |

### Simple Fields

| Field | Support Status |
|-------|----------------|
| model | Use DeepSeek Model Instead |
| max_tokens | Fully Supported |
| container | Ignored |
| mcp_servers | Ignored |
| metadata | Ignored |
| service_tier | Ignored |
| stop_sequences | Fully Supported |
| stream | Fully Supported |
| system | Fully Supported |
| temperature | Fully Supported (range [0.0 ~ 2.0]) |
| thinking | Ignored |
| top_k | Ignored |
| top_p | Fully Supported |

### Tool Fields

#### tools

| Field | Support Status |
|-------|----------------|
| name | Fully Supported |
| input_schema | Fully Supported |
| description | Fully Supported |
| cache_control | Ignored |

#### tool_choice

| Value | Support Status |
|-------|----------------|
| none | Fully Supported |
| auto | Supported (`disable_parallel_tool_use` is ignored) |
| any | Supported (`disable_parallel_tool_use` is ignored) |
| tool | Supported (`disable_parallel_tool_use` is ignored) |

### Message Fields

| Field | Variant | Sub-Field | Support Status |
|-------|---------|-----------|----------------|
| content | string | | Fully Supported |
| | array, type="text" | text | Fully Supported |
| | | cache_control | Ignored |
| | | citations | Ignored |
| | array, type="image" | | Not Supported |
| | array, type="document" | | Not Supported |
| | array, type="search_result" | | Not Supported |
| | array, type="thinking" | | Fully Supported |
| | array, type="redacted_thinking" | | Not Supported |
| | array, type="tool_use" | id | Fully Supported |
| | | input | Fully Supported |
| | | name | Fully Supported |
| | | cache_control | Ignored |
| | array, type="tool_result" | tool_use_id | Fully Supported |
| | | content | Fully Supported |
| | | cache_control | Ignored |
| | | is_error | Ignored |
| | array, type="server_tool_use" | | Not Supported |
| | array, type="web_search_tool_result" | | Not Supported |
| | array, type="code_execution_tool_result" | | Not Supported |
| | array, type="mcp_tool_use" | | Not Supported |
| | array, type="mcp_tool_result" | | Not Supported |
| | array, type="container_upload" | | Not Supported |

## Quick Start Examples

### For Claude Code Users

```bash
# One-time setup
npm install -g @anthropic-ai/claude-code

# Set environment variables
export ANTHROPIC_BASE_URL=https://api.deepseek.com/anthropic
export ANTHROPIC_AUTH_TOKEN="your_deepseek_api_key_here"
export ANTHROPIC_MODEL=deepseek-chat

# Use in any project
cd your-project
claude
```

### For Python Developers

```python
import anthropic
import os

# Configure client
client = anthropic.Anthropic(
    base_url="https://api.deepseek.com/anthropic",
    api_key=os.environ.get("ANTHROPIC_API_KEY")
)

# Make a request
response = client.messages.create(
    model="deepseek-chat",
    max_tokens=1000,
    messages=[
        {
            "role": "user", 
            "content": "Hello, how can I use DeepSeek with Anthropic API?"
        }
    ]
)

print(response.content[0].text)
```

### For cURL Users

```bash
curl https://api.deepseek.com/anthropic/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: $ANTHROPIC_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "deepseek-chat",
    "max_tokens": 1000,
    "messages": [
      {
        "role": "user",
        "content": "Hello, DeepSeek!"
      }
    ]
  }'
```

## Important Notes

- **Model Specification**: Use `deepseek-chat` as the model name
- **Base URL**: Always use `https://api.deepseek.com/anthropic` 
- **Authentication**: Use your DeepSeek API key
- **Compatibility**: Most Anthropic API features are supported, but some advanced features may be ignored
- **Temperature Range**: Supported range is [0.0 ~ 2.0]

## Unsupported Features

The following Anthropic API features are currently not supported:

- Image processing (array, type="image")
- Document processing (array, type="document")  
- Search results (array, type="search_result")
- Redacted thinking (array, type="redacted_thinking")
- Server tool use (array, type="server_tool_use")
- Web search tool results (array, type="web_search_tool_result")
- Code execution tool results (array, type="code_execution_tool_result")
- MCP tool use and results
- Container upload functionality
- Cache control features
- Citations feature

---

MODEL	deepseek-chat	deepseek-reasoner
MODEL VERSION	DeepSeek-V3.1 (Non-thinking Mode)	DeepSeek-V3.1 (Thinking Mode)
CONTEXT LENGTH	128K
MAX OUTPUT	DEFAULT: 4K
MAXIMUM: 8K	DEFAULT: 32K
MAXIMUM: 64K
FEATURES	Json Output	âœ“	âœ“
Function Calling	âœ“	âœ—(1)
Chat Prefix Completionï¼ˆBetaï¼‰	âœ“	âœ“
FIM Completionï¼ˆBetaï¼‰	âœ“	âœ—
```

`claude-model-switcher/docs/deepseek-function-calling.md`:

```md
# DeepSeek Function Calling Documentation

*Downloaded from: https://api-docs.deepseek.com/guides/function_calling*
*Download date: 2025-08-21*

---

## Overview

Function Calling allows the model to call external tools to enhance its capabilities.

## Sample Code

Here is an example of using Function Calling to get the current weather information of the user's location, demonstrated with complete Python code.

For the specific API format of Function Calling, please refer to the Chat Completion documentation.

```python
from openai import OpenAI

def send_messages(messages):
    response = client.chat.completions.create(
        model="deepseek-chat",
        messages=messages,
        tools=tools
    )
    return response.choices[0].message

client = OpenAI(
    api_key="<your api key>",
    base_url="https://api.deepseek.com",
)

tools = [
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "Get weather of an location, the user shoud supply a location first",
            "parameters": {
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "The city and state, e.g. San Francisco, CA",
                    }
                },
                "required": ["location"]
            },
        }
    },
]

messages = [{"role": "user", "content": "How's the weather in Hangzhou?"}]
message = send_messages(messages)
print(f"User>\t {messages[0]['content']}")

tool = message.tool_calls[0]
messages.append(message)
messages.append({"role": "tool", "tool_call_id": tool.id, "content": "24â„ƒ"})
message = send_messages(messages)
print(f"Model>\t {message.content}")
```

### Execution Flow

1. **User**: Asks about the current weather in Hangzhou
2. **Model**: Returns the function `get_weather({location: 'Hangzhou'})`
3. **User**: Calls the function `get_weather({location: 'Hangzhou'})` and provides the result to the model
4. **Model**: Returns in natural language, "The current temperature in Hangzhou is 24Â°C."

> **Note**: In the above code, the functionality of the `get_weather` function needs to be provided by the user. The model itself does not execute specific functions.

---

## `strict` Mode (Beta)

In `strict` mode, the model strictly adheres to the format requirements of the Function's JSON schema when outputting a Function call, ensuring that the model's output complies with the user's definition.

### Requirements

To use `strict` mode, you need to:

1. Use `base_url="https://api.deepseek.com/beta"` to enable Beta features
2. In the `tools` parameter, all `function` need to set the `strict` property to `true`
3. The server will validate the JSON Schema of the Function provided by the user. If the schema does not conform to the specifications or contains JSON schema types that are not supported by the server, an error message will be returned

### Example Tool Definition in `strict` Mode

```json
{
    "type": "function",
    "function": {
        "name": "get_weather",
        "strict": true,
        "description": "Get weather of an location, the user shoud supply a location first",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The city and state, e.g. San Francisco, CA",
                }
            },
            "required": ["location"],
            "additionalProperties": false
        }
    }
}
```

---

## Support Json Schema Types In `strict` Mode

- object
- string
- number
- integer
- boolean
- array
- enum
- anyOf

---

### object

The `object` defines a nested structure containing key-value pairs, where `properties` specifies the schema for each key (or property) within the object. **All properties of every `object` must be set as `required`, and the `additionalProperties` attribute of the `object` must be set to `false`.**

#### Example

```json
{
    "type": "object",
    "properties": {
        "name": { "type": "string" },
        "age": { "type": "integer" }
    },
    "required": ["name", "age"],
    "additionalProperties": false
}
```

---

### string

#### Supported Parameters

- `pattern`: Uses regular expressions to constrain the format of the string
- `format`: Validates the string against predefined common formats. Currently supported formats:
  - `email`: Email address
  - `hostname`: Hostname
  - `ipv4`: IPv4 address
  - `ipv6`: IPv6 address
  - `uuid`: UUID

#### Unsupported Parameters

- `minLength`
- `maxLength`

#### Example

```json
{
    "type": "object",
    "properties": {
        "user_email": {
            "type": "string",
            "description": "The user's email address",
            "format": "email"
        },
        "zip_code": {
            "type": "string",
            "description": "Six digit postal code",
            "pattern": "^\\d{6}$"
        }
    }
}
```

---

### number/integer

#### Supported Parameters

- `const`: Specifies a constant numeric value
- `default`: Defines the default value of the number
- `minimum`: Specifies the minimum value
- `maximum`: Specifies the maximum value
- `exclusiveMinimum`: Defines a value that the number must be greater than
- `exclusiveMaximum`: Defines a value that the number must be less than
- `multipleOf`: Ensures that the number is a multiple of the specified value

#### Example

```json
{
    "type": "object",
    "properties": {
        "score": {
            "type": "integer",
            "description": "A number from 1-5, which represents your rating, the higher, the better",
            "minimum": 1,
            "maximum": 5
        }
    },
    "required": ["score"],
    "additionalProperties": false
}
```

---

### array

#### Unsupported Parameters

- minItems
- maxItems

#### Example

```json
{
    "type": "object",
    "properties": {
        "keywords": {
            "type": "array",
            "description": "Five keywords of the article, sorted by importance",
            "items": {
                "type": "string",
                "description": "A concise and accurate keyword or phrase."
            }
        }
    },
    "required": ["keywords"],
    "additionalProperties": false
}
```

---

### enum

The `enum` ensures that the output is one of the predefined options. For example, in the case of order status, it can only be one of a limited set of specified states.

#### Example

```json
{
    "type": "object",
    "properties": {
        "order_status": {
            "type": "string",
            "description": "Ordering status",
            "enum": ["pending", "processing", "shipped", "cancelled"]
        }
    }
}
```

---

### anyOf

Matches any one of the provided schemas, allowing fields to accommodate multiple valid formats. For example, a user's account could be either an email address or a phone number:

#### Example

```json
{
    "type": "object",
    "properties": {
        "account": {
            "anyOf": [
                { 
                    "type": "string", 
                    "format": "email", 
                    "description": "å¯ä»¥æ˜¯ç”µå­é‚®ä»¶åœ°å€" 
                },
                { 
                    "type": "string", 
                    "pattern": "^\\d{11}$", 
                    "description": "æˆ–11ä½æ‰‹æœºå·ç " 
                }
            ]
        }
    }
}
```

---

### $ref and $def

You can use `$def` to define reusable modules and then use `$ref` to reference them, reducing schema repetition and enabling modularization. Additionally, `$ref` can be used independently to define recursive structures.

#### Example

```json
{
    "type": "object",
    "properties": {
        "report_date": {
            "type": "string",
            "description": "The date when the report was published"
        },
        "authors": {
            "type": "array",
            "description": "The authors of the report",
            "items": {
                "$ref": "#/$def/author"
            }
        }
    },
    "required": ["report_date", "authors"],
    "additionalProperties": false,
    "$def": {
        "authors": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "author's name"
                },
                "institution": {
                    "type": "string",
                    "description": "author's institution"
                },
                "email": {
                    "type": "string",
                    "format": "email",
                    "description": "author's email"
                }
            },
            "additionalProperties": false,
            "required": ["name", "institution", "email"]
        }
    }
}
```

---

## Quick Setup Examples

### Standard Function Calling

```python
from openai import OpenAI

client = OpenAI(
    api_key="your-api-key",
    base_url="https://api.deepseek.com"
)

response = client.chat.completions.create(
    model="deepseek-chat",
    messages=[{"role": "user", "content": "What's the weather in Tokyo?"}],
    tools=[{
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "Get weather for a location",
            "parameters": {
                "type": "object",
                "properties": {
                    "location": {"type": "string"}
                },
                "required": ["location"]
            }
        }
    }]
)
```

### Strict Mode Function Calling

```python
from openai import OpenAI

client = OpenAI(
    api_key="your-api-key",
    base_url="https://api.deepseek.com/beta"  # Note: beta endpoint
)

response = client.chat.completions.create(
    model="deepseek-chat",
    messages=[{"role": "user", "content": "Calculate 15% of 200"}],
    tools=[{
        "type": "function",
        "function": {
            "name": "calculate_percentage",
            "strict": True,  # Enable strict mode
            "description": "Calculate percentage of a number",
            "parameters": {
                "type": "object",
                "properties": {
                    "percentage": {
                        "type": "number",
                        "description": "Percentage to calculate",
                        "minimum": 0,
                        "maximum": 100
                    },
                    "number": {
                        "type": "number",
                        "description": "Base number"
                    }
                },
                "required": ["percentage", "number"],
                "additionalProperties": False
            }
        }
    }]
)
```

## Key Benefits of Strict Mode

1. **Enhanced Reliability**: Ensures function calls exactly match your schema
2. **Type Safety**: Validates all parameters against defined types
3. **Better Error Handling**: Server-side validation catches schema issues
4. **Consistent Output**: Guarantees consistent function call formatting

## Important Notes

- **Beta Feature**: Strict mode is currently in beta and requires the beta endpoint
- **Schema Validation**: The server validates your JSON Schema and returns errors for unsupported types
- **Required Properties**: In strict mode, all object properties must be listed as required
- **No Additional Properties**: `additionalProperties` must be set to `false` for all objects

---

*This documentation was downloaded from DeepSeek API docs and saved locally for reference.*
```

`claude-model-switcher/docs/deepseek-pricing.md`:

```md
# DeepSeek Models & Pricing Documentation

*Downloaded from: https://api-docs.deepseek.com/quick_start/pricing*
*Download date: 2025-08-21*

---

## Overview

The prices listed below are in units of per 1M tokens. A token, the smallest unit of text that the model recognizes, can be a word, a number, or even a punctuation mark. We will bill based on the total number of input and output tokens by the model.

## Model Details

| MODEL | deepseek-chat | deepseek-reasoner |
|-------|---------------|-------------------|
| **MODEL VERSION** | DeepSeek-V3.1 (Non-thinking Mode) | DeepSeek-V3.1 (Thinking Mode) |
| **CONTEXT LENGTH** | 128K | 128K |
| **MAX OUTPUT** | **DEFAULT**: 4K<br>**MAXIMUM**: 8K | **DEFAULT**: 32K<br>**MAXIMUM**: 64K |
| **FEATURES** | | |
| &nbsp;&nbsp;Json Output | âœ“ | âœ“ |
| &nbsp;&nbsp;Function Calling | âœ“ | âœ—(1) |
| &nbsp;&nbsp;Chat Prefix Completionï¼ˆBetaï¼‰ | âœ“ | âœ“ |
| &nbsp;&nbsp;FIM Completionï¼ˆBetaï¼‰ | âœ“ | âœ— |

> **(1) Note**: If the request to the `deepseek-reasoner` model includes the `tools` parameter, the request will actually be processed using the `deepseek-chat` model.

## Pricing Details

### New Pricing (Effective September 5th, 2025 at 16:00 UTC)

Starting from 16:00 UTC Time on Sept 5th, 2025, we will apply the following price list and cancel the nighttime discount:

| MODEL | deepseek-chat | deepseek-reasoner |
|-------|---------------|-------------------|
| **1M INPUT TOKENS (CACHE HIT)** | $0.07 | $0.07 |
| **1M INPUT TOKENS (CACHE MISS)** | $0.56 | $0.56 |
| **1M OUTPUT TOKENS** | $1.68 | $1.68 |

### Current Pricing (Until September 5th, 2025 at 16:00 UTC)

The current price list will remain in effect until 16:00 UTC Time on Sept 5th, 2025:

| MODEL | deepseek-chat | deepseek-reasoner |
|-------|---------------|-------------------|
| **STANDARD PRICE**<br>ï¼ˆUTC 00:30-16:30ï¼‰ | | |
| &nbsp;&nbsp;1M INPUT TOKENS (CACHE HIT) | $0.07 | $0.14 |
| &nbsp;&nbsp;1M INPUT TOKENS (CACHE MISS) | $0.27 | $0.55 |
| &nbsp;&nbsp;1M OUTPUT TOKENS | $1.10 | $2.19 |
| **DISCOUNT PRICE**<br>ï¼ˆUTC 16:30-00:30ï¼‰ | | |
| &nbsp;&nbsp;1M INPUT TOKENS (CACHE HIT) | $0.035 | $0.035 |
| &nbsp;&nbsp;1M INPUT TOKENS (CACHE MISS) | $0.135 | $0.135 |
| &nbsp;&nbsp;1M OUTPUT TOKENS | $0.550 | $0.550 |

## Deduction Rules

The expense = number of tokens Ã— price. The corresponding fees will be directly deducted from your topped-up balance or granted balance, with a preference for using the granted balance first when both balances are available.

Product prices may vary and DeepSeek reserves the right to adjust them. We recommend topping up based on your actual usage and regularly checking this page for the most recent pricing information.

---

## Key Information Summary

### Model Comparison

**deepseek-chat**:
- Non-thinking mode
- 8K max output
- Full feature support (Function Calling, FIM Completion)
- Lower pricing

**deepseek-reasoner**:
- Thinking mode
- 64K max output (8x more than chat)
- Limited feature support (no Function Calling, no FIM)
- Higher pricing (except after Sept 5th)

### Pricing Timeline

- **Until Sept 5th, 2025**: Discount pricing during UTC 16:30-00:30
- **After Sept 5th, 2025**: Unified pricing, no nighttime discount
- **Cache Hit**: Significantly cheaper than cache miss
- **Output Tokens**: Generally more expensive than input tokens

### Cost Optimization Tips

1. **Use Cache**: Cache hits are much cheaper (up to 8x savings)
2. **Time Usage**: Until Sept 5th, use during UTC 16:30-00:30 for discount
3. **Model Selection**: Use `deepseek-chat` for function calling needs
4. **Output Management**: Monitor output tokens as they cost more

### Token Estimation

- 1 token â‰ˆ 4 characters in English
- 1 token â‰ˆ 1-2 words in English
- 1000 tokens â‰ˆ 750 words
- Cache hits can reduce costs by up to 87.5%

---

*This documentation was downloaded from DeepSeek API docs and saved locally for reference.*
```

`claude-model-switcher/docs/moonshot.md`:

```md

æ¨¡å‹
è®¡è´¹å•ä½
è¾“å…¥ä»·æ ¼
ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰
è¾“å…¥ä»·æ ¼
ï¼ˆç¼“å­˜æœªå‘½ä¸­ï¼‰
è¾“å‡ºä»·æ ¼
æ¨¡å‹ä¸Šä¸‹æ–‡é•¿åº¦
kimi-k2-0711-preview	1M tokens	ï¿¥1.00	ï¿¥4.00	ï¿¥16.00	131,072 tokens
kimi-k2-turbo-preview	1M tokens	ï¿¥4.00	ï¿¥16.00	ï¿¥64.00	131,072 tokens
kimi-k2 æ˜¯ä¸€æ¬¾å…·å¤‡è¶…å¼ºä»£ç å’Œ Agent èƒ½åŠ›çš„ MoE æ¶æ„åŸºç¡€æ¨¡å‹ï¼Œæ€»å‚æ•° 1Tï¼Œæ¿€æ´»å‚æ•° 32Bã€‚åœ¨é€šç”¨çŸ¥è¯†æ¨ç†ã€ç¼–ç¨‹ã€æ•°å­¦ã€Agent ç­‰ä¸»è¦ç±»åˆ«çš„åŸºå‡†æ€§èƒ½æµ‹è¯•ä¸­ï¼ŒK2 æ¨¡å‹çš„æ€§èƒ½è¶…è¿‡å…¶ä»–ä¸»æµå¼€æºæ¨¡å‹
kimi-k2-turbo-preview æ¨¡å‹æ˜¯ kimi-k2 çš„é«˜é€Ÿç‰ˆï¼Œæ¨¡å‹å‚æ•°ä¸ kimi-k2 ä¸€è‡´ï¼Œä½†è¾“å‡ºé€Ÿåº¦ç”±æ¯ç§’ 10 Tokens æå‡è‡³æ¯ç§’ 40 Tokens
kimi-k2 æ¨¡å‹ä¸Šä¸‹æ–‡é•¿åº¦ä¸º 128k
ä¸æ”¯æŒè§†è§‰åŠŸèƒ½
æ”¯æŒ ToolCallsã€JSON Modeã€Partial Modeã€è”ç½‘æœç´¢åŠŸèƒ½ç­‰
```

`claude-model-switcher/docs/statusline-configuration-complete.md`:

```md
# StatusLine é…ç½®å®ŒæˆæŠ¥å‘Š

## âœ… é…ç½®çŠ¶æ€ï¼šæˆåŠŸå®Œæˆ

### ğŸ¯ å®ç°çš„åŠŸèƒ½

æ‚¨çš„ Claude Code ç°åœ¨é…å¤‡äº†ä¿¡æ¯ä¸°å¯Œçš„ statusLineï¼ŒåŒ…å«ä»¥ä¸‹ç‰¹æ€§ï¼š

#### 1. **ç”¨æˆ·å’Œä¸»æœºä¿¡æ¯** (ç»¿è‰²)
- æ ¼å¼ï¼š`[user@host:path]`
- æ˜¾ç¤ºå½“å‰ç”¨æˆ·å’Œä¸»æœºå
- ä½¿ç”¨ç»¿è‰²çªå‡ºæ˜¾ç¤º

#### 2. **å½“å‰å·¥ä½œç›®å½•** (è“è‰²)
- æ˜¾ç¤ºå®Œæ•´è·¯å¾„ï¼Œå®¶ç›®å½•ç”¨ `~` æ›¿ä»£
- ä½¿ç”¨è“è‰²çªå‡ºæ˜¾ç¤º

#### 3. **Git åˆ†æ”¯ä¿¡æ¯** (é»„è‰²)
- ä»…åœ¨ Git ä»“åº“ä¸­æ˜¾ç¤º
- æ˜¾ç¤ºå½“å‰åˆ†æ”¯åç§°
- ä½¿ç”¨é»„è‰²çªå‡ºæ˜¾ç¤º

#### 4. **æ¨¡å‹ä¿¡æ¯** (é’è‰²)
- æ˜¾ç¤ºå½“å‰ä½¿ç”¨çš„ AI æ¨¡å‹
- åŒ…å« ğŸ¤– å›¾æ ‡
- ä½¿ç”¨é’è‰²çªå‡ºæ˜¾ç¤º

#### 5. **MCP æœåŠ¡å™¨çŠ¶æ€** (ç´«è‰²)
- ğŸ“ æ–‡ä»¶ç³»ç»ŸæœåŠ¡å™¨ï¼ˆå§‹ç»ˆå¯ç”¨ï¼‰
- ğŸ” Jina AI æœåŠ¡å™¨ï¼ˆå½“ JINA_API_KEY è®¾ç½®æ—¶ï¼‰
- ğŸ™ GitHub æœåŠ¡å™¨ï¼ˆå½“ GITHUB_TOKEN è®¾ç½®æ—¶ï¼‰
- ğŸ” Brave Search æœåŠ¡å™¨ï¼ˆå½“ BRAVE_API_KEY è®¾ç½®æ—¶ï¼‰
- ä½¿ç”¨ç´«è‰²çªå‡ºæ˜¾ç¤º

### ğŸ“‹ å®é™…æ˜¾ç¤ºæ•ˆæœ

```
[root@kvm-hk2024hostpe:/www/claude-model-switcher] (main) ğŸ¤– glm-4.5 |ğŸ“ğŸ”
```

### ğŸ”§ é…ç½®æ–‡ä»¶

1. **ä¸»é…ç½®æ–‡ä»¶**: `/root/.claude/settings.json`
   - statusLine æŒ‡å‘ `/root/.claude/statusline-command.sh`

2. **StatusLine è„šæœ¬**: `/root/.claude/statusline-command.sh`
   - å®Œæ•´çš„çŠ¶æ€è¡Œç”Ÿæˆè„šæœ¬
   - åŒ…å«é¢œè‰²ã€å›¾æ ‡å’ŒåŠ¨æ€ä¿¡æ¯

### ğŸ§ª æµ‹è¯•ç»“æœ

âœ… **è„šæœ¬è¯­æ³•æ£€æŸ¥**: é€šè¿‡
âœ… **åŠŸèƒ½æµ‹è¯•**: é€šè¿‡
âœ… **é¢œè‰²æ˜¾ç¤º**: æ­£å¸¸
âœ… **Git åˆ†æ”¯æ£€æµ‹**: æ­£å¸¸
âœ… **MCP æœåŠ¡å™¨çŠ¶æ€**: æ­£å¸¸
âœ… **è·¯å¾„æ˜¾ç¤º**: æ­£å¸¸

### ğŸš€ ä½¿ç”¨æ–¹æ³•

1. **é‡å¯ Claude Code** ä»¥åº”ç”¨æ–°é…ç½®
2. **çŠ¶æ€è¡Œå°†è‡ªåŠ¨æ˜¾ç¤º** åœ¨ Claude Code ç•Œé¢ä¸­
3. **åŠ¨æ€æ›´æ–°** ä¼šæ ¹æ®å½“å‰ç¯å¢ƒè‡ªåŠ¨è°ƒæ•´

### ğŸ¨ é¢œè‰²æ–¹æ¡ˆ

- ğŸŸ¢ **ç»¿è‰²**: ç”¨æˆ·å’Œä¸»æœºä¿¡æ¯
- ğŸ”µ **è“è‰²**: å½“å‰ç›®å½•è·¯å¾„
- ğŸŸ¡ **é»„è‰²**: Git åˆ†æ”¯ä¿¡æ¯
- ğŸ”µ **é’è‰²**: AI æ¨¡å‹ä¿¡æ¯
- ğŸŸ£ **ç´«è‰²**: MCP æœåŠ¡å™¨çŠ¶æ€

### ğŸ“ ç‰¹æ®ŠåŠŸèƒ½

1. **æ™ºèƒ½æ˜¾ç¤º**: åªæ˜¾ç¤ºç›¸å…³ä¿¡æ¯ï¼ˆå¦‚åªåœ¨ Git ä»“åº“ä¸­æ˜¾ç¤ºåˆ†æ”¯ï¼‰
2. **è·¯å¾„ä¼˜åŒ–**: è‡ªåŠ¨å°†å®¶ç›®å½•æ˜¾ç¤ºä¸º `~`
3. **ç¯å¢ƒæ„ŸçŸ¥**: è‡ªåŠ¨æ£€æµ‹å¯ç”¨çš„ MCP æœåŠ¡å™¨
4. **é”™è¯¯å¤„ç†**: å³ä½¿æŸäº›å‘½ä»¤å¤±è´¥ä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ

### ğŸ”® æœªæ¥æ‰©å±•

å¦‚éœ€è¿›ä¸€æ­¥è‡ªå®šä¹‰ï¼Œæ‚¨å¯ä»¥ï¼š
- ä¿®æ”¹é¢œè‰²æ–¹æ¡ˆ
- æ·»åŠ æ›´å¤šä¿¡æ¯ï¼ˆå¦‚ç³»ç»Ÿè´Ÿè½½ã€æ—¶é—´ç­‰ï¼‰
- è°ƒæ•´å›¾æ ‡å’Œæ ¼å¼
- æ·»åŠ é¡¹ç›®ç‰¹å®šçš„çŠ¶æ€ä¿¡æ¯

---
*é…ç½®å®Œæˆæ—¶é—´: $(date)*
*çŠ¶æ€: âœ… å…¨éƒ¨åŠŸèƒ½æ­£å¸¸å·¥ä½œ*
```

`claude-model-switcher/install.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Simplified Installation Script
# Version 5.0.0 - Modular Architecture
# This script bootstraps the modular installation system

set -e

# Script metadata
SCRIPT_VERSION="5.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_TARGET="$HOME/.claude/claude-model-switcher"

# Simple logging for bootstrap
log_info() {
    echo "â„¹ï¸  $1"
}

log_success() {
    echo "âœ… $1"
}

log_error() {
    echo "âŒ $1"
}

log_progress() {
    echo "ğŸš€ $1"
}

# Bootstrap installation
bootstrap_install() {
    log_info "Claude Model Switcher v$SCRIPT_VERSION - Modular Installation"
    echo "================================================================="
    
    # Check if we're running from the correct location
    if [ ! -f "$SCRIPT_DIR/main.sh" ]; then
        log_error "main.sh not found. Please ensure you're running from the correct directory."
        exit 1
    fi
    
    # Check if already installed
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_info "Existing installation detected at: $INSTALL_TARGET"
        echo -n "Do you want to update the existing installation? [y/N]: "
        read -r update_choice
        
        case "$update_choice" in
            [yY]|[yY][eS]|[yY][eE][sS])
                log_progress "Updating existing installation..."
                ;;
            *)
                log_info "Installation cancelled by user"
                exit 0
                ;;
        esac
    fi
    
    # Create installation directory
    log_progress "Creating installation directory: $INSTALL_TARGET"
    mkdir -p "$INSTALL_TARGET"
    
    # Copy all files to installation directory
    log_progress "Copying modular system files..."
    cp -r "$SCRIPT_DIR"/* "$INSTALL_TARGET/"
    
    # Make scripts executable
    chmod +x "$INSTALL_TARGET/main.sh"
    chmod +x "$INSTALL_TARGET/tests/test_runner.sh"
    
    log_success "Modular system files copied successfully"
    
    # Run the modular installation
    log_progress "Running modular installation process..."
    cd "$INSTALL_TARGET"
    
    if ./main.sh install; then
        log_success "Installation completed successfully!"
        echo ""
        log_info "The modular system is now installed at: $INSTALL_TARGET"
        log_info "You can manage it using: $INSTALL_TARGET/main.sh [command]"
        echo ""
        log_info "Quick start:"
        log_info "1. Source your shell configuration: source ~/.bashrc"
        log_info "2. List models: list_models"
        log_info "3. Use a model: use_model kimi"
    else
        log_error "Installation failed!"
        exit 1
    fi
}

# Uninstall function
uninstall() {
    log_info "Uninstalling Claude Model Switcher..."
    
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_progress "Running modular uninstallation..."
        cd "$INSTALL_TARGET"
        ./main.sh uninstall
    else
        log_info "Modular system not found, cleaning up manually..."
        
        # Manual cleanup for legacy installations
        local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
        for shell_file in "${shell_files[@]}"; do
            if [ -f "$shell_file" ] && grep -q "CLAUDE_CODE_MODEL_MANAGER" "$shell_file"; then
                log_progress "Cleaning shell configuration: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.cleanup_backup.$(date +%Y%m%d_%H%M%S)"
                # Remove old configuration blocks (both V4 and V5)
                sed -i '/# CLAUDE_CODE_MODEL_MANAGER/,/# END_OF_CLAUDE_CONFIG/d' "$shell_file"
            fi
        done
        
        # Remove installation directory
        if [ -d "$INSTALL_TARGET" ]; then
            rm -rf "$INSTALL_TARGET"
            log_success "Installation directory removed"
        fi
        
        # Remove parent directory if empty
        local parent_dir
        parent_dir=$(dirname "$INSTALL_TARGET")
        if [ -d "$parent_dir" ] && [ -z "$(ls -A "$parent_dir" 2>/dev/null)" ]; then
            rmdir "$parent_dir"
        fi
    fi
    
    log_success "Uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Show help
show_help() {
    cat << EOF
Claude Model Switcher v$SCRIPT_VERSION - Installation Script

USAGE:
    $0 [OPTION]

OPTIONS:
    (no option)    Install or update Claude Model Switcher
    --uninstall    Remove Claude Model Switcher completely
    --help         Show this help message

DESCRIPTION:
    This script installs the modular Claude Model Switcher system.
    The system will be installed to: $INSTALL_TARGET

FEATURES:
    â€¢ Modular architecture with clean separation of concerns
    â€¢ Configuration-driven (no hardcoded values)
    â€¢ Comprehensive test suite with TDD/BDD support
    â€¢ Support for multiple AI model providers
    â€¢ Automatic shell integration
    â€¢ Safe installation with backups

EXAMPLES:
    $0                 # Install or update
    $0 --uninstall     # Complete removal
    $0 --help          # Show this help

After installation, you can use:
    list_models        # List available models
    use_model <alias>  # Switch to a model
    
Or use the full CLI:
    $INSTALL_TARGET/main.sh [command]

EOF
}

# Main execution
main() {
    local command="${1:-install}"
    
    case "$command" in
        "install"|"")
            bootstrap_install
            ;;
        "--uninstall")
            uninstall
            ;;
        "--help"|"-h")
            show_help
            ;;
        *)
            log_error "Unknown option: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"

```

`claude-model-switcher/lib/core/config_loader.sh`:

```sh
#!/bin/bash

# Configuration Loader Module
# Handles loading and validation of configuration files

# Source the logger
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Global configuration variables
declare -A CONFIG_CACHE
declare -A CONFIG_FILE_TIMESTAMPS

# Load a configuration file
config_load() {
    local config_file="$1"
    local force_reload="${2:-false}"
    local config_name="${3:-$(basename "$config_file" .conf)}"
    
    if [ ! -f "$config_file" ]; then
        log_error "Configuration file not found: $config_file"
        return 1
    fi
    
    # Check if we need to reload based on file modification time
    local current_timestamp
    current_timestamp=$(stat -c %Y "$config_file" 2>/dev/null || echo "0")
    local cached_timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]:-0}"
    
    if [ "$force_reload" = "true" ] || [ "$current_timestamp" -gt "$cached_timestamp" ]; then
        log_debug "Loading configuration: $config_file"
        
        # Validate configuration file syntax
        if ! config_validate_syntax "$config_file"; then
            log_error "Configuration file has syntax errors: $config_file"
            return 1
        fi
        
        # Pre-declare associative arrays for models.conf
        if [[ "$config_file" == *"models.conf" ]]; then
            declare -gA MODEL_PROVIDERS 2>/dev/null || true
            declare -gA MODEL_API_NAMES 2>/dev/null || true
            declare -gA MODEL_CONTEXTS 2>/dev/null || true
            declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
            declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
            declare -gA MODEL_CAPABILITIES 2>/dev/null || true
        fi
        
        # Source the configuration file
        if source "$config_file"; then
            CONFIG_FILE_TIMESTAMPS[$config_name]="$current_timestamp"
            CONFIG_CACHE[$config_name]="loaded"
            log_debug "Configuration loaded successfully: $config_name"
            return 0
        else
            log_error "Failed to load configuration: $config_file"
            return 1
        fi
    else
        log_debug "Configuration already loaded and up-to-date: $config_name"
        return 0
    fi
}

# Validate configuration file syntax
config_validate_syntax() {
    local config_file="$1"
    
    # Basic shell syntax check
    if ! bash -n "$config_file" 2>/dev/null; then
        log_error "Shell syntax error in configuration file: $config_file"
        return 1
    fi
    
    # Check for required variables based on file type
    local filename=$(basename "$config_file")
    case "$filename" in
        "app.conf")
            config_validate_app_config "$config_file"
            ;;
        "models.conf")
            config_validate_models_config "$config_file"
            ;;
        "providers.conf")
            config_validate_providers_config "$config_file"
            ;;
        *)
            log_debug "No specific validation rules for: $filename"
            return 0
            ;;
    esac
}

# Validate app configuration
config_validate_app_config() {
    local config_file="$1"
    local required_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    # Source config in a subshell to check variables
    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$config_file"; then
            log_error "Required variable '$var' not found in $config_file"
            return 1
        fi
    done
    
    log_debug "App configuration validation passed"
    return 0
}

# Validate models configuration
config_validate_models_config() {
    local config_file="$1"
    
    # Check for model assignments (arrays are declared externally)
    if ! grep -q "MODEL_PROVIDERS\[" "$config_file"; then
        log_error "No MODEL_PROVIDERS assignments found in $config_file"
        return 1
    fi
    
    if ! grep -q "MODEL_API_NAMES\[" "$config_file"; then
        log_error "No MODEL_API_NAMES assignments found in $config_file"
        return 1
    fi
    
    log_debug "Models configuration validation passed"
    return 0
}

# Validate providers configuration
config_validate_providers_config() {
    local config_file="$1"
    
    # Check for at least one provider configuration
    if ! grep -q "PROVIDER_.*_BASE_URL=" "$config_file"; then
        log_error "No provider configurations found in $config_file"
        return 1
    fi
    
    log_debug "Providers configuration validation passed"
    return 0
}

# Load all configuration files
config_load_all() {
    local config_dir="${1:-$HOME/.claude/claude-model-switcher/config}"
    local force_reload="${2:-false}"
    
    if [ ! -d "$config_dir" ]; then
        log_error "Configuration directory not found: $config_dir"
        return 1
    fi
    
    log_progress "Loading all configuration files from: $config_dir"
    
    # Load configurations in order of dependency
    local config_files=(
        "$config_dir/app.conf"
        "$config_dir/providers.conf"
        "$config_dir/models.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            if ! config_load "$config_file" "$force_reload"; then
                log_error "Failed to load configuration: $config_file"
                return 1
            fi
        else
            log_warn "Configuration file not found (optional): $config_file"
        fi
    done
    
    log_success "All configuration files loaded successfully"
    return 0
}

# Get configuration value with fallback
config_get() {
    local var_name="$1"
    local default_value="$2"
    
    # Check if variable is set
    if [ -n "${!var_name}" ]; then
        echo "${!var_name}"
    else
        log_debug "Configuration variable '$var_name' not set, using default: $default_value"
        echo "$default_value"
    fi
}

# Set configuration value
config_set() {
    local var_name="$1"
    local value="$2"
    
    export "$var_name"="$value"
    log_debug "Configuration variable set: $var_name=$value"
}

# Check if configuration is loaded
config_is_loaded() {
    local config_name="$1"
    [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]
}

# Reload specific configuration
config_reload() {
    local config_name="$1"
    local config_dir="${2:-$HOME/.claude/claude-model-switcher/config}"
    
    config_load "$config_dir/${config_name}.conf" "true" "$config_name"
}

# List loaded configurations
config_list_loaded() {
    log_info "Loaded configurations:"
    for config_name in "${!CONFIG_CACHE[@]}"; do
        if [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]; then
            local timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]}"
            local date_str=$(date -d "@$timestamp" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
            log_indent info "$config_name (loaded at: $date_str)" 2
        fi
    done
}

# Validate current environment against configuration
config_validate_environment() {
    log_progress "Validating environment against configuration..."
    
    # Check bash version for associative arrays
    local bash_version="${BASH_VERSION%%.*}"
    if [ "$bash_version" -lt 4 ]; then
        log_error "Bash 4.0+ required for associative arrays. Current version: $BASH_VERSION"
        return 1
    fi
    
    # Check required directories
    local required_dirs=(
        "$SWITCHER_DIR"
        "$CONFIG_DIR"
        "$LIB_DIR"
        "$MEMORY_DIR"
        "$LOG_DIR"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ -n "$dir" ] && [ ! -d "$dir" ]; then
            log_warn "Required directory missing: $dir"
            mkdir -p "$dir" || {
                log_error "Failed to create directory: $dir"
                return 1
            }
            log_success "Created directory: $dir"
        fi
    done
    
    log_success "Environment validation completed"
    return 0
}


```

`claude-model-switcher/lib/core/logger.sh`:

```sh
#!/bin/bash

# Logger Module - Centralized logging functionality
# Supports different log levels and formatted output

# Initialize logger (should be called once)
logger_init() {
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    local log_file="${LOG_FILE:-$log_dir/installer.log}"
    
    # Ensure log directory exists
    mkdir -p "$log_dir"
    
    # Set global log file
    export LOGGER_FILE="$log_file"
    export LOGGER_LEVEL="${LOG_LEVEL:-INFO}"
    export LOGGER_USE_EMOJIS="${USE_EMOJIS:-true}"
    
    # Initialize log file with session header
    echo "=== New Session Started: $(date) ===" >> "$LOGGER_FILE"
}

# Get current timestamp
_get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Get emoji for log level
_get_emoji() {
    local level="$1"
    if [ "$LOGGER_USE_EMOJIS" != "true" ]; then
        echo ""
        return
    fi
    
    case "$level" in
        DEBUG) echo "ğŸ”" ;;
        INFO)  echo "â„¹ï¸" ;;
        WARN)  echo "âš ï¸" ;;
        ERROR) echo "âŒ" ;;
        SUCCESS) echo "âœ…" ;;
        PROGRESS) echo "ğŸš€" ;;
        *) echo "ğŸ“" ;;
    esac
}

# Check if log level should be printed
_should_log() {
    local level="$1"
    local current_level="${LOGGER_LEVEL:-INFO}"
    
    case "$current_level" in
        DEBUG) return 0 ;;
        INFO)  [[ "$level" =~ ^(INFO|WARN|ERROR|SUCCESS|PROGRESS)$ ]] ;;
        WARN)  [[ "$level" =~ ^(WARN|ERROR|SUCCESS)$ ]] ;;
        ERROR) [[ "$level" =~ ^(ERROR|SUCCESS)$ ]] ;;
        *) return 0 ;;
    esac
}

# Core logging function
_log() {
    local level="$1"
    local message="$2"
    local to_file="${3:-true}"
    local to_console="${4:-true}"
    
    if ! _should_log "$level"; then
        return 0
    fi
    
    local timestamp="$(_get_timestamp)"
    local emoji="$(_get_emoji "$level")"
    local formatted_message="[$timestamp] [$level] $message"
    local console_message="$emoji $message"
    
    # Log to file
    if [ "$to_file" = "true" ] && [ -n "$LOGGER_FILE" ]; then
        # Ensure log directory exists before writing
        local log_dir
        log_dir=$(dirname "$LOGGER_FILE")
        if [ ! -d "$log_dir" ]; then
            mkdir -p "$log_dir" 2>/dev/null || true
        fi
        
        # Only write to file if we can create/access the directory
        if [ -d "$log_dir" ] && [ -w "$log_dir" ]; then
            echo "$formatted_message" >> "$LOGGER_FILE" 2>/dev/null || true
        fi
    fi
    
    # Log to console
    if [ "$to_console" = "true" ]; then
        echo "$console_message"
    fi
}

# Public logging functions
log_debug() {
    _log "DEBUG" "$1" "${2:-true}" "${3:-true}"
}

log_info() {
    _log "INFO" "$1" "${2:-true}" "${3:-true}"
}

log_warn() {
    _log "WARN" "$1" "${2:-true}" "${3:-true}"
}

log_error() {
    _log "ERROR" "$1" "${2:-true}" "${3:-true}"
}

log_success() {
    _log "SUCCESS" "$1" "${2:-true}" "${3:-true}"
}

log_progress() {
    _log "PROGRESS" "$1" "${2:-true}" "${3:-true}"
}

# Special logging functions
log_separator() {
    local char="${1:--}"
    local width="${2:-50}"
    local message=""
    
    for ((i=1; i<=width; i++)); do
        message+="$char"
    done
    
    log_info "$message"
}

log_header() {
    local title="$1"
    local width="${2:-50}"
    
    log_separator "=" "$width"
    log_info "$title"
    log_separator "=" "$width"
}

# Log with indentation (for nested operations)
log_indent() {
    local level="$1"
    local message="$2"
    local indent="${3:-2}"
    
    local spaces=""
    for ((i=1; i<=indent; i++)); do
        spaces+=" "
    done
    
    case "$level" in
        debug) log_debug "$spaces$message" ;;
        info)  log_info "$spaces$message" ;;
        warn)  log_warn "$spaces$message" ;;
        error) log_error "$spaces$message" ;;
        success) log_success "$spaces$message" ;;
        progress) log_progress "$spaces$message" ;;
    esac
}

# Log command execution
log_command() {
    local cmd="$1"
    local show_output="${2:-false}"
    
    log_debug "Executing command: $cmd"
    
    if [ "$show_output" = "true" ]; then
        eval "$cmd" 2>&1 | while read -r line; do
            log_indent debug "$line" 4
        done
        return "${PIPESTATUS[0]}"
    else
        eval "$cmd" >/dev/null 2>&1
        return $?
    fi
}

# Cleanup old log files
log_cleanup() {
    local retention_days="${BACKUP_RETENTION_DAYS:-30}"
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    
    if [ -d "$log_dir" ]; then
        log_debug "Cleaning up log files older than $retention_days days"
        find "$log_dir" -name "*.log" -type f -mtime +"$retention_days" -delete 2>/dev/null || true
    fi
}


```

`claude-model-switcher/lib/core/validator.sh`:

```sh
#!/bin/bash

# Validator Module
# Provides validation functions for various inputs and system states

# Source dependencies
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Validate system requirements
validate_system_requirements() {
    log_progress "Validating system requirements..."
    
    local errors=0
    
    # Check operating system
    local os_name=$(uname -s)
    case "$os_name" in
        Linux|Darwin)
            log_success "Operating system supported: $os_name"
            ;;
        *)
            log_error "Unsupported operating system: $os_name"
            ((errors++))
            ;;
    esac
    
    # Check bash version
    local bash_major="${BASH_VERSION%%.*}"
    if [ "$bash_major" -ge 4 ]; then
        log_success "Bash version supported: $BASH_VERSION"
    else
        log_error "Bash 4.0+ required. Current version: $BASH_VERSION"
        ((errors++))
    fi
    
    # Check required commands
    local required_commands=("curl" "sed" "grep" "mkdir" "cp" "rm")
    for cmd in "${required_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            log_debug "Required command available: $cmd"
        else
            log_error "Required command not found: $cmd"
            ((errors++))
        fi
    done
    
    # Check write permissions for home directory
    if [ -w "$HOME" ]; then
        log_success "Home directory is writable: $HOME"
    else
        log_error "Home directory is not writable: $HOME"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All system requirements validated successfully"
        return 0
    else
        log_error "System requirements validation failed with $errors errors"
        return 1
    fi
}

# Validate Node.js installation
validate_nodejs() {
    local min_version="${1:-18}"
    
    log_debug "Validating Node.js installation (minimum version: $min_version)"
    
    if ! command -v node >/dev/null 2>&1; then
        log_warn "Node.js not found"
        return 1
    fi
    
    local current_version
    current_version=$(node -v 2>/dev/null | sed 's/v//')
    
    if [ -z "$current_version" ]; then
        log_error "Could not determine Node.js version"
        return 1
    fi
    
    local major_version
    major_version=$(echo "$current_version" | cut -d. -f1)
    
    if [ "$major_version" -ge "$min_version" ]; then
        log_success "Node.js version meets requirements: v$current_version (>= v$min_version)"
        return 0
    else
        log_warn "Node.js version too old: v$current_version (< v$min_version)"
        return 1
    fi
}

# Validate Claude Code installation
validate_claude_code() {
    log_debug "Validating Claude Code installation"
    
    if ! command -v claude >/dev/null 2>&1; then
        log_warn "Claude Code not found"
        return 1
    fi
    
    local version
    if version=$(claude --version 2>/dev/null); then
        log_success "Claude Code is installed: $version"
        return 0
    else
        log_error "Claude Code installation appears corrupted"
        return 1
    fi
}

# Validate model alias
validate_model_alias() {
    local alias="$1"
    
    if [ -z "$alias" ]; then
        log_error "Model alias cannot be empty"
        return 1
    fi
    
    # Check if alias contains only allowed characters
    if [[ ! "$alias" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Model alias contains invalid characters: $alias"
        log_info "Allowed characters: letters, numbers, underscore, hyphen"
        return 1
    fi
    
    # Check alias length
    if [ ${#alias} -gt 20 ]; then
        log_error "Model alias too long (max 20 characters): $alias"
        return 1
    fi
    
    log_debug "Model alias validation passed: $alias"
    return 0
}

# Validate provider name
validate_provider_name() {
    local provider="$1"
    local available_providers="${2:-$AVAILABLE_PROVIDERS}"
    
    if [ -z "$provider" ]; then
        log_error "Provider name cannot be empty"
        return 1
    fi
    
    # Check if provider is in the list of available providers
    if [[ " $available_providers " =~ " $provider " ]]; then
        log_debug "Provider validation passed: $provider"
        return 0
    else
        log_error "Unknown provider: $provider"
        log_info "Available providers: $available_providers"
        return 1
    fi
}

# Validate API key format
validate_api_key() {
    local api_key="$1"
    local provider="${2:-generic}"
    
    if [ -z "$api_key" ]; then
        log_error "API key cannot be empty"
        return 1
    fi
    
    # Check minimum length
    if [ ${#api_key} -lt 10 ]; then
        log_error "API key too short (minimum 10 characters)"
        return 1
    fi
    
    # Provider-specific validation
    case "$provider" in
        "moonshot")
            if [[ "$api_key" =~ ^sk-[a-zA-Z0-9]{40,}$ ]]; then
                log_debug "Moonshot API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Moonshot (expected: sk-...)"
                return 0  # Warning only, don't fail
            fi
            ;;
        "zhipu")
            if [[ "$api_key" =~ ^[a-zA-Z0-9]{32,}$ ]]; then
                log_debug "Zhipu API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Zhipu"
                return 0  # Warning only, don't fail
            fi
            ;;
        *)
            log_debug "Generic API key validation passed"
            return 0
            ;;
    esac
}

# Validate file path
validate_file_path() {
    local file_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$file_path" ]; then
        log_error "File path cannot be empty"
        return 1
    fi
    
    # Check if file must exist
    if [ "$must_exist" = "true" ] && [ ! -f "$file_path" ]; then
        log_error "File does not exist: $file_path"
        return 1
    fi
    
    # Check if file must be writable
    if [ "$must_be_writable" = "true" ]; then
        local dir_path
        dir_path=$(dirname "$file_path")
        if [ ! -w "$dir_path" ]; then
            log_error "Directory not writable: $dir_path"
            return 1
        fi
        
        if [ -f "$file_path" ] && [ ! -w "$file_path" ]; then
            log_error "File not writable: $file_path"
            return 1
        fi
    fi
    
    log_debug "File path validation passed: $file_path"
    return 0
}

# Validate directory path
validate_directory_path() {
    local dir_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$dir_path" ]; then
        log_error "Directory path cannot be empty"
        return 1
    fi
    
    # Check if directory must exist
    if [ "$must_exist" = "true" ] && [ ! -d "$dir_path" ]; then
        log_error "Directory does not exist: $dir_path"
        return 1
    fi
    
    # Check if directory must be writable
    if [ "$must_be_writable" = "true" ] && [ -d "$dir_path" ] && [ ! -w "$dir_path" ]; then
        log_error "Directory not writable: $dir_path"
        return 1
    fi
    
    log_debug "Directory path validation passed: $dir_path"
    return 0
}

# Validate URL format
validate_url() {
    local url="$1"
    
    if [ -z "$url" ]; then
        log_error "URL cannot be empty"
        return 1
    fi
    
    # Basic URL format validation
    if [[ "$url" =~ ^https?://[a-zA-Z0-9.-]+[a-zA-Z0-9]+(:[0-9]+)?(/.*)?$ ]]; then
        log_debug "URL format validation passed: $url"
        return 0
    else
        log_error "Invalid URL format: $url"
        return 1
    fi
}

# Validate version string
validate_version() {
    local version="$1"
    
    if [ -z "$version" ]; then
        log_error "Version cannot be empty"
        return 1
    fi
    
    # Semantic version format (major.minor.patch)
    if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
        log_debug "Version format validation passed: $version"
        return 0
    else
        log_error "Invalid version format: $version (expected: major.minor.patch)"
        return 1
    fi
}

# Validate shell type
validate_shell_type() {
    local shell_path="$1"
    
    if [ -z "$shell_path" ]; then
        shell_path="$SHELL"
    fi
    
    local shell_name
    shell_name=$(basename "$shell_path")
    
    case "$shell_name" in
        bash|zsh|sh)
            log_debug "Supported shell detected: $shell_name"
            return 0
            ;;
        *)
            log_warn "Shell may not be fully supported: $shell_name"
            return 0  # Warning only, don't fail
            ;;
    esac
}

# Validate configuration completeness
validate_configuration_completeness() {
    log_progress "Validating configuration completeness..."
    
    local errors=0
    
    # Check required variables from app.conf
    local required_app_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    for var in "${required_app_vars[@]}"; do
        if [ -z "${!var}" ]; then
            log_error "Required configuration variable not set: $var"
            ((errors++))
        fi
    done
    
    # Check model configuration
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_error "No models configured in MODEL_PROVIDERS"
        ((errors++))
    fi
    
    # Check provider configuration
    if [ -z "$AVAILABLE_PROVIDERS" ]; then
        log_error "No providers configured in AVAILABLE_PROVIDERS"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "Configuration completeness validation passed"
        return 0
    else
        log_error "Configuration completeness validation failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/installers/claude_installer.sh`:

```sh
#!/bin/bash

# Claude Code Installer Module
# Handles Claude Code CLI installation and configuration

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Claude Code CLI
install_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Installation"
    
    # Validate Node.js is available
    if ! validate_nodejs; then
        log_error "Node.js is required for Claude Code installation"
        return 1
    fi
    
    # Check if Claude Code is already installed
    if validate_claude_code; then
        log_info "Claude Code is already installed and working"
        _display_claude_info
        return 0
    fi
    
    log_progress "Installing Claude Code CLI package: $package_name"
    
    # Install via npm
    if _install_claude_npm "$package_name"; then
        log_success "Claude Code CLI installed successfully"
    else
        log_error "Failed to install Claude Code CLI"
        return 1
    fi
    
    # Configure Claude Code
    if _configure_claude_code; then
        log_success "Claude Code configured successfully"
    else
        log_warn "Claude Code installation succeeded but configuration failed"
    fi
    
    # Verify installation
    if validate_claude_code; then
        log_success "Claude Code installation and verification completed"
        _display_claude_info
        return 0
    else
        log_error "Claude Code installation verification failed"
        return 1
    fi
}

# Install Claude Code via npm
_install_claude_npm() {
    local package_name="$1"
    
    log_debug "Installing $package_name via npm..."
    
    # Check npm availability
    if ! command -v npm >/dev/null 2>&1; then
        log_error "npm command not found"
        return 1
    fi
    
    # Install globally with error handling
    local install_output
    if install_output=$(npm install -g "$package_name" 2>&1); then
        log_debug "npm install output: $install_output"
        return 0
    else
        log_error "npm install failed: $install_output"
        return 1
    fi
}

# Configure Claude Code
_configure_claude_code() {
    log_progress "Configuring Claude Code to skip onboarding..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    local claude_settings_file="$claude_config_dir/settings.json"
    
    # Ensure Claude config directory exists
    if ! mkdir -p "$claude_config_dir"; then
        log_error "Failed to create Claude config directory: $claude_config_dir"
        return 1
    fi
    
    # Create or update configuration using Node.js
    local config_script='
        const fs = require("fs");
        const path = require("path");
        const os = require("os");
        const configPath = path.join(os.homedir(), ".claude.json");
        
        let config = {};
        if (fs.existsSync(configPath)) {
            try {
                const content = fs.readFileSync(configPath, "utf-8");
                config = JSON.parse(content);
            } catch (e) {
                console.error("Warning: Could not parse existing config, creating new one");
                config = {};
            }
        }
        
        config.hasCompletedOnboarding = true;
        
        try {
            fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
            console.log("Configuration updated successfully");
        } catch (e) {
            console.error("Failed to write configuration:", e.message);
            process.exit(1);
        }
    '
    
    if node -e "$config_script" 2>/dev/null; then
        log_success "Claude Code configuration updated"
    else
        log_error "Failed to configure Claude Code"
        return 1
    fi
    
    # Configure MCP servers
    _configure_mcp_servers
}

# Configure MCP servers
_configure_mcp_servers() {
    log_progress "Configuring MCP servers..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_settings_file="$claude_config_dir/settings.json"
    local mcp_config_source="$(dirname "${BASH_SOURCE[0]}")/../../config/mcp.json"
    
    # Check if MCP config exists
    if [ ! -f "$mcp_config_source" ]; then
        log_info "No MCP configuration found, skipping MCP setup"
        return 0
    fi
    
    # Read MCP configuration
    local mcp_config
    if ! mcp_config=$(cat "$mcp_config_source" 2>/dev/null); then
        log_error "Failed to read MCP configuration from $mcp_config_source"
        return 1
    fi
    
    # Configure settings.json with MCP servers
    local mcp_config_path="$HOME/.claude/settings.json"
    local mcp_source_path="$(dirname "${BASH_SOURCE[0]}")/../../config/mcp.json"
    
    if [ -f "$mcp_source_path" ]; then
        log_progress "Configuring MCP servers..."
        
        # Create backup
        if [ -f "$mcp_config_path" ]; then
            cp "$mcp_config_path" "$mcp_config_path.backup"
        fi
        
        # Use a simple Node.js script to merge configurations
        node -e "
const fs = require('fs');
const path = require('path');
const os = require('os');

const settingsPath = path.join(os.homedir(), '.claude', 'settings.json');
const mcpPath = '$mcp_source_path';

let settings = {};
if (fs.existsSync(settingsPath)) {
    try {
        settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
    } catch (e) {
        console.warn('Could not parse existing settings');
    }
}

let mcpConfig = {};
if (fs.existsSync(mcpPath)) {
    try {
        mcpConfig = JSON.parse(fs.readFileSync(mcpPath, 'utf8'));
    } catch (e) {
        console.warn('Could not parse MCP configuration');
    }
}

// Merge MCP configuration
if (mcpConfig.mcpServers) {
    settings.mcpServers = mcpConfig.mcpServers;
}

// Update hook
if (!settings.hooks) settings.hooks = {};
if (!settings.hooks.SessionStart) settings.hooks.SessionStart = [];
if (settings.hooks.SessionStart.length === 0 || 
    !settings.hooks.SessionStart[0].command.includes('MCP:')) {
    settings.hooks.SessionStart = [{
        type: 'command',
        command: 'echo ğŸ¤– Active: ' + (settings.model || 'kimi-k2-turbo-preview') + ' | MCP: jina-mcp-server enabled'
    }];
}

fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
console.log('MCP configuration applied successfully');
" 2>/dev/null
        
        if [ $? -eq 0 ]; then
            log_success "MCP configuration applied"
            return 0
        else
            log_error "Failed to apply MCP configuration"
            return 1
        fi
    else
        log_info "No MCP configuration found, skipping MCP setup"
        return 0
    fi
}

# Display Claude Code information
_display_claude_info() {
    log_info "Claude Code Installation Summary:"
    
    if command -v claude >/dev/null 2>&1; then
        local claude_version
        if claude_version=$(claude --version 2>/dev/null); then
            log_indent info "Claude Code version: $claude_version" 2
        else
            log_indent warn "Could not determine Claude Code version" 2
        fi
        
        local claude_path
        if claude_path=$(which claude 2>/dev/null); then
            log_indent info "Claude Code path: $claude_path" 2
        fi
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration file: $config_file" 2
        local onboarding_status
        if onboarding_status=$(node -e "
            try {
                const config = JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'));
                console.log(config.hasCompletedOnboarding ? 'completed' : 'pending');
            } catch (e) {
                console.log('unknown');
            }
        " 2>/dev/null); then
            log_indent info "Onboarding status: $onboarding_status" 2
        fi
    fi
}

# Update Claude Code
update_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Update"
    
    # Check current installation
    if ! validate_claude_code; then
        log_error "Claude Code not found. Please install it first."
        return 1
    fi
    
    log_progress "Updating Claude Code CLI package: $package_name"
    
    # Update via npm
    if _update_claude_npm "$package_name"; then
        log_success "Claude Code CLI updated successfully"
        _display_claude_info
        return 0
    else
        log_error "Failed to update Claude Code CLI"
        return 1
    fi
}

# Update Claude Code via npm
_update_claude_npm() {
    local package_name="$1"
    
    log_debug "Updating $package_name via npm..."
    
    local update_output
    if update_output=$(npm update -g "$package_name" 2>&1); then
        log_debug "npm update output: $update_output"
        return 0
    else
        log_error "npm update failed: $update_output"
        return 1
    fi
}

# Uninstall Claude Code
uninstall_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Uninstallation"
    
    # Check if Claude Code is installed
    if ! command -v claude >/dev/null 2>&1; then
        log_info "Claude Code not found, nothing to uninstall"
        return 0
    fi
    
    log_progress "Uninstalling Claude Code CLI package: $package_name"
    
    # Uninstall via npm
    if _uninstall_claude_npm "$package_name"; then
        log_success "Claude Code CLI uninstalled successfully"
    else
        log_error "Failed to uninstall Claude Code CLI"
        return 1
    fi
    
    # Clean up configuration (optional)
    local cleanup_config="${2:-false}"
    if [ "$cleanup_config" = "true" ]; then
        _cleanup_claude_config
    fi
    
    return 0
}

# Uninstall Claude Code via npm
_uninstall_claude_npm() {
    local package_name="$1"
    
    log_debug "Uninstalling $package_name via npm..."
    
    local uninstall_output
    if uninstall_output=$(npm uninstall -g "$package_name" 2>&1); then
        log_debug "npm uninstall output: $uninstall_output"
        return 0
    else
        log_error "npm uninstall failed: $uninstall_output"
        return 1
    fi
}

# Clean up Claude Code configuration
_cleanup_claude_config() {
    log_progress "Cleaning up Claude Code configuration..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    local claude_settings_file="$claude_config_dir/settings.json"
    
    # Remove configuration files
    local files_to_remove=("$claude_config_file" "$claude_settings_file")
    
    for file in "${files_to_remove[@]}"; do
        if [ -f "$file" ]; then
            log_debug "Removing configuration file: $file"
            rm -f "$file"
        fi
    done
    
    # Remove empty directory
    if [ -d "$claude_config_dir" ] && [ -z "$(ls -A "$claude_config_dir" 2>/dev/null)" ]; then
        log_debug "Removing empty Claude config directory: $claude_config_dir"
        rmdir "$claude_config_dir"
    fi
    
    log_success "Claude Code configuration cleanup completed"
}

# Test Claude Code installation
test_claude_installation() {
    log_header "Claude Code Installation Test"
    
    local errors=0
    
    # Test Claude command availability
    if command -v claude >/dev/null 2>&1; then
        log_success "Claude command is available"
    else
        log_error "Claude command not found"
        ((errors++))
    fi
    
    # Test Claude version command
    local version_output
    if version_output=$(claude --version 2>/dev/null); then
        log_success "Claude version command works: $version_output"
    else
        log_error "Claude version command failed"
        ((errors++))
    fi
    
    # Test Claude help command
    if claude --help >/dev/null 2>&1; then
        log_success "Claude help command works"
    else
        log_error "Claude help command failed"
        ((errors++))
    fi
    
    # Test configuration file
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_success "Claude configuration file exists"
        
        # Test configuration file validity
        if node -e "JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'))" 2>/dev/null; then
            log_success "Claude configuration file is valid JSON"
        else
            log_error "Claude configuration file has invalid JSON"
            ((errors++))
        fi
    else
        log_warn "Claude configuration file not found (may be created on first run)"
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Claude Code tests passed"
        return 0
    else
        log_error "Claude Code tests failed with $errors errors"
        return 1
    fi
}

# Get Claude Code status
get_claude_status() {
    log_info "Claude Code Status:"
    
    if command -v claude >/dev/null 2>&1; then
        log_indent success "Status: Installed" 2
        
        local version
        if version=$(claude --version 2>/dev/null); then
            log_indent info "Version: $version" 2
        fi
        
        local path
        if path=$(which claude 2>/dev/null); then
            log_indent info "Path: $path" 2
        fi
    else
        log_indent error "Status: Not installed" 2
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration: Found" 2
    else
        log_indent warn "Configuration: Not found" 2
    fi
}


```

`claude-model-switcher/lib/installers/nodejs_installer.sh`:

```sh
#!/bin/bash

# Node.js Installer Module
# Handles Node.js installation via NVM

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Node.js via NVM
install_nodejs() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    local nvm_version="${2:-$NVM_VERSION}"
    
    log_header "Node.js Installation"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met for Node.js installation"
        return 1
    fi
    
    # Check if Node.js is already installed and meets requirements
    if validate_nodejs "$min_version"; then
        log_info "Node.js already meets requirements, skipping installation"
        return 0
    fi
    
    local platform
    platform=$(uname -s)
    
    case "$platform" in
        Linux|Darwin)
            _install_nodejs_unix "$min_version" "$nvm_version"
            ;;
        *)
            log_error "Unsupported platform for Node.js installation: $platform"
            return 1
            ;;
    esac
}

# Install Node.js on Unix-like systems (Linux/macOS)
_install_nodejs_unix() {
    local min_version="$1"
    local nvm_version="$2"
    
    log_progress "Installing Node.js via NVM for Unix-like system..."
    
    # Check if NVM is already installed
    if [ -d "$HOME/.nvm" ]; then
        log_info "NVM directory already exists, sourcing existing installation..."
        _source_nvm
    else
        log_progress "Downloading and installing NVM $nvm_version..."
        if ! _install_nvm "$nvm_version"; then
            log_error "Failed to install NVM"
            return 1
        fi
    fi
    
    # Install Node.js LTS
    log_progress "Installing Node.js LTS version..."
    if ! _install_nodejs_lts; then
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Verify installation
    if validate_nodejs "$min_version"; then
        log_success "Node.js installation completed successfully"
        _display_nodejs_info
        return 0
    else
        log_error "Node.js installation verification failed"
        return 1
    fi
}

# Install NVM
_install_nvm() {
    local nvm_version="$1"
    local install_url="${NVM_INSTALL_URL:-https://raw.githubusercontent.com/nvm-sh/nvm/$nvm_version/install.sh}"
    
    log_debug "Downloading NVM from: $install_url"
    
    # Validate URL format
    if ! validate_url "$install_url"; then
        log_error "Invalid NVM install URL: $install_url"
        return 1
    fi
    
    # Download and execute NVM installer
    if curl -s -o- "$install_url" | bash; then
        log_success "NVM installation script executed successfully"
        _source_nvm
        return 0
    else
        log_error "Failed to download or execute NVM installer"
        return 1
    fi
}

# Source NVM environment
_source_nvm() {
    log_debug "Sourcing NVM environment..."
    
    export NVM_DIR="$HOME/.nvm"
    
    # Source NVM script
    if [ -s "$NVM_DIR/nvm.sh" ]; then
        source "$NVM_DIR/nvm.sh"
        log_debug "NVM script sourced successfully"
    else
        log_error "NVM script not found: $NVM_DIR/nvm.sh"
        return 1
    fi
    
    # Source NVM bash completion (optional)
    if [ -s "$NVM_DIR/bash_completion" ]; then
        source "$NVM_DIR/bash_completion"
        log_debug "NVM bash completion sourced"
    fi
    
    return 0
}

# Install Node.js LTS
_install_nodejs_lts() {
    # Ensure NVM is sourced
    if ! command -v nvm >/dev/null 2>&1; then
        if ! _source_nvm; then
            log_error "NVM not available after sourcing"
            return 1
        fi
    fi
    
    log_debug "Installing Node.js LTS via NVM..."
    
    # Install LTS version
    if nvm install --lts; then
        log_success "Node.js LTS installed successfully"
    else
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Use LTS version
    if nvm use --lts; then
        log_success "Switched to Node.js LTS"
    else
        log_error "Failed to switch to Node.js LTS"
        return 1
    fi
    
    # Set LTS as default
    if nvm alias default 'lts/*'; then
        log_success "Node.js LTS set as default"
    else
        log_warn "Failed to set Node.js LTS as default"
    fi
    
    return 0
}

# Display Node.js installation information
_display_nodejs_info() {
    log_info "Node.js Installation Summary:"
    
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_indent info "Node.js version: $node_version" 2
    fi
    
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_indent info "npm version: $npm_version" 2
    fi
    
    if command -v nvm >/dev/null 2>&1; then
        local nvm_version
        nvm_version=$(nvm --version 2>/dev/null)
        log_indent info "NVM version: $nvm_version" 2
    fi
}

# Check if Node.js upgrade is needed
check_nodejs_upgrade() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    
    if ! validate_nodejs "$min_version"; then
        log_info "Node.js upgrade recommended"
        return 1
    else
        log_info "Node.js version is up to date"
        return 0
    fi
}

# Upgrade Node.js to latest LTS
upgrade_nodejs() {
    log_header "Node.js Upgrade"
    
    # Check if NVM is available
    if [ ! -d "$HOME/.nvm" ]; then
        log_error "NVM not found. Please install Node.js first."
        return 1
    fi
    
    # Source NVM
    if ! _source_nvm; then
        log_error "Failed to source NVM environment"
        return 1
    fi
    
    log_progress "Upgrading to latest Node.js LTS..."
    
    # Install latest LTS
    if ! _install_nodejs_lts; then
        log_error "Failed to upgrade Node.js"
        return 1
    fi
    
    log_success "Node.js upgrade completed"
    _display_nodejs_info
    return 0
}

# Uninstall Node.js (remove NVM)
uninstall_nodejs() {
    log_header "Node.js Uninstallation"
    
    if [ -d "$HOME/.nvm" ]; then
        log_progress "Removing NVM directory..."
        rm -rf "$HOME/.nvm"
        log_success "NVM directory removed"
    else
        log_info "NVM directory not found, nothing to remove"
    fi
    
    # Remove NVM lines from shell configuration files
    local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    
    for shell_file in "${shell_files[@]}"; do
        if [ -f "$shell_file" ]; then
            if grep -q "NVM_DIR" "$shell_file"; then
                log_progress "Cleaning NVM configuration from: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.nvm_removal_backup"
                # Remove NVM lines
                sed -i '/NVM_DIR/d' "$shell_file"
                sed -i '/nvm.sh/d' "$shell_file"
                sed -i '/bash_completion/d' "$shell_file"
                log_success "NVM configuration removed from: $shell_file"
            fi
        fi
    done
    
    log_success "Node.js uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Test Node.js installation
test_nodejs_installation() {
    log_header "Node.js Installation Test"
    
    local errors=0
    
    # Test Node.js command
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js command available: $node_version"
    else
        log_error "Node.js command not found"
        ((errors++))
    fi
    
    # Test npm command
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_success "npm command available: $npm_version"
    else
        log_error "npm command not found"
        ((errors++))
    fi
    
    # Test simple Node.js execution
    local test_result
    test_result=$(node -e "console.log('Node.js test successful')" 2>/dev/null)
    if [ "$test_result" = "Node.js test successful" ]; then
        log_success "Node.js execution test passed"
    else
        log_error "Node.js execution test failed"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Node.js tests passed"
        return 0
    else
        log_error "Node.js tests failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/managers/model_manager.sh`:

```sh
#!/bin/bash

# Model Manager Module
# Handles model switching, listing, and configuration

# Source dependencies
# Note: Core modules (logger, validator, config_loader) are expected to be 
# available in the environment. This avoids circular dependencies during testing.

# List available models (implementation)
list_models_impl() {
    log_header "Available Models"
    
    # Reload configuration to get latest models
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if models are configured
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_warn "No models defined in $MODEL_CONFIG_FILE"
        return 1
    fi
    
    # Display table header
    local table_width="${TABLE_WIDTH:-110}"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    printf "%-12s %-12s %-25s %-25s %s\n" "Alias" "Provider" "Main Model" "Fast Model" "Context"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display models
    for alias in "${!MODEL_PROVIDERS[@]}"; do
        local provider="${MODEL_PROVIDERS[$alias]}"
        local main_model="${MODEL_API_NAMES[$alias]}"
        local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
        local context="${MODEL_CONTEXTS[$alias]:-N/A}"
        
        printf "%-12s %-12s %-25s %-25s %s\n" \
            "$alias" \
            "$provider" \
            "$main_model" \
            "$fast_model" \
            "$context"
    done
    
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display additional information
    log_info "Total models configured: ${#MODEL_PROVIDERS[@]}"
    log_info "Configuration file: $MODEL_CONFIG_FILE"
    
    return 0
}

# Use/switch to a specific model (implementation)
use_model_impl() {
    local alias="$1"
    local api_key="$2"  # Optional: can be provided or prompted
    
    log_header "Model Switching: $alias"
    
    # Validate input
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        log_info "Usage: use_model <alias> [api_key]"
        list_models
        return 1
    fi
    
    # Validate alias format
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    # Reload configuration
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if model exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found in configuration"
        list_models
        return 1
    fi
    
    # Get model properties
    local provider="${MODEL_PROVIDERS[$alias]}"
    local main_model="${MODEL_API_NAMES[$alias]}"
    local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
    local context_info="${MODEL_CONTEXTS[$alias]}"
    local description="${MODEL_DESCRIPTIONS[$alias]:-N/A}"
    
    # Validate provider
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    # Configure provider-specific settings
    if ! _configure_provider "$provider" "$alias" "$api_key"; then
        log_error "Failed to configure provider: $provider"
        return 1
    fi
    
    # Set model environment variables
    export ANTHROPIC_MODEL="$main_model"
    export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
    log_success "Model environment variables configured: $main_model | $fast_model"
    
    # Save environment variables for persistence
    _save_current_env_vars "$provider" "$main_model" "$fast_model"
    
    # Configure Claude Code settings
    if ! _configure_claude_settings "$alias" "$main_model" "$fast_model" "$context_info"; then
        log_error "Failed to configure Claude Code settings"
        return 1
    fi
    
    # Update memory/context file
    if ! _update_model_context "$alias" "$provider" "$main_model" "$fast_model" "$context_info" "$description"; then
        log_warn "Failed to update model context file"
    fi
    
    log_success "Successfully switched to model: $alias"
    _display_active_model_info "$alias" "$provider" "$main_model" "$fast_model" "$context_info"
    
    return 0
}

# Configure provider-specific settings
_configure_provider() {
    local provider="$1"
    local alias="$2"
    local api_key="$3"
    
    log_progress "Configuring provider: $provider"
    
    # Get provider configuration
    local base_url_var="PROVIDER_${provider^^}_BASE_URL"
    local base_url="${!base_url_var}"
    
    if [ -z "$base_url" ]; then
        log_error "Base URL not configured for provider: $provider"
        return 1
    fi
    
    # Validate base URL
    if ! validate_url "$base_url"; then
        log_error "Invalid base URL for provider $provider: $base_url"
        return 1
    fi
    
    # Set base URL
    export ANTHROPIC_BASE_URL="$base_url"
    log_success "Base URL configured: $base_url"
    
    # Handle API key
    if [ -z "$api_key" ]; then
        log_info "Please enter your $provider API key (input hidden):"
        read -s api_key
        echo  # New line after hidden input
    fi
    
    # Validate API key
    if ! validate_api_key "$api_key" "$provider"; then
        log_error "Invalid API key format"
        return 1
    fi
    
    # Set API key
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    log_success "API key configured for this session"
    
    return 0
}

# Configure Claude Code settings
_configure_claude_settings() {
    local alias="$1"
    local main_model="$2"
    local fast_model="$3"
    local context_info="$4"
    
    log_progress "Configuring Claude Code settings..."
    
    local claude_dir="$HOME/.claude"
    local settings_file="$claude_dir/settings.json"
    
    # Ensure Claude directory exists
    mkdir -p "$claude_dir"
    
    # Get configuration values
    local temperature="${CLAUDE_DEFAULT_TEMPERATURE:-0.6}"
    local timeout="${CLAUDE_DEFAULT_TIMEOUT:-300000}"
    
    # Create settings JSON
    local settings_content
    settings_content=$(cat << EOF
{
  "model": "$main_model",
  "env": {
    "CLAUDE_CODE_TEMPERATURE": "$temperature",
    "BASH_DEFAULT_TIMEOUT_MS": "$timeout",
    "ANTHROPIC_MODEL": "$main_model",
    "ANTHROPIC_SMALL_FAST_MODEL": "$fast_model"
  },
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "echo 'ğŸ¤– Active: $main_model ($alias) | Fast: $fast_model | Context: $context_info | T:$temperature | Timeout:${timeout}ms'"
      }
    ]
  }
}
EOF
    )
    
    # Write settings file
    if echo "$settings_content" > "$settings_file"; then
        log_success "Claude Code settings updated: $settings_file"
        return 0
    else
        log_error "Failed to write Claude Code settings file"
        return 1
    fi
}

# Update model context file
_update_model_context() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    local description="$6"
    
    local memory_file="$MEMORY_DIR/model-context.md"
    
    # Ensure memory directory exists
    mkdir -p "$MEMORY_DIR"
    
    # Create context content
    local context_content
    context_content=$(cat << EOF
# Model Context Reference

## Current Configuration
- **Provider**: $provider
- **Alias**: $alias
- **Main Model**: $main_model
- **Fast Model**: $fast_model
- **Context Window**: $context_info
- **Description**: $description
- **Temperature**: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6} (Programming Mode)
- **Timeout**: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms (5 minutes)
- **Last Updated**: $(date)

## Environment Variables
- **ANTHROPIC_BASE_URL**: ${ANTHROPIC_BASE_URL:-Not set}
- **ANTHROPIC_MODEL**: $main_model
- **ANTHROPIC_SMALL_FAST_MODEL**: $fast_model

## Usage Instructions
1. Use \`claude "your prompt here"\` for general queries
2. The system automatically selects between main and fast models based on task complexity
3. Programming assistance is optimized with temperature 0.6
4. Session timeout is set to 5 minutes for long-running tasks

## Provider Information
- **Base URL**: ${ANTHROPIC_BASE_URL:-Not configured}
- **Authentication**: Session-based (API key required per session)

---
*Generated by Claude Model Switcher v${APP_VERSION:-5.0.0}*
EOF
    )
    
    # Write context file
    if echo "$context_content" > "$memory_file"; then
        log_debug "Model context file updated: $memory_file"
        return 0
    else
        log_warn "Failed to update model context file: $memory_file"
        return 1
    fi
}

# Display active model information
_display_active_model_info() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    
    log_info "Active Model Configuration:"
    log_indent info "Alias: $alias" 2
    log_indent info "Provider: $provider" 2
    log_indent info "Main Model: $main_model" 2
    log_indent info "Fast Model: $fast_model" 2
    log_indent info "Context: $context_info" 2
    log_indent info "Temperature: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6}" 2
    log_indent info "Timeout: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms" 2
    
    log_info "Ready to use Claude Code with: claude \"your prompt here\""
}

# Get current model status
get_model_status() {
    log_info "Current Model Status:"
    
    # Check environment variables
    if [ -n "$ANTHROPIC_MODEL" ]; then
        log_indent success "Main Model: $ANTHROPIC_MODEL" 2
    else
        log_indent warn "Main Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_SMALL_FAST_MODEL" ]; then
        log_indent success "Fast Model: $ANTHROPIC_SMALL_FAST_MODEL" 2
    else
        log_indent warn "Fast Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_BASE_URL" ]; then
        log_indent success "Base URL: $ANTHROPIC_BASE_URL" 2
    else
        log_indent warn "Base URL: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
        log_indent success "API Key: Configured" 2
    else
        log_indent warn "API Key: Not configured" 2
    fi
    
    # Check settings file
    local settings_file="$HOME/.claude/settings.json"
    if [ -f "$settings_file" ]; then
        log_indent success "Settings File: $settings_file" 2
    else
        log_indent warn "Settings File: Not found" 2
    fi
    
    # Check context file
    local context_file="$MEMORY_DIR/model-context.md"
    if [ -f "$context_file" ]; then
        log_indent success "Context File: $context_file" 2
    else
        log_indent warn "Context File: Not found" 2
    fi
}

# Add a new model to configuration
add_model() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context="$5"
    local description="$6"
    
    log_header "Adding New Model: $alias"
    
    # Validate inputs
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    if [ -z "$main_model" ]; then
        log_error "Main model name is required"
        return 1
    fi
    
    # Set defaults
    fast_model="${fast_model:-$main_model}"
    context="${context:-N/A}"
    description="${description:-Custom model configuration}"
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias already exists
    if [ -n "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' already exists"
        return 1
    fi
    
    # Add model to configuration file
    log_progress "Adding model to configuration file..."
    
    local new_model_config
    new_model_config=$(cat << EOF

# Model Alias: '$alias' - $description
MODEL_PROVIDERS["$alias"]="$provider"
MODEL_API_NAMES["$alias"]="$main_model"
MODEL_SMALL_FAST_NAMES["$alias"]="$fast_model"
MODEL_CONTEXTS["$alias"]="$context"
MODEL_DESCRIPTIONS["$alias"]="$description"
EOF
    )
    
    # Append to configuration file
    if echo "$new_model_config" >> "$MODEL_CONFIG_FILE"; then
        log_success "Model '$alias' added to configuration"
        
        # Update AVAILABLE_MODELS list
        local current_models
        current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
        local updated_models="$current_models $alias"
        
        # Update the AVAILABLE_MODELS line
        sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
        
        log_success "Model successfully added and configuration updated"
        return 0
    else
        log_error "Failed to add model to configuration file"
        return 1
    fi
}

# Remove a model from configuration
remove_model() {
    local alias="$1"
    
    log_header "Removing Model: $alias"
    
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        return 1
    fi
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found"
        return 1
    fi
    
    # Create backup
    local backup_file="${MODEL_CONFIG_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    if cp "$MODEL_CONFIG_FILE" "$backup_file"; then
        log_success "Configuration backup created: $backup_file"
    else
        log_warn "Failed to create backup, proceeding anyway"
    fi
    
    # Remove model entries from configuration file
    log_progress "Removing model entries from configuration..."
    
    # Remove all lines related to this model
    sed -i "/MODEL_PROVIDERS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_API_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_SMALL_FAST_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_CONTEXTS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_DESCRIPTIONS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    
    # Update AVAILABLE_MODELS list
    local current_models
    current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
    local updated_models
    updated_models=$(echo "$current_models" | sed "s/\b$alias\b//g" | tr -s ' ' | sed 's/^ *//;s/ *$//')
    
    sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
    
    log_success "Model '$alias' removed from configuration"
    return 0
}

# Save current environment variables for persistence
_save_current_env_vars() {
    local provider="$1"
    local main_model="$2"
    local fast_model="$3"
    
    local env_file="$CONFIG_DIR/current_env.conf"
    
    # Create environment configuration content
    local env_content
    env_content=$(cat << EOF
# Current Model Environment Variables
# This file is automatically managed by the model switcher
# Last updated: $(date)

export ANTHROPIC_BASE_URL="$ANTHROPIC_BASE_URL"
export ANTHROPIC_AUTH_TOKEN="$ANTHROPIC_AUTH_TOKEN"
export ANTHROPIC_MODEL="$main_model"
export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
EOF
    )
    
    # Write environment file
    if echo "$env_content" > "$env_file"; then
        log_success "Environment variables saved for persistence"
        return 0
    else
        log_warn "Failed to save environment variables"
        return 1
    fi
}

# Load persisted environment variables
load_persisted_env_vars() {
    local env_file="$CONFIG_DIR/current_env.conf"
    
    if [ -f "$env_file" ]; then
        source "$env_file"
        return 0
    fi
    
    return 1
}


```

`claude-model-switcher/main.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Main Entry Point
# Version 5.0.0 - Modular Architecture
# A robust installer and manager for Claude Code with multi-model support

set -e

# --- Script Metadata ---
SCRIPT_VERSION="5.0.0"
SCRIPT_NAME="Claude Model Switcher"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Bootstrap Configuration ---
# Load base configuration to get directory paths
if [ -f "$SCRIPT_DIR/config/app.conf" ]; then
    source "$SCRIPT_DIR/config/app.conf"
else
    echo "âŒ Error: Configuration file not found: $SCRIPT_DIR/config/app.conf"
    echo "Please ensure the script is run from the correct directory."
    exit 1
fi

# --- Module Loading ---
# Load core modules
source "$SCRIPT_DIR/lib/core/logger.sh"
source "$SCRIPT_DIR/lib/core/config_loader.sh"
source "$SCRIPT_DIR/lib/core/validator.sh"

# Load installer modules
source "$SCRIPT_DIR/lib/installers/nodejs_installer.sh"
source "$SCRIPT_DIR/lib/installers/claude_installer.sh"

# Load manager modules
source "$SCRIPT_DIR/lib/managers/model_manager.sh"

# --- Initialization ---
initialize_system() {
    # Initialize logger
    logger_init
    
    log_header "$SCRIPT_NAME v$SCRIPT_VERSION"
    log_info "Initializing modular system..."
    
    # Load all configurations
    if ! config_load_all "$SCRIPT_DIR/config"; then
        log_error "Failed to load configurations"
        return 1
    fi
    
    # Validate environment
    if ! config_validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi
    
    log_success "System initialization completed"
    return 0
}

# --- Command Functions ---

# Install command - Full installation process
cmd_install() {
    log_header "Full Installation Process"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met"
        return 1
    fi
    
    # Install Node.js if needed
    log_progress "Step 1: Node.js Installation"
    if ! install_nodejs; then
        log_error "Node.js installation failed"
        return 1
    fi
    
    # Install Claude Code
    log_progress "Step 2: Claude Code Installation"
    if ! install_claude_code; then
        log_error "Claude Code installation failed"
        return 1
    fi
    
    # Setup shell integration
    log_progress "Step 3: Shell Integration Setup"
    if ! setup_shell_integration; then
        log_error "Shell integration setup failed"
        return 1
    fi
    
    # Display completion message
    display_installation_complete
    
    return 0
}

# Setup shell integration
setup_shell_integration() {
    log_progress "Setting up shell integration..."
    
    # Detect shell
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    log_info "Detected shell: $current_shell"
    log_info "Configuration file: $rc_file"
    
    # Create backup
    if [ -f "$rc_file" ]; then
        local backup_file="$rc_file.claude_backup.$(date +%Y%m%d_%H%M%S)"
        if cp "$rc_file" "$backup_file"; then
            log_success "Backup created: $backup_file"
        else
            log_warn "Failed to create backup"
        fi
        
        # Remove old configuration block
        sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
    fi
    
    # Add new configuration block
    local shell_config
    shell_config=$(cat << 'EOF'

# CLAUDE_CODE_MODEL_MANAGER_V5
# --- Claude Model Switcher (Modular Architecture) ---
# This block is managed automatically by the installation script.

# Define paths for the switcher's files.
export CLAUDE_SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
export CLAUDE_MODELS_CONF="$CLAUDE_SWITCHER_DIR/config/models.conf"

# Load the modular system
if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ]; then
    # Source configuration
    [ -f "$CLAUDE_SWITCHER_DIR/config/app.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/app.conf"
    [ -f "$CLAUDE_SWITCHER_DIR/config/providers.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/providers.conf"
    
    # Pre-declare associative arrays before loading models.conf
    declare -gA MODEL_PROVIDERS 2>/dev/null || true
    declare -gA MODEL_API_NAMES 2>/dev/null || true
    declare -gA MODEL_CONTEXTS 2>/dev/null || true
    declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
    declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
    declare -gA MODEL_CAPABILITIES 2>/dev/null || true
    
    [ -f "$CLAUDE_SWITCHER_DIR/config/models.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/models.conf"
    
    # Source core modules
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh"
    
    # Initialize logger for shell functions
    logger_init >/dev/null 2>&1
    
    # Load persisted environment variables if available
    if declare -f load_persisted_env_vars >/dev/null 2>&1; then
        load_persisted_env_vars >/dev/null 2>&1 || true
    fi
fi

# Shell functions for user interaction
list_models() {
    # Check if the modular system is loaded
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f list_models_impl >/dev/null 2>&1; then
        list_models_impl "$@"
    else
        echo "âŒ Claude Model Switcher not properly installed"
        echo "ğŸ’¡ Try running: source ~/.bashrc"
        return 1
    fi
}

use_model() {
    # Check if the modular system is loaded  
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f use_model_impl >/dev/null 2>&1; then
        use_model_impl "$@"
    else
        echo "âŒ Claude Model Switcher not properly installed"
        echo "ğŸ’¡ Try running: source ~/.bashrc"
        return 1
    fi
}

# END_OF_CLAUDE_CONFIG
EOF
    )
    
    # Append configuration
    if echo "$shell_config" >> "$rc_file"; then
        log_success "Shell integration configured: $rc_file"
        return 0
    else
        log_error "Failed to configure shell integration"
        return 1
    fi
}

# Display installation complete message
display_installation_complete() {
    log_header "Installation Complete!"
    
    echo ""
    log_success "ğŸ‰ Claude Model Switcher v$SCRIPT_VERSION is ready!"
    echo ""
    
    log_info "Next Steps:"
    log_indent info "1. Refresh your environment:" 2
    log_indent info "   source ~/.bashrc  # or ~/.zshrc" 4
    echo ""
    
    log_indent info "2. List available models:" 2
    log_indent info "   list_models" 4
    echo ""
    
    log_indent info "3. Switch to a model:" 2
    log_indent info "   use_model kimi" 4
    log_indent info "   use_model glm4" 4
    echo ""
    
    log_indent info "4. Start using Claude Code:" 2
    log_indent info "   claude \"your prompt here\"" 4
    echo ""
    
    log_info "Configuration Files:"
    log_indent info "â€¢ Models: $MODEL_CONFIG_FILE" 2
    log_indent info "â€¢ Providers: $PROVIDERS_CONFIG_FILE" 2
    log_indent info "â€¢ Application: $SCRIPT_DIR/config/app.conf" 2
    echo ""
    
    log_info "For help: $SCRIPT_DIR/main.sh --help"
}

# Uninstall command
cmd_uninstall() {
    log_header "Uninstallation Process"
    
    echo "This will remove Claude Model Switcher and all its components."
    echo -n "Are you sure you want to continue? [y/N]: "
    read -r confirmation
    
    case "$confirmation" in
        [yY]|[yY][eE][sS])
            log_progress "Proceeding with uninstallation..."
            ;;
        *)
            log_info "Uninstallation cancelled"
            return 0
            ;;
    esac
    
    # Remove shell integration
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    if [ -f "$rc_file" ]; then
        if grep -q "$SHELL_CONFIG_MARKER" "$rc_file"; then
            log_progress "Removing shell integration..."
            
            # Create backup
            local backup_file="$rc_file.uninstall_backup.$(date +%Y%m%d_%H%M%S)"
            cp "$rc_file" "$backup_file"
            
            # Remove configuration block
            sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
            log_success "Shell integration removed. Backup: $backup_file"
        fi
    fi
    
    # Remove switcher directory
    if [ -d "$SWITCHER_DIR" ]; then
        log_progress "Removing switcher directory: $SWITCHER_DIR"
        rm -rf "$SWITCHER_DIR"
        
        # After removing the directory, disable file logging to avoid errors
        # since the log directory no longer exists
        export LOGGER_FILE=""
        
        log_success "Switcher directory removed"
    fi
    
    # Optionally remove Claude Code (ask user)
    echo -n "Do you want to remove Claude Code CLI as well? [y/N]: "
    read -r remove_claude
    
    case "$remove_claude" in
        [yY]|[yY][eE][sS])
            uninstall_claude_code "" "true"
            ;;
        *)
            log_info "Claude Code CLI preserved"
            ;;
    esac
    
    log_success "ğŸ‰ Uninstallation completed successfully"
    log_info "Please restart your terminal for changes to take effect"
    
    return 0
}

# Status command
cmd_status() {
    log_header "System Status"
    
    # System requirements
    log_progress "Checking system requirements..."
    validate_system_requirements
    echo ""
    
    # Node.js status
    log_progress "Checking Node.js..."
    if validate_nodejs; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js: $node_version"
    else
        log_warn "Node.js: Not installed or version too old"
    fi
    echo ""
    
    # Claude Code status
    log_progress "Checking Claude Code..."
    if validate_claude_code; then
        local claude_version
        claude_version=$(claude --version 2>/dev/null)
        log_success "Claude Code: $claude_version"
    else
        log_warn "Claude Code: Not installed"
    fi
    echo ""
    
    # Model configuration
    log_progress "Checking model configuration..."
    get_model_status
    echo ""
    
    # Configuration files
    log_progress "Checking configuration files..."
    local config_files=(
        "$SCRIPT_DIR/config/app.conf"
        "$SCRIPT_DIR/config/models.conf"
        "$SCRIPT_DIR/config/providers.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            log_indent success "$(basename "$config_file"): Found" 2
        else
            log_indent error "$(basename "$config_file"): Missing" 2
        fi
    done
    
    return 0
}

# Help command
cmd_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION - Modular Architecture

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    install         Full installation process (Node.js + Claude Code + Shell integration)
    uninstall       Remove Claude Model Switcher and optionally Claude Code
    status          Show system and component status
    list-models     List all available models
    use-model       Switch to a specific model
    add-model       Add a new model to configuration
    remove-model    Remove a model from configuration
    update          Update Claude Code to latest version
    test            Run system tests
    help            Show this help message

EXAMPLES:
    # Full installation
    $0 install

    # List available models
    $0 list-models

    # Switch to a model
    $0 use-model kimi

    # Add a custom model
    $0 add-model my-model openai gpt-4 gpt-3.5-turbo "8K tokens" "Custom GPT-4 configuration"

    # Check system status
    $0 status

    # Uninstall everything
    $0 uninstall

SHELL FUNCTIONS (available after installation):
    list_models     List available models
    use_model       Switch to a model

CONFIGURATION:
    â€¢ Application: $SCRIPT_DIR/config/app.conf
    â€¢ Models: $SCRIPT_DIR/config/models.conf
    â€¢ Providers: $SCRIPT_DIR/config/providers.conf

For more information, visit: https://github.com/your-repo/claude-model-switcher
EOF
}

# --- Command Line Interface ---

# Parse command line arguments
parse_arguments() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        "install")
            cmd_install "$@"
            ;;
        "uninstall")
            cmd_uninstall "$@"
            ;;
        "status")
            cmd_status "$@"
            ;;
        "list-models")
            list_models_impl "$@"
            ;;
        "use-model")
            use_model_impl "$@"
            ;;
        "add-model")
            add_model "$@"
            ;;
        "remove-model")
            remove_model "$@"
            ;;
        "update")
            update_claude_code "$@"
            ;;
        "test")
            cmd_test "$@"
            ;;
        "help"|"--help"|"-h")
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

# Test command
cmd_test() {
    log_header "System Tests"
    
    local errors=0
    
    # Test Node.js
    if ! test_nodejs_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test Claude Code
    if ! test_claude_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test configuration
    log_progress "Testing configuration..."
    if ! validate_configuration_completeness; then
        ((errors++))
    fi
    echo ""
    
    if [ $errors -eq 0 ]; then
        log_success "ğŸ‰ All tests passed!"
        return 0
    else
        log_error "âŒ Tests failed with $errors errors"
        return 1
    fi
}

# --- Main Execution ---

main() {
    # Initialize system
    if ! initialize_system; then
        echo "âŒ Failed to initialize system"
        exit 1
    fi
    
    # Parse and execute command
    parse_arguments "$@"
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi


```

`claude-model-switcher/tests/bdd/test_user_scenarios.sh`:

```sh
#!/bin/bash

# BDD Tests - User Scenarios

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger first
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    source "$PROJECT_DIR/lib/managers/model_manager.sh"
    
    # Create mock environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    
    # Setup configuration
    mkdir -p "$CONFIG_DIR"
    cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
    config_load_all "$CONFIG_DIR"
}

# Scenario: User wants to list available models
describe "BDD Scenario: Listing Available Models"

context "Given that the system is properly configured"

it "should have model configuration loaded"
assert_success "Model configuration should be loaded" "[ \${#MODEL_PROVIDERS[@]} -gt 0 ]"

context "When the user runs list_models command"

it "should display available models without errors"
# Capture output to verify content
output=$(list_models 2>&1)
assert_success "list_models should execute successfully" "list_models >/dev/null 2>&1"

it "should show model information in table format"
output=$(list_models 2>&1)
assert_contains "Output should contain table header" "$output" "Alias"
assert_contains "Output should contain provider column" "$output" "Provider"
assert_contains "Output should contain kimi model" "$output" "kimi"
assert_contains "Output should contain glm4 model" "$output" "glm4"

# Scenario: User wants to switch to a model (dry run)
describe "BDD Scenario: Model Switching (Validation Only)"

context "Given that models are configured"

it "should validate model alias before switching"
assert_success "Valid alias should pass validation" "validate_model_alias 'kimi'"
assert_failure "Invalid alias should fail validation" "validate_model_alias 'invalid@model'"

context "When user provides a valid model alias"

it "should find the model in configuration"
source "$MODEL_CONFIG_FILE"
assert_success "kimi model should exist in configuration" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"

it "should validate the provider"
provider="${MODEL_PROVIDERS[kimi]}"
assert_success "Provider should be valid" "validate_provider_name '$provider' '$AVAILABLE_PROVIDERS'"

# Scenario: User adds a custom model
describe "BDD Scenario: Adding Custom Model"

context "Given that the user wants to add a new model"

it "should validate new model parameters"
assert_success "New alias should be valid" "validate_model_alias 'custom-model'"
assert_success "Provider should be valid" "validate_provider_name 'moonshot' '$AVAILABLE_PROVIDERS'"

context "When the user adds the model"

it "should accept valid model configuration"
# Test the validation logic that would be used in add_model function
alias="custom-model"
provider="moonshot"
main_model="custom-api-model"
fast_model="custom-api-model-fast"
context="100K tokens"
description="Custom test model"

assert_success "All parameters should validate" "
    validate_model_alias '$alias' && 
    validate_provider_name '$provider' '$AVAILABLE_PROVIDERS' &&
    [ -n '$main_model' ] &&
    [ -n '$fast_model' ]
"

# Scenario: System health check
describe "BDD Scenario: System Health Check"

context "Given that the system is installed"

it "should have all required directories"
config_validate_environment >/dev/null 2>&1
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

context "When checking configuration files"

it "should have all required configuration files"
assert_file_exists "App config should exist" "$CONFIG_DIR/app.conf"
assert_file_exists "Models config should exist" "$CONFIG_DIR/models.conf"
assert_file_exists "Providers config should exist" "$CONFIG_DIR/providers.conf"

context "When validating configuration content"

it "should have valid configuration syntax"
assert_success "App config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/app.conf'"
assert_success "Models config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/models.conf'"
assert_success "Providers config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/providers.conf'"

# Scenario: Error handling
describe "BDD Scenario: Error Handling"

context "Given that user provides invalid input"

it "should handle empty model alias gracefully"
# This should fail gracefully, not crash
assert_failure "Empty alias should be rejected" "validate_model_alias ''"

it "should handle unknown model alias gracefully"
# Load config first
source "$MODEL_CONFIG_FILE"
# Check for non-existent model
assert_equals "Unknown model should return empty provider" "" "${MODEL_PROVIDERS[nonexistent]}"

context "When configuration files are missing"

it "should handle missing config files gracefully"
# Test with non-existent config file
assert_failure "Missing config file should fail gracefully" "config_load '/nonexistent/path/config.conf'"
```

`claude-model-switcher/tests/integration/test_installation.sh`:

```sh
#!/bin/bash

# Integration Tests for Installation Process

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="INFO"
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    
    # Create mock installation environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    
    # Override paths for testing (force override after app.conf)
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export LIB_DIR="$SWITCHER_DIR/lib"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    

}

teardown_all() {
    # Clean up mock environment
    rm -rf "$MOCK_HOME"
}

# Test configuration loading
describe "Integration Tests - Configuration System"

context "When loading configurations"

it "should load all configuration files successfully"
# Copy config files to test environment
mkdir -p "$CONFIG_DIR"
cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
assert_success "All configurations should load" "config_load_all \"$CONFIG_DIR\""

it "should validate configuration completeness"
# Use the absolute path from setup_all to avoid variable override issues
test_config_dir="$TEMP_DIR/mock_home/.claude/claude-model-switcher/config"
test_config_validation() {
    local config_dir="$1"
    config_load_all "$config_dir" "true" && validate_configuration_completeness
}
assert_success "Configuration should be complete" "test_config_validation '$test_config_dir'"

# Test directory structure creation
describe "Integration Tests - Directory Structure"

context "When creating directory structure"

it "should create all required directories"
assert_success "Environment validation should create directories" "config_validate_environment"

it "should create switcher directory"
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"

it "should create config directory"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"

it "should create memory directory"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

it "should create log directory"
assert_dir_exists "Log directory should exist" "$LOG_DIR"

# Test model configuration
describe "Integration Tests - Model Configuration"

context "When working with model configuration"

it "should load model definitions"
assert_success "Model configuration should load" "config_load '$MODEL_CONFIG_FILE'"

it "should have default models configured"
# Source the models config to check arrays
source "$MODEL_CONFIG_FILE"
assert_success "Should have kimi model" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"
assert_success "Should have glm4 model" "[ -n \"\${MODEL_PROVIDERS[glm4]}\" ]"

# Test system validation
describe "Integration Tests - System Validation"

context "When validating system requirements"

it "should validate bash version"
assert_success "Bash version should be valid" "validate_shell_type"

it "should check required commands"
assert_success "Required commands should be available" "command -v curl && command -v sed && command -v grep"
```

`claude-model-switcher/tests/results/test_report.txt`:

```txt
Claude Model Switcher - Test Report
Generated: Tue Aug 19 02:20:26 UTC 2025

TEST SUMMARY:
=============
Total Tests: 86
Passed: 86
Failed: 0
Skipped: 0

PASS RATE: 100%

RESULT: PASSED

```

`claude-model-switcher/tests/test_runner.sh`:

```sh
#!/bin/bash

# Test Runner - Simple TDD/BDD Framework for Bash
# Supports unit tests, integration tests, and BDD scenarios

# Test framework configuration
TEST_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$TEST_DIR")"
RESULTS_DIR="$TEST_DIR/results"
TEMP_DIR="$TEST_DIR/temp"

# Test statistics
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test framework functions

# Initialize test environment
test_init() {
    echo -e "${BLUE}ğŸ§ª Initializing Test Environment${NC}"
    
    # Create necessary directories
    mkdir -p "$RESULTS_DIR"
    mkdir -p "$TEMP_DIR"
    
    # Clean up previous test results
    rm -f "$RESULTS_DIR"/*.log
    rm -rf "$TEMP_DIR"/*
    
    # Initialize test statistics
    TESTS_TOTAL=0
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_SKIPPED=0
    
    echo "Test directory: $TEST_DIR"
    echo "Project directory: $PROJECT_DIR"
    echo "Results directory: $RESULTS_DIR"
    echo ""
}

# Test assertion functions

# Assert that a command succeeds
assert_success() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  âœ“ $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Command: $command"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a command fails
assert_failure() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  âœ— $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${RED}FAIL${NC}"
        echo "    Expected command to fail: $command"
        ((TESTS_FAILED++))
        return 1
    else
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    fi
}

# Assert that two strings are equal
assert_equals() {
    local description="$1"
    local expected="$2"
    local actual="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  = $description... "
    
    if [ "$expected" = "$actual" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Expected: '$expected'"
        echo "    Actual: '$actual'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a file exists
assert_file_exists() {
    local description="$1"
    local file_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ“ $description... "
    
    if [ -f "$file_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    File not found: $file_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a directory exists
assert_dir_exists() {
    local description="$1"
    local dir_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ“‚ $description... "
    
    if [ -d "$dir_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Directory not found: $dir_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a string contains a substring
assert_contains() {
    local description="$1"
    local haystack="$2"
    local needle="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ğŸ” $description... "
    
    if [[ "$haystack" == *"$needle"* ]]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    String '$needle' not found in: '$haystack'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Skip a test
skip_test() {
    local description="$1"
    local reason="$2"
    
    ((TESTS_TOTAL++))
    ((TESTS_SKIPPED++))
    
    echo -e "  â­ï¸  $description... ${YELLOW}SKIP${NC}"
    if [ -n "$reason" ]; then
        echo "    Reason: $reason"
    fi
}

# BDD-style functions

# Describe a test suite
describe() {
    local suite_name="$1"
    echo -e "${BLUE}ğŸ“‹ $suite_name${NC}"
}

# Define a test context
context() {
    local context_name="$1"
    echo -e "${BLUE}  ğŸ“ $context_name${NC}"
}

# Define a test case
it() {
    local test_name="$1"
    echo -e "    ğŸ§ª $test_name"
}

# Test setup and teardown - empty by default
setup() { :; }
teardown() { :; }
setup_all() { :; }
teardown_all() { :; }

# Test discovery and execution

# Run a single test file
run_test_file() {
    local test_file="$1"
    
    if [ ! -f "$test_file" ]; then
        echo -e "${RED}âŒ Test file not found: $test_file${NC}"
        return 1
    fi
    
    echo -e "${BLUE}ğŸš€ Running test file: $(basename "$test_file")${NC}"
    echo ""
    
    # Reset functions for this test file
    setup_all() { :; }
    teardown_all() { :; }
    
    # Source the test file in a controlled manner
    set +e  # Don't exit on errors
    
    # First, source only the function definitions (setup_all, teardown_all)
    # by creating a temporary file with only function definitions
    local temp_functions_file="$TEMP_DIR/$(basename "$test_file").functions"
    
    # Extract function definitions from the test file
    awk '/^(setup_all|teardown_all)\(\)/ {p=1} p && /^}$/ {print; p=0; next} p' "$test_file" > "$temp_functions_file"
    
    # Source the function definitions
    source "$temp_functions_file"
    
    # If setup_all is defined, call it first
    if declare -f setup_all >/dev/null 2>&1; then
        setup_all 2>/dev/null || echo -e "${YELLOW}âš ï¸  Warning: setup_all failed${NC}"
    fi
    
    # Now source the full test file to run the tests
    source "$test_file"
    
    # If teardown_all is defined, call it
    if declare -f teardown_all >/dev/null 2>&1; then
        teardown_all 2>/dev/null || echo -e "${YELLOW}âš ï¸  Warning: teardown_all failed${NC}"
    fi
    
    # Clean up temporary file
    rm -f "$temp_functions_file"
    
    set -e  # Re-enable exit on error
    
    echo ""
    return 0
}

# Run all test files in a directory
run_test_directory() {
    local test_dir="$1"
    
    if [ ! -d "$test_dir" ]; then
        echo -e "${RED}âŒ Test directory not found: $test_dir${NC}"
        return 1
    fi
    
    echo -e "${BLUE}ğŸ” Discovering tests in: $test_dir${NC}"
    
    local test_files
    test_files=($(find "$test_dir" -name "test_*.sh" -type f | sort))
    
    if [ ${#test_files[@]} -eq 0 ]; then
        echo -e "${YELLOW}âš ï¸  No test files found in: $test_dir${NC}"
        return 0
    fi
    
    echo "Found ${#test_files[@]} test files"
    echo ""
    
    for test_file in "${test_files[@]}"; do
        run_test_file "$test_file"
    done
}

# Generate test report
generate_report() {
    local report_file="$RESULTS_DIR/test_report.txt"
    
    echo "Generating test report: $report_file"
    
    cat > "$report_file" << EOF
Claude Model Switcher - Test Report
Generated: $(date)

TEST SUMMARY:
=============
Total Tests: $TESTS_TOTAL
Passed: $TESTS_PASSED
Failed: $TESTS_FAILED
Skipped: $TESTS_SKIPPED

PASS RATE: $(( TESTS_TOTAL > 0 ? TESTS_PASSED * 100 / TESTS_TOTAL : 0 ))%

EOF

    if [ $TESTS_FAILED -gt 0 ]; then
        echo "RESULT: FAILED" >> "$report_file"
    else
        echo "RESULT: PASSED" >> "$report_file"
    fi
    
    echo "Test report generated: $report_file"
}

# Display test summary
display_summary() {
    echo ""
    echo -e "${BLUE}ğŸ“Š TEST SUMMARY${NC}"
    echo "================"
    echo "Total Tests: $TESTS_TOTAL"
    echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
    echo -e "Failed: ${RED}$TESTS_FAILED${NC}"
    echo -e "Skipped: ${YELLOW}$TESTS_SKIPPED${NC}"
    
    if [ $TESTS_TOTAL -gt 0 ]; then
        local pass_rate=$((TESTS_PASSED * 100 / TESTS_TOTAL))
        echo "Pass Rate: $pass_rate%"
    fi
    
    echo ""
    
    if [ $TESTS_FAILED -gt 0 ]; then
        echo -e "${RED}âŒ TESTS FAILED${NC}"
        return 1
    else
        echo -e "${GREEN}âœ… ALL TESTS PASSED${NC}"
        return 0
    fi
}

# Cleanup test environment
test_cleanup() {
    echo -e "${BLUE}ğŸ§¹ Cleaning up test environment${NC}"
    
    # Remove temporary files
    rm -rf "$TEMP_DIR"/*
    
    echo "Cleanup completed"
}

# Main test runner function
run_tests() {
    local target="${1:-all}"
    
    test_init
    
    case "$target" in
        "all")
            run_test_directory "$TEST_DIR/unit"
            run_test_directory "$TEST_DIR/integration"
            run_test_directory "$TEST_DIR/bdd"
            ;;
        "unit")
            run_test_directory "$TEST_DIR/unit"
            ;;
        "integration")
            run_test_directory "$TEST_DIR/integration"
            ;;
        "bdd")
            run_test_directory "$TEST_DIR/bdd"
            ;;
        *)
            if [ -f "$target" ]; then
                run_test_file "$target"
            elif [ -d "$target" ]; then
                run_test_directory "$target"
            else
                echo -e "${RED}âŒ Unknown test target: $target${NC}"
                return 1
            fi
            ;;
    esac
    
    generate_report
    display_summary
    local result=$?
    
    test_cleanup
    
    return $result
}

# Help function
show_help() {
    cat << EOF
Test Runner - TDD/BDD Framework for Claude Model Switcher

USAGE:
    $0 [TARGET]

TARGETS:
    all           Run all tests (unit + integration + bdd)
    unit          Run unit tests only
    integration   Run integration tests only
    bdd           Run BDD tests only
    <file>        Run a specific test file
    <directory>   Run all tests in a directory

EXAMPLES:
    $0                          # Run all tests
    $0 unit                     # Run unit tests
    $0 tests/unit/test_logger.sh # Run specific test file

TEST FILE NAMING:
    test_*.sh                   # Test files must start with 'test_'

ASSERTION FUNCTIONS:
    assert_success              # Command should succeed
    assert_failure              # Command should fail
    assert_equals               # String equality
    assert_file_exists          # File exists
    assert_dir_exists           # Directory exists
    assert_contains             # String contains substring
    skip_test                   # Skip a test

BDD FUNCTIONS:
    describe                    # Test suite description
    context                     # Test context
    it                          # Test case description

SETUP/TEARDOWN:
    setup                       # Run before each test
    teardown                    # Run after each test
    setup_all                   # Run once before all tests
    teardown_all                # Run once after all tests
EOF
}

# Main execution
main() {
    local command="${1:-all}"
    
    case "$command" in
        "help"|"--help"|"-h")
            show_help
            ;;
        *)
            run_tests "$command"
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

`claude-model-switcher/tests/unit/test_logger.sh`:

```sh
#!/bin/bash

# Unit Tests for Logger Module

# Setup test environment
setup_all() {
    # Create temporary log directory for testing
    TEST_LOG_DIR="$TEMP_DIR/logs"
    mkdir -p "$TEST_LOG_DIR"
    
    # Set test configuration before sourcing logger
    export LOG_DIR="$TEST_LOG_DIR"
    export LOG_FILE="$TEST_LOG_DIR/test.log"
    export LOG_LEVEL="DEBUG"
    export USE_EMOJIS="true"
    
    # Source the logger module after setting environment
    source "$PROJECT_DIR/lib/core/logger.sh"
    
    # Initialize logger
    logger_init
    
    # Verify initialization
    if [ ! -f "$LOG_FILE" ]; then
        touch "$LOG_FILE"
    fi
    
    # Export variables for test assertions
    export TEST_LOG_DIR
}

teardown_all() {
    # Clean up test logs
    rm -rf "$TEST_LOG_DIR"
}

# Test logger initialization
describe "Logger Module - Initialization"

context "When initializing logger"

it "should create log directory"
assert_dir_exists "Log directory should be created" "$TEST_LOG_DIR"

it "should create log file"
assert_file_exists "Log file should be created" "$LOG_FILE"

it "should set global variables"
assert_equals "LOGGER_FILE should be set" "$LOG_FILE" "$LOGGER_FILE"
assert_equals "LOGGER_LEVEL should be set" "DEBUG" "$LOGGER_LEVEL"

# Test logging functions
describe "Logger Module - Logging Functions"

context "When logging messages"

it "should log debug messages"
log_debug "Test debug message"
assert_success "Debug message should be logged" "grep 'Test debug message' '$LOG_FILE'"

it "should log info messages"
log_info "Test info message"
assert_success "Info message should be logged" "grep 'Test info message' '$LOG_FILE'"

it "should log warning messages"
log_warn "Test warning message"
assert_success "Warning message should be logged" "grep 'Test warning message' '$LOG_FILE'"

it "should log error messages"
log_error "Test error message"
assert_success "Error message should be logged" "grep 'Test error message' '$LOG_FILE'"

it "should log success messages"
log_success "Test success message"
assert_success "Success message should be logged" "grep 'Test success message' '$LOG_FILE'"

# Test log levels
describe "Logger Module - Log Levels"

context "When log level is INFO"

it "should not log debug messages when level is INFO"
export LOGGER_LEVEL="INFO"
log_debug "Debug message that should not appear"
assert_failure "Debug message should not be logged at INFO level" "grep 'Debug message that should not appear' '$LOG_FILE'"

it "should log info messages when level is INFO"
log_info "Info message that should appear"
assert_success "Info message should be logged at INFO level" "grep 'Info message that should appear' '$LOG_FILE'"

# Test log formatting
describe "Logger Module - Formatting"

context "When logging with timestamps"

it "should include timestamps in log file"
log_info "Timestamp test message"
assert_success "Log should contain timestamp" "grep '\\[.*\\] \\[INFO\\] Timestamp test message' '$LOG_FILE'"

# Test utility functions
describe "Logger Module - Utility Functions"

context "When using utility functions"

it "should create log separators"
log_separator "-" 10
assert_success "Log separator should be created" "grep -- '-----------*' '$LOG_FILE'"

it "should create log headers"
log_header "Test Header"
assert_success "Log header should be created" "grep 'Test Header' '$LOG_FILE'"
```

`claude-model-switcher/tests/unit/test_validator.sh`:

```sh
#!/bin/bash

# Unit Tests for Validator Module

setup_all() {
    # Initialize logger for testing first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise in tests
    export USE_EMOJIS="false"  # Reduce noise in test output
    mkdir -p "$LOG_DIR"
    
    # Source required modules in correct order
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Now source validator after logger is initialized
    source "$PROJECT_DIR/lib/core/validator.sh"
}

# Test model alias validation
describe "Validator Module - Model Alias Validation"

context "When validating model aliases"

it "should accept valid aliases"
assert_success "Valid alias 'kimi' should pass" "validate_model_alias 'kimi'"
assert_success "Valid alias 'glm4' should pass" "validate_model_alias 'glm4'"
assert_success "Valid alias 'my-model' should pass" "validate_model_alias 'my-model'"
assert_success "Valid alias 'model_123' should pass" "validate_model_alias 'model_123'"

it "should reject invalid aliases"
assert_failure "Empty alias should fail" "validate_model_alias ''"
assert_failure "Alias with spaces should fail" "validate_model_alias 'my model'"
assert_failure "Alias with special chars should fail" "validate_model_alias 'model@123'"
assert_failure "Too long alias should fail" "validate_model_alias 'this_is_a_very_long_model_alias_name'"

# Test provider name validation
describe "Validator Module - Provider Validation"

context "When validating provider names"

it "should accept valid providers"
export AVAILABLE_PROVIDERS="moonshot zhipu openai"
assert_success "Valid provider 'moonshot' should pass" "validate_provider_name 'moonshot'"
assert_success "Valid provider 'zhipu' should pass" "validate_provider_name 'zhipu'"

it "should reject invalid providers"
assert_failure "Empty provider should fail" "validate_provider_name ''"
assert_failure "Unknown provider should fail" "validate_provider_name 'unknown'"

# Test API key validation
describe "Validator Module - API Key Validation"

context "When validating API keys"

it "should accept valid API keys"
assert_success "Valid generic API key should pass" "validate_api_key 'sk-1234567890abcdef1234567890abcdef12345678'"
assert_success "Long API key should pass" "validate_api_key '1234567890abcdef1234567890abcdef12345678901234567890'"

it "should reject invalid API keys"
assert_failure "Empty API key should fail" "validate_api_key ''"
assert_failure "Too short API key should fail" "validate_api_key '123'"

# Test URL validation
describe "Validator Module - URL Validation"

context "When validating URLs"

it "should accept valid URLs"
assert_success "HTTPS URL should pass" "validate_url 'https://api.example.com'"
assert_success "HTTP URL should pass" "validate_url 'http://api.example.com'"
assert_success "URL with port should pass" "validate_url 'https://api.example.com:8080'"
assert_success "URL with path should pass" "validate_url 'https://api.example.com/v1/api'"

it "should reject invalid URLs"
assert_failure "Empty URL should fail" "validate_url ''"
assert_failure "Invalid protocol should fail" "validate_url 'ftp://example.com'"
assert_failure "No protocol should fail" "validate_url 'example.com'"
assert_failure "Invalid format should fail" "validate_url 'https://'"

# Test version validation
describe "Validator Module - Version Validation"

context "When validating version strings"

it "should accept valid versions"
assert_success "Semantic version should pass" "validate_version '1.0.0'"
assert_success "Version with pre-release should pass" "validate_version '1.0.0-alpha'"
assert_success "Version with build should pass" "validate_version '1.0.0-alpha.1'"

it "should reject invalid versions"
assert_failure "Empty version should fail" "validate_version ''"
assert_failure "Invalid format should fail" "validate_version '1.0'"
assert_failure "Non-numeric should fail" "validate_version 'v1.0.0'"

# Test file path validation
describe "Validator Module - File Path Validation"

context "When validating file paths"

it "should accept valid file paths"
assert_success "Absolute path should pass" "validate_file_path '/tmp/test.txt'"
assert_success "Relative path should pass" "validate_file_path 'config/app.conf'"

it "should reject invalid file paths"
assert_failure "Empty path should fail" "validate_file_path ''"

it "should check file existence when required"
# Create a test file
touch "$TEMP_DIR/existing_file.txt"
assert_success "Existing file should pass existence check" "validate_file_path '$TEMP_DIR/existing_file.txt' true"
assert_failure "Non-existing file should fail existence check" "validate_file_path '$TEMP_DIR/missing_file.txt' true"
```