Project Path: claude-model-switcher

Source Tree:

```txt
claude-model-switcher
├── CLAUDE.md
├── LICENSE
├── README.md
├── config
│   ├── app.conf
│   ├── models.conf
│   └── providers.conf
├── install.sh
├── lib
│   ├── core
│   │   ├── config_loader.sh
│   │   ├── logger.sh
│   │   └── validator.sh
│   ├── installers
│   │   ├── claude_installer.sh
│   │   └── nodejs_installer.sh
│   ├── managers
│   │   └── model_manager.sh
│   └── utils
├── main.sh
├── memory-bank
├── templates
└── tests
    ├── bdd
    │   └── test_user_scenarios.sh
    ├── integration
    │   └── test_installation.sh
    ├── results
    │   └── test_report.txt
    ├── temp
    ├── test_runner.sh
    └── unit
        ├── test_logger.sh
        └── test_validator.sh

```

`claude-model-switcher/CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 🏗️ Project Overview

**Claude Model Switcher v5.0.0** - A modular, configuration-driven Claude Code installer and multi-model management system with comprehensive testing support.

### Architecture Characteristics
- **Modular Design**: Single-responsibility modules (≤500 lines each)
- **Configuration-Driven**: All settings in external config files
- **Test-First**: TDD/BDD framework with unit, integration, and behavioral tests
- **Shell Integration**: Automatic shell configuration and CLI functions
- **Provider-Agnostic**: Supports multiple AI providers (Moonshot, Zhipu, etc.)

## 📁 Directory Structure

```
claude-model-switcher/
├── main.sh              # Entry point & command router
├── config/              # Configuration files
│   ├── app.conf        # Application settings
│   ├── models.conf     # Model definitions
│   └── providers.conf  # API provider configs
├── lib/                 # Core modules
│   ├── core/           # Foundation modules
│   │   ├── logger.sh   # Logging & output formatting
│   │   ├── config_loader.sh # Configuration management
│   │   └── validator.sh # Input validation & checks
│   ├── installers/     # Installation modules
│   │   ├── nodejs_installer.sh   # Node.js/NVM setup
│   │   └── claude_installer.sh   # Claude Code installation
│   └── managers/       # Runtime management
│       └── model_manager.sh # Model switching & management
└── tests/              # Test framework
    ├── test_runner.sh  # TDD/BDD test execution
    ├── unit/          # Module-level tests
    ├── integration/   # Cross-module tests
    └── bdd/           # User scenario tests
```

## 🚀 Common Commands

### Development Workflow
```bash
# Run all tests
./tests/test_runner.sh

# Run specific test types
./tests/test_runner.sh unit          # Unit tests only
./tests/test_runner.sh integration   # Integration tests
./tests/test_runner.sh bdd          # BDD scenarios

# Run single test file
./tests/test_runner.sh tests/unit/test_logger.sh

# Install development environment
./main.sh install

# Check system status
./main.sh status

# List available models
./main.sh list-models

# Switch model provider
./main.sh use-model kimi
```

### Shell Functions (Post-Installation)
```bash
# Available after source ~/.bashrc
list_models                    # List all configured models
use_model <model-name>        # Switch to specific model
```

## 🔧 Key Configuration Files

### Primary Configs
- **config/app.conf**: Application settings, paths, versions
- **config/models.conf**: Model definitions & metadata
- **config/providers.conf**: API provider configurations

### Environment Variables
- `CLAUDE_SWITCHER_DIR`: Installation directory
- `CLAUDE_MODELS_CONF`: Model configuration path
- `LOG_LEVEL`: Debug/INFO/WARN/ERROR

## 🧪 Testing Framework

### Test Types
- **Unit Tests**: `tests/unit/` - Individual module validation
- **Integration Tests**: `tests/integration/` - Module interactions
- **BDD Tests**: `tests/bdd/` - User scenario validation

### Test Functions Available
```bash
# Assertions
assert_success "description" "command"
assert_failure "description" "command"
assert_equals "description" "expected" "actual"
assert_file_exists "description" "path"
assert_contains "description" "string" "substring"

# BDD Structure
describe "Feature Name"
context "Scenario Context"
it "should behave correctly"
```

## 🎯 Core Module Responsibilities

### Core Modules (`lib/core/`)
- **logger.sh**: Colorized output, log levels, file logging
- **config_loader.sh**: Config validation, caching, reload detection
- **validator.sh**: System requirements, input validation

### Installers (`lib/installers/`)
- **nodejs_installer.sh**: Node.js/NVM version management
- **claude_installer.sh**: Claude Code CLI installation

### Managers (`lib/managers/`)
- **model_manager.sh**: Model switching, API provider coordination

## 📊 Quality Gates

Before committing changes:
1. **Tests Pass**: `./tests/test_runner.sh` must succeed
2. **Config Validation**: All config files must be valid
3. **Shell Compatibility**: Test on bash/zsh
4. **Error Handling**: All edge cases handled gracefully

## 🔄 Extension Patterns

### Adding New Models
1. Edit `config/models.conf`: Add model metadata
2. Edit `config/providers.conf`: Add provider config
3. Update `lib/managers/model_manager.sh`: Add provider logic
4. Add tests in appropriate test directories

### Adding New Modules
1. Create module in appropriate `lib/` subdirectory
2. Follow existing naming: `<function>_module.sh`
3. Add comprehensive tests
4. Include in `main.sh` module loading

## 🛠️ Development Tips

### Debugging
```bash
# Enable debug logging
export LOG_LEVEL="DEBUG"
./main.sh <command>

# Check logs
tail -f ~/.claude/claude-model-switcher/logs/installer.log
```

### Testing Changes
```bash
# Quick validation
./tests/test_runner.sh unit/test_logger.sh

# Full system test
./tests/test_runner.sh
```

### Module Testing
```bash
# Test individual module
source lib/core/logger.sh && logger_init && log_info "test"
```

## 🔍 Key Patterns Used

- **Configuration Over Code**: All settings externalized
- **Single Responsibility**: Each module has one clear purpose
- **Dependency Injection**: Modules sourced dynamically
- **Defensive Programming**: Extensive validation and error handling
- **Atomic Operations**: Safe configuration changes with rollback
- **Observability**: Structured logging and status reporting
```

`claude-model-switcher/LICENSE`:

```
MIT License

Copyright (c) 2025 stark-y

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`claude-model-switcher/README.md`:

```md
# Claude Model Switcher v5.0.0 - 模块化架构

一个强大的 Claude Code 安装器和多模型管理系统，采用模块化架构设计，遵循《设计模式》和《代码简洁之道》的最佳实践。

## 🏗️ 架构特性

### ✨ 核心改进

- **模块化设计**: 将单个378行文件拆分为多个专门模块，每个模块不超过500行
- **配置驱动**: 完全消除硬编码，所有配置集中管理
- **测试驱动**: 支持TDD/BDD的完整测试框架
- **关注点分离**: 每个模块职责单一，易于维护和扩展
- **依赖注入**: 模块间松耦合，便于单独测试

### 🎯 设计原则

1. **单一职责原则 (SRP)**: 每个模块只负责一个功能域
2. **开闭原则 (OCP)**: 对扩展开放，对修改关闭
3. **依赖倒置原则 (DIP)**: 依赖抽象而非具体实现
4. **配置化管理**: 所有可变参数外部化配置
5. **测试优先**: 支持单元测试、集成测试和BDD场景测试

## 📁 目录结构

```
claude-model-switcher/
├── main.sh                    # 主入口点 - 模块编排器
├── install.sh                 # 简化的安装引导脚本
├── config/                    # 配置文件目录
│   ├── app.conf              # 应用程序配置
│   ├── models.conf           # 模型定义配置
│   └── providers.conf        # 提供商配置
├── lib/                      # 核心库目录
│   ├── core/                 # 核心模块
│   │   ├── logger.sh         # 日志模块
│   │   ├── config_loader.sh  # 配置加载器
│   │   └── validator.sh      # 验证器模块
│   ├── installers/           # 安装器模块
│   │   ├── nodejs_installer.sh  # Node.js安装器
│   │   └── claude_installer.sh  # Claude Code安装器
│   ├── managers/             # 管理器模块
│   │   └── model_manager.sh  # 模型管理器
│   └── utils/                # 工具模块 (待扩展)
├── tests/                    # 测试框架
│   ├── test_runner.sh        # 测试运行器
│   ├── unit/                 # 单元测试
│   ├── integration/          # 集成测试
│   └── bdd/                  # BDD场景测试
└── templates/                # 模板文件 (待扩展)
```

## 🚀 快速开始

### 安装

```bash
# 克隆或下载项目
git clone <repository-url>
cd claude-model-switcher

# 运行安装脚本
./install.sh
```

### 基本使用

```bash
# 列出可用模型
list_models

# 切换到指定模型
use_model kimi

# 使用 Claude Code
claude "你的提示词"
```

### 高级管理

```bash
# 使用完整CLI
~/.claude/claude-model-switcher/main.sh --help

# 系统状态检查
~/.claude/claude-model-switcher/main.sh status

# 添加自定义模型
~/.claude/claude-model-switcher/main.sh add-model my-model openai gpt-4

# 运行测试
~/.claude/claude-model-switcher/tests/test_runner.sh
```

## 🔧 模块详解

### 核心模块 (lib/core/)

#### logger.sh - 日志模块
- **职责**: 统一的日志记录和输出格式化
- **特性**: 多级别日志、文件输出、彩色控制台输出
- **函数**: `log_info()`, `log_error()`, `log_success()`, `log_debug()`

#### config_loader.sh - 配置加载器
- **职责**: 配置文件的加载、验证和缓存管理
- **特性**: 自动重载、语法验证、依赖检查
- **函数**: `config_load()`, `config_validate_syntax()`, `config_load_all()`

#### validator.sh - 验证器模块
- **职责**: 输入验证和系统环境检查
- **特性**: 多种验证规则、详细错误信息
- **函数**: `validate_model_alias()`, `validate_api_key()`, `validate_system_requirements()`

### 安装器模块 (lib/installers/)

#### nodejs_installer.sh - Node.js安装器
- **职责**: Node.js和NVM的安装管理
- **特性**: 版本检查、平台适配、安装验证
- **函数**: `install_nodejs()`, `validate_nodejs()`, `upgrade_nodejs()`

#### claude_installer.sh - Claude Code安装器
- **职责**: Claude Code CLI的安装和配置
- **特性**: NPM包管理、配置文件生成
- **函数**: `install_claude_code()`, `update_claude_code()`, `test_claude_installation()`

### 管理器模块 (lib/managers/)

#### model_manager.sh - 模型管理器
- **职责**: AI模型的切换、配置和管理
- **特性**: 动态配置加载、提供商适配、会话管理
- **函数**: `list_models()`, `use_model()`, `add_model()`, `remove_model()`

## 🧪 测试框架

### 测试类型

1. **单元测试** (`tests/unit/`): 测试单个模块的功能
2. **集成测试** (`tests/integration/`): 测试模块间的协作
3. **BDD测试** (`tests/bdd/`): 基于用户场景的行为驱动测试

### 运行测试

```bash
# 运行所有测试
./tests/test_runner.sh

# 运行特定类型的测试
./tests/test_runner.sh unit
./tests/test_runner.sh integration
./tests/test_runner.sh bdd

# 运行特定测试文件
./tests/test_runner.sh tests/unit/test_logger.sh
```

### 测试断言函数

- `assert_success()` - 命令应该成功
- `assert_failure()` - 命令应该失败
- `assert_equals()` - 字符串相等
- `assert_file_exists()` - 文件存在
- `assert_contains()` - 字符串包含

## ⚙️ 配置管理

### 配置文件

#### config/app.conf - 应用配置
```bash
APP_VERSION="5.0.0"
SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
CLAUDE_DEFAULT_TEMPERATURE="0.6"
LOG_LEVEL="INFO"
```

#### config/models.conf - 模型配置
```bash
# 模型定义
MODEL_PROVIDERS["kimi"]="moonshot"
MODEL_API_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_CONTEXTS["kimi"]="128K tokens"
```

#### config/providers.conf - 提供商配置
```bash
# 提供商配置
PROVIDER_MOONSHOT_BASE_URL="https://api.moonshot.cn/anthropic/"
PROVIDER_ZHIPU_BASE_URL="https://open.bigmodel.cn/api/anthropic"
```

## 🔄 扩展指南

### 添加新的AI提供商

1. 在 `config/providers.conf` 中添加提供商配置
2. 在 `lib/managers/model_manager.sh` 中添加提供商逻辑
3. 更新 `config/models.conf` 中的可用提供商列表
4. 编写相应的测试用例

### 添加新的模块

1. 在适当的 `lib/` 子目录中创建新模块
2. 遵循现有的命名约定和代码风格
3. 在 `main.sh` 中引入新模块
4. 编写对应的单元测试和集成测试

### 自定义配置

所有配置都可以通过修改 `config/` 目录下的文件进行自定义，无需修改代码。

## 🛠️ 开发工具

### 代码风格
- 使用清晰的变量命名
- 全局配置使用大写，局部变量使用小写
- 每个函数包含详细注释
- 错误处理和返回码一致性

### 调试支持
```bash
# 启用调试模式
export LOG_LEVEL="DEBUG"

# 查看日志文件
tail -f ~/.claude/claude-model-switcher/logs/installer.log
```

## 📊 性能优化

- 配置文件缓存机制，避免重复加载
- 模块按需加载，减少启动时间
- 并行化处理，提升安装速度
- 智能备份策略，节省存储空间

## 🔒 安全特性

- API密钥仅在会话中存储，不写入文件
- 所有文件修改前自动备份
- 原子操作，防止配置损坏
- 输入验证，防止注入攻击

## 📈 监控和日志

- 结构化日志记录
- 多级别日志控制
- 操作审计追踪
- 性能指标收集

## 🤝 贡献指南

1. Fork 项目
2. 创建功能分支
3. 编写测试用例
4. 提交代码变更
5. 创建 Pull Request

## 📝 版本历史

### v5.0.0 (当前版本)
- 🎉 完全模块化重构
- ✅ 实现配置驱动架构
- 🧪 添加完整测试框架
- 📚 改进文档和用户体验

### v4.2.0 (遗留版本)
- 单文件架构
- 硬编码配置
- 基本功能实现

## 📞 支持

如有问题或建议，请：
1. 查看本文档
2. 运行 `./main.sh --help` 获取帮助
3. 检查日志文件
4. 提交 Issue

---

**Claude Model Switcher v5.0.0** - 让AI模型切换变得简单而强大！ 🚀

```

`claude-model-switcher/config/app.conf`:

```conf
# Claude Model Switcher Application Configuration
# Version: 5.0.0 (Modular Architecture)
# This file contains all application-level configurations

# Application Metadata
APP_NAME="Claude Model Switcher"
APP_VERSION="5.0.0"
APP_DESCRIPTION="Robust installer and manager for Claude Code with multi-model support"

# Directory Structure
SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
CONFIG_DIR="$SWITCHER_DIR/config"
LIB_DIR="$SWITCHER_DIR/lib"
MEMORY_DIR="$SWITCHER_DIR/memory"
LOG_DIR="$SWITCHER_DIR/logs"
BACKUP_DIR="$SWITCHER_DIR/backups"

# Configuration Files
MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
PROVIDERS_CONFIG_FILE="$CONFIG_DIR/providers.conf"
USER_CONFIG_FILE="$CONFIG_DIR/user.conf"

# Shell Integration
SHELL_CONFIG_MARKER="# CLAUDE_CODE_MODEL_MANAGER_V5"
SHELL_CONFIG_END_MARKER="# END_OF_CLAUDE_CONFIG"

# Node.js Configuration
NODE_MIN_VERSION="18"
NVM_VERSION="v0.39.7"
NVM_INSTALL_URL="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh"

# Claude Code Configuration
CLAUDE_PACKAGE="@anthropic-ai/claude-code"
CLAUDE_DEFAULT_TEMPERATURE="0.6"
CLAUDE_DEFAULT_TIMEOUT="300000"

# Logging Configuration
LOG_LEVEL="INFO"  # DEBUG, INFO, WARN, ERROR
LOG_FILE="$LOG_DIR/installer.log"
LOG_MAX_SIZE="10M"
LOG_BACKUP_COUNT="5"

# Safety and Backup Configuration
ENABLE_BACKUPS="true"
BACKUP_RETENTION_DAYS="30"
ATOMIC_OPERATIONS="true"

# Feature Flags
ENABLE_DUAL_MODEL_SUPPORT="true"
ENABLE_TEMPERATURE_CONTROL="true"
ENABLE_TIMEOUT_CONTROL="true"
ENABLE_MEMORY_TRACKING="true"
ENABLE_SHELL_HOOKS="true"

# UI Configuration
USE_EMOJIS="true"
PROGRESS_BAR_WIDTH="50"
TABLE_WIDTH="110"


```

`claude-model-switcher/config/models.conf`:

```conf
# Claude Model Switcher Model Configuration
# This file defines all available AI models and their properties
# Requires Bash 4.0+ for associative arrays

# Associative arrays to hold model properties
# (Arrays are declared in config_loader.sh before sourcing this file)

# --- Moonshot Models ---

# Model: Kimi K2 Turbo Preview
MODEL_PROVIDERS["kimi"]="moonshot"
MODEL_API_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_SMALL_FAST_NAMES["kimi"]="kimi-k2-turbo-preview"
MODEL_CONTEXTS["kimi"]="128K tokens (Main & Fast)"
MODEL_DESCRIPTIONS["kimi"]="Moonshot Kimi K2 - Advanced reasoning and long context"
MODEL_CAPABILITIES["kimi"]="text,reasoning,code"

# --- Zhipu GLM Models ---

# Model: GLM-4.5 Series
MODEL_PROVIDERS["glm4"]="zhipu"
MODEL_API_NAMES["glm4"]="glm-4.5"
MODEL_SMALL_FAST_NAMES["glm4"]="glm-4.5-flash"
MODEL_CONTEXTS["glm4"]="32K tokens (Main) / 128K tokens (Fast)"
MODEL_DESCRIPTIONS["glm4"]="Zhipu GLM-4.5 - Balanced performance with fast variant"
MODEL_CAPABILITIES["glm4"]="text,reasoning,code,multimodal"

# --- Example Future Models (Commented) ---

# OpenAI GPT-4
# MODEL_PROVIDERS["gpt4"]="openai"
# MODEL_API_NAMES["gpt4"]="gpt-4"
# MODEL_SMALL_FAST_NAMES["gpt4"]="gpt-3.5-turbo"
# MODEL_CONTEXTS["gpt4"]="8K tokens (Main) / 4K tokens (Fast)"
# MODEL_DESCRIPTIONS["gpt4"]="OpenAI GPT-4 - Most capable model"
# MODEL_CAPABILITIES["gpt4"]="text,reasoning,code"

# Anthropic Claude
# MODEL_PROVIDERS["claude"]="anthropic"
# MODEL_API_NAMES["claude"]="claude-3-opus"
# MODEL_SMALL_FAST_NAMES["claude"]="claude-3-sonnet"
# MODEL_CONTEXTS["claude"]="200K tokens (Main) / 200K tokens (Fast)"
# MODEL_DESCRIPTIONS["claude"]="Anthropic Claude 3 - Excellent reasoning"
# MODEL_CAPABILITIES["claude"]="text,reasoning,code,analysis"

# Model Registry
# List of all available model aliases (used for validation and iteration)
AVAILABLE_MODELS="kimi glm4"

# Default Model Settings
DEFAULT_MODEL="kimi"
FALLBACK_MODEL="glm4"

# Model Categories
TEXT_MODELS="kimi glm4"
CODE_MODELS="kimi glm4"
MULTIMODAL_MODELS="glm4"
REASONING_MODELS="kimi glm4"


```

`claude-model-switcher/config/providers.conf`:

```conf
# Claude Model Switcher Provider Configuration
# This file defines all supported AI model providers

# Provider Configuration Format:
# PROVIDER_<NAME>_BASE_URL="base_url"
# PROVIDER_<NAME>_AUTH_TYPE="bearer|api_key"
# PROVIDER_<NAME>_DESCRIPTION="description"

# Moonshot Provider Configuration
PROVIDER_MOONSHOT_BASE_URL="https://api.moonshot.cn/anthropic/"
PROVIDER_MOONSHOT_AUTH_TYPE="bearer"
PROVIDER_MOONSHOT_DESCRIPTION="Moonshot AI - Kimi series models"
PROVIDER_MOONSHOT_SUPPORTED_MODELS="kimi-k2-turbo-preview"

# Zhipu GLM Provider Configuration
PROVIDER_ZHIPU_BASE_URL="https://open.bigmodel.cn/api/anthropic"
PROVIDER_ZHIPU_AUTH_TYPE="bearer"
PROVIDER_ZHIPU_DESCRIPTION="Zhipu AI - GLM series models"
PROVIDER_ZHIPU_SUPPORTED_MODELS="glm-4.5,glm-4.5-flash"

# OpenAI Provider Configuration (Example for future extension)
PROVIDER_OPENAI_BASE_URL="https://api.openai.com/v1"
PROVIDER_OPENAI_AUTH_TYPE="bearer"
PROVIDER_OPENAI_DESCRIPTION="OpenAI - GPT series models"
PROVIDER_OPENAI_SUPPORTED_MODELS="gpt-4,gpt-3.5-turbo"

# Anthropic Provider Configuration (Example for future extension)
PROVIDER_ANTHROPIC_BASE_URL="https://api.anthropic.com"
PROVIDER_ANTHROPIC_AUTH_TYPE="api_key"
PROVIDER_ANTHROPIC_DESCRIPTION="Anthropic - Claude series models"
PROVIDER_ANTHROPIC_SUPPORTED_MODELS="claude-3-opus,claude-3-sonnet"

# Provider Registry
# List of all available providers (used for validation and iteration)
AVAILABLE_PROVIDERS="moonshot zhipu openai anthropic"

# Default Provider Settings
DEFAULT_PROVIDER="moonshot"
FALLBACK_PROVIDER="zhipu"


```

`claude-model-switcher/install.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Simplified Installation Script
# Version 5.0.0 - Modular Architecture
# This script bootstraps the modular installation system

set -e

# Script metadata
SCRIPT_VERSION="5.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_TARGET="$HOME/.claude/claude-model-switcher"

# Simple logging for bootstrap
log_info() {
    echo "ℹ️  $1"
}

log_success() {
    echo "✅ $1"
}

log_error() {
    echo "❌ $1"
}

log_progress() {
    echo "🚀 $1"
}

# Bootstrap installation
bootstrap_install() {
    log_info "Claude Model Switcher v$SCRIPT_VERSION - Modular Installation"
    echo "================================================================="
    
    # Check if we're running from the correct location
    if [ ! -f "$SCRIPT_DIR/main.sh" ]; then
        log_error "main.sh not found. Please ensure you're running from the correct directory."
        exit 1
    fi
    
    # Check if already installed
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_info "Existing installation detected at: $INSTALL_TARGET"
        echo -n "Do you want to update the existing installation? [y/N]: "
        read -r update_choice
        
        case "$update_choice" in
            [yY]|[yY][eS]|[yY][eE][sS])
                log_progress "Updating existing installation..."
                ;;
            *)
                log_info "Installation cancelled by user"
                exit 0
                ;;
        esac
    fi
    
    # Create installation directory
    log_progress "Creating installation directory: $INSTALL_TARGET"
    mkdir -p "$INSTALL_TARGET"
    
    # Copy all files to installation directory
    log_progress "Copying modular system files..."
    cp -r "$SCRIPT_DIR"/* "$INSTALL_TARGET/"
    
    # Make scripts executable
    chmod +x "$INSTALL_TARGET/main.sh"
    chmod +x "$INSTALL_TARGET/tests/test_runner.sh"
    
    log_success "Modular system files copied successfully"
    
    # Run the modular installation
    log_progress "Running modular installation process..."
    cd "$INSTALL_TARGET"
    
    if ./main.sh install; then
        log_success "Installation completed successfully!"
        echo ""
        log_info "The modular system is now installed at: $INSTALL_TARGET"
        log_info "You can manage it using: $INSTALL_TARGET/main.sh [command]"
        echo ""
        log_info "Quick start:"
        log_info "1. Source your shell configuration: source ~/.bashrc"
        log_info "2. List models: list_models"
        log_info "3. Use a model: use_model kimi"
    else
        log_error "Installation failed!"
        exit 1
    fi
}

# Uninstall function
uninstall() {
    log_info "Uninstalling Claude Model Switcher..."
    
    if [ -d "$INSTALL_TARGET" ] && [ -f "$INSTALL_TARGET/main.sh" ]; then
        log_progress "Running modular uninstallation..."
        cd "$INSTALL_TARGET"
        ./main.sh uninstall
    else
        log_info "Modular system not found, cleaning up manually..."
        
        # Manual cleanup for legacy installations
        local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
        for shell_file in "${shell_files[@]}"; do
            if [ -f "$shell_file" ] && grep -q "CLAUDE_CODE_MODEL_MANAGER" "$shell_file"; then
                log_progress "Cleaning shell configuration: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.cleanup_backup.$(date +%Y%m%d_%H%M%S)"
                # Remove old configuration blocks (both V4 and V5)
                sed -i '/# CLAUDE_CODE_MODEL_MANAGER/,/# END_OF_CLAUDE_CONFIG/d' "$shell_file"
            fi
        done
        
        # Remove installation directory
        if [ -d "$INSTALL_TARGET" ]; then
            rm -rf "$INSTALL_TARGET"
            log_success "Installation directory removed"
        fi
        
        # Remove parent directory if empty
        local parent_dir
        parent_dir=$(dirname "$INSTALL_TARGET")
        if [ -d "$parent_dir" ] && [ -z "$(ls -A "$parent_dir" 2>/dev/null)" ]; then
            rmdir "$parent_dir"
        fi
    fi
    
    log_success "Uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Show help
show_help() {
    cat << EOF
Claude Model Switcher v$SCRIPT_VERSION - Installation Script

USAGE:
    $0 [OPTION]

OPTIONS:
    (no option)    Install or update Claude Model Switcher
    --uninstall    Remove Claude Model Switcher completely
    --help         Show this help message

DESCRIPTION:
    This script installs the modular Claude Model Switcher system.
    The system will be installed to: $INSTALL_TARGET

FEATURES:
    • Modular architecture with clean separation of concerns
    • Configuration-driven (no hardcoded values)
    • Comprehensive test suite with TDD/BDD support
    • Support for multiple AI model providers
    • Automatic shell integration
    • Safe installation with backups

EXAMPLES:
    $0                 # Install or update
    $0 --uninstall     # Complete removal
    $0 --help          # Show this help

After installation, you can use:
    list_models        # List available models
    use_model <alias>  # Switch to a model
    
Or use the full CLI:
    $INSTALL_TARGET/main.sh [command]

EOF
}

# Main execution
main() {
    local command="${1:-install}"
    
    case "$command" in
        "install"|"")
            bootstrap_install
            ;;
        "--uninstall")
            uninstall
            ;;
        "--help"|"-h")
            show_help
            ;;
        *)
            log_error "Unknown option: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"

```

`claude-model-switcher/lib/core/config_loader.sh`:

```sh
#!/bin/bash

# Configuration Loader Module
# Handles loading and validation of configuration files

# Source the logger
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Global configuration variables
declare -A CONFIG_CACHE
declare -A CONFIG_FILE_TIMESTAMPS

# Load a configuration file
config_load() {
    local config_file="$1"
    local force_reload="${2:-false}"
    local config_name="${3:-$(basename "$config_file" .conf)}"
    
    if [ ! -f "$config_file" ]; then
        log_error "Configuration file not found: $config_file"
        return 1
    fi
    
    # Check if we need to reload based on file modification time
    local current_timestamp
    current_timestamp=$(stat -c %Y "$config_file" 2>/dev/null || echo "0")
    local cached_timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]:-0}"
    
    if [ "$force_reload" = "true" ] || [ "$current_timestamp" -gt "$cached_timestamp" ]; then
        log_debug "Loading configuration: $config_file"
        
        # Validate configuration file syntax
        if ! config_validate_syntax "$config_file"; then
            log_error "Configuration file has syntax errors: $config_file"
            return 1
        fi
        
        # Pre-declare associative arrays for models.conf
        if [[ "$config_file" == *"models.conf" ]]; then
            declare -gA MODEL_PROVIDERS 2>/dev/null || true
            declare -gA MODEL_API_NAMES 2>/dev/null || true
            declare -gA MODEL_CONTEXTS 2>/dev/null || true
            declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
            declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
            declare -gA MODEL_CAPABILITIES 2>/dev/null || true
        fi
        
        # Source the configuration file
        if source "$config_file"; then
            CONFIG_FILE_TIMESTAMPS[$config_name]="$current_timestamp"
            CONFIG_CACHE[$config_name]="loaded"
            log_debug "Configuration loaded successfully: $config_name"
            return 0
        else
            log_error "Failed to load configuration: $config_file"
            return 1
        fi
    else
        log_debug "Configuration already loaded and up-to-date: $config_name"
        return 0
    fi
}

# Validate configuration file syntax
config_validate_syntax() {
    local config_file="$1"
    
    # Basic shell syntax check
    if ! bash -n "$config_file" 2>/dev/null; then
        log_error "Shell syntax error in configuration file: $config_file"
        return 1
    fi
    
    # Check for required variables based on file type
    local filename=$(basename "$config_file")
    case "$filename" in
        "app.conf")
            config_validate_app_config "$config_file"
            ;;
        "models.conf")
            config_validate_models_config "$config_file"
            ;;
        "providers.conf")
            config_validate_providers_config "$config_file"
            ;;
        *)
            log_debug "No specific validation rules for: $filename"
            return 0
            ;;
    esac
}

# Validate app configuration
config_validate_app_config() {
    local config_file="$1"
    local required_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    # Source config in a subshell to check variables
    for var in "${required_vars[@]}"; do
        if ! grep -q "^${var}=" "$config_file"; then
            log_error "Required variable '$var' not found in $config_file"
            return 1
        fi
    done
    
    log_debug "App configuration validation passed"
    return 0
}

# Validate models configuration
config_validate_models_config() {
    local config_file="$1"
    
    # Check for model assignments (arrays are declared externally)
    if ! grep -q "MODEL_PROVIDERS\[" "$config_file"; then
        log_error "No MODEL_PROVIDERS assignments found in $config_file"
        return 1
    fi
    
    if ! grep -q "MODEL_API_NAMES\[" "$config_file"; then
        log_error "No MODEL_API_NAMES assignments found in $config_file"
        return 1
    fi
    
    log_debug "Models configuration validation passed"
    return 0
}

# Validate providers configuration
config_validate_providers_config() {
    local config_file="$1"
    
    # Check for at least one provider configuration
    if ! grep -q "PROVIDER_.*_BASE_URL=" "$config_file"; then
        log_error "No provider configurations found in $config_file"
        return 1
    fi
    
    log_debug "Providers configuration validation passed"
    return 0
}

# Load all configuration files
config_load_all() {
    local config_dir="${1:-$HOME/.claude/claude-model-switcher/config}"
    local force_reload="${2:-false}"
    
    if [ ! -d "$config_dir" ]; then
        log_error "Configuration directory not found: $config_dir"
        return 1
    fi
    
    log_progress "Loading all configuration files from: $config_dir"
    
    # Load configurations in order of dependency
    local config_files=(
        "$config_dir/app.conf"
        "$config_dir/providers.conf"
        "$config_dir/models.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            if ! config_load "$config_file" "$force_reload"; then
                log_error "Failed to load configuration: $config_file"
                return 1
            fi
        else
            log_warn "Configuration file not found (optional): $config_file"
        fi
    done
    
    log_success "All configuration files loaded successfully"
    return 0
}

# Get configuration value with fallback
config_get() {
    local var_name="$1"
    local default_value="$2"
    
    # Check if variable is set
    if [ -n "${!var_name}" ]; then
        echo "${!var_name}"
    else
        log_debug "Configuration variable '$var_name' not set, using default: $default_value"
        echo "$default_value"
    fi
}

# Set configuration value
config_set() {
    local var_name="$1"
    local value="$2"
    
    export "$var_name"="$value"
    log_debug "Configuration variable set: $var_name=$value"
}

# Check if configuration is loaded
config_is_loaded() {
    local config_name="$1"
    [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]
}

# Reload specific configuration
config_reload() {
    local config_name="$1"
    local config_dir="${2:-$HOME/.claude/claude-model-switcher/config}"
    
    config_load "$config_dir/${config_name}.conf" "true" "$config_name"
}

# List loaded configurations
config_list_loaded() {
    log_info "Loaded configurations:"
    for config_name in "${!CONFIG_CACHE[@]}"; do
        if [ "${CONFIG_CACHE[$config_name]}" = "loaded" ]; then
            local timestamp="${CONFIG_FILE_TIMESTAMPS[$config_name]}"
            local date_str=$(date -d "@$timestamp" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
            log_indent info "$config_name (loaded at: $date_str)" 2
        fi
    done
}

# Validate current environment against configuration
config_validate_environment() {
    log_progress "Validating environment against configuration..."
    
    # Check bash version for associative arrays
    local bash_version="${BASH_VERSION%%.*}"
    if [ "$bash_version" -lt 4 ]; then
        log_error "Bash 4.0+ required for associative arrays. Current version: $BASH_VERSION"
        return 1
    fi
    
    # Check required directories
    local required_dirs=(
        "$SWITCHER_DIR"
        "$CONFIG_DIR"
        "$LIB_DIR"
        "$MEMORY_DIR"
        "$LOG_DIR"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ -n "$dir" ] && [ ! -d "$dir" ]; then
            log_warn "Required directory missing: $dir"
            mkdir -p "$dir" || {
                log_error "Failed to create directory: $dir"
                return 1
            }
            log_success "Created directory: $dir"
        fi
    done
    
    log_success "Environment validation completed"
    return 0
}


```

`claude-model-switcher/lib/core/logger.sh`:

```sh
#!/bin/bash

# Logger Module - Centralized logging functionality
# Supports different log levels and formatted output

# Initialize logger (should be called once)
logger_init() {
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    local log_file="${LOG_FILE:-$log_dir/installer.log}"
    
    # Ensure log directory exists
    mkdir -p "$log_dir"
    
    # Set global log file
    export LOGGER_FILE="$log_file"
    export LOGGER_LEVEL="${LOG_LEVEL:-INFO}"
    export LOGGER_USE_EMOJIS="${USE_EMOJIS:-true}"
    
    # Initialize log file with session header
    echo "=== New Session Started: $(date) ===" >> "$LOGGER_FILE"
}

# Get current timestamp
_get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Get emoji for log level
_get_emoji() {
    local level="$1"
    if [ "$LOGGER_USE_EMOJIS" != "true" ]; then
        echo ""
        return
    fi
    
    case "$level" in
        DEBUG) echo "🔍" ;;
        INFO)  echo "ℹ️" ;;
        WARN)  echo "⚠️" ;;
        ERROR) echo "❌" ;;
        SUCCESS) echo "✅" ;;
        PROGRESS) echo "🚀" ;;
        *) echo "📝" ;;
    esac
}

# Check if log level should be printed
_should_log() {
    local level="$1"
    local current_level="${LOGGER_LEVEL:-INFO}"
    
    case "$current_level" in
        DEBUG) return 0 ;;
        INFO)  [[ "$level" =~ ^(INFO|WARN|ERROR|SUCCESS|PROGRESS)$ ]] ;;
        WARN)  [[ "$level" =~ ^(WARN|ERROR|SUCCESS)$ ]] ;;
        ERROR) [[ "$level" =~ ^(ERROR|SUCCESS)$ ]] ;;
        *) return 0 ;;
    esac
}

# Core logging function
_log() {
    local level="$1"
    local message="$2"
    local to_file="${3:-true}"
    local to_console="${4:-true}"
    
    if ! _should_log "$level"; then
        return 0
    fi
    
    local timestamp="$(_get_timestamp)"
    local emoji="$(_get_emoji "$level")"
    local formatted_message="[$timestamp] [$level] $message"
    local console_message="$emoji $message"
    
    # Log to file
    if [ "$to_file" = "true" ] && [ -n "$LOGGER_FILE" ]; then
        # Ensure log directory exists before writing
        local log_dir
        log_dir=$(dirname "$LOGGER_FILE")
        if [ ! -d "$log_dir" ]; then
            mkdir -p "$log_dir" 2>/dev/null || true
        fi
        
        # Only write to file if we can create/access the directory
        if [ -d "$log_dir" ] && [ -w "$log_dir" ]; then
            echo "$formatted_message" >> "$LOGGER_FILE" 2>/dev/null || true
        fi
    fi
    
    # Log to console
    if [ "$to_console" = "true" ]; then
        echo "$console_message"
    fi
}

# Public logging functions
log_debug() {
    _log "DEBUG" "$1" "${2:-true}" "${3:-true}"
}

log_info() {
    _log "INFO" "$1" "${2:-true}" "${3:-true}"
}

log_warn() {
    _log "WARN" "$1" "${2:-true}" "${3:-true}"
}

log_error() {
    _log "ERROR" "$1" "${2:-true}" "${3:-true}"
}

log_success() {
    _log "SUCCESS" "$1" "${2:-true}" "${3:-true}"
}

log_progress() {
    _log "PROGRESS" "$1" "${2:-true}" "${3:-true}"
}

# Special logging functions
log_separator() {
    local char="${1:--}"
    local width="${2:-50}"
    local message=""
    
    for ((i=1; i<=width; i++)); do
        message+="$char"
    done
    
    log_info "$message"
}

log_header() {
    local title="$1"
    local width="${2:-50}"
    
    log_separator "=" "$width"
    log_info "$title"
    log_separator "=" "$width"
}

# Log with indentation (for nested operations)
log_indent() {
    local level="$1"
    local message="$2"
    local indent="${3:-2}"
    
    local spaces=""
    for ((i=1; i<=indent; i++)); do
        spaces+=" "
    done
    
    case "$level" in
        debug) log_debug "$spaces$message" ;;
        info)  log_info "$spaces$message" ;;
        warn)  log_warn "$spaces$message" ;;
        error) log_error "$spaces$message" ;;
        success) log_success "$spaces$message" ;;
        progress) log_progress "$spaces$message" ;;
    esac
}

# Log command execution
log_command() {
    local cmd="$1"
    local show_output="${2:-false}"
    
    log_debug "Executing command: $cmd"
    
    if [ "$show_output" = "true" ]; then
        eval "$cmd" 2>&1 | while read -r line; do
            log_indent debug "$line" 4
        done
        return "${PIPESTATUS[0]}"
    else
        eval "$cmd" >/dev/null 2>&1
        return $?
    fi
}

# Cleanup old log files
log_cleanup() {
    local retention_days="${BACKUP_RETENTION_DAYS:-30}"
    local log_dir="${LOG_DIR:-$HOME/.claude/claude-model-switcher/logs}"
    
    if [ -d "$log_dir" ]; then
        log_debug "Cleaning up log files older than $retention_days days"
        find "$log_dir" -name "*.log" -type f -mtime +"$retention_days" -delete 2>/dev/null || true
    fi
}


```

`claude-model-switcher/lib/core/validator.sh`:

```sh
#!/bin/bash

# Validator Module
# Provides validation functions for various inputs and system states

# Source dependencies
# Note: Logger functions are expected to be available in the environment
# This avoids circular dependencies during testing

# Validate system requirements
validate_system_requirements() {
    log_progress "Validating system requirements..."
    
    local errors=0
    
    # Check operating system
    local os_name=$(uname -s)
    case "$os_name" in
        Linux|Darwin)
            log_success "Operating system supported: $os_name"
            ;;
        *)
            log_error "Unsupported operating system: $os_name"
            ((errors++))
            ;;
    esac
    
    # Check bash version
    local bash_major="${BASH_VERSION%%.*}"
    if [ "$bash_major" -ge 4 ]; then
        log_success "Bash version supported: $BASH_VERSION"
    else
        log_error "Bash 4.0+ required. Current version: $BASH_VERSION"
        ((errors++))
    fi
    
    # Check required commands
    local required_commands=("curl" "sed" "grep" "mkdir" "cp" "rm")
    for cmd in "${required_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            log_debug "Required command available: $cmd"
        else
            log_error "Required command not found: $cmd"
            ((errors++))
        fi
    done
    
    # Check write permissions for home directory
    if [ -w "$HOME" ]; then
        log_success "Home directory is writable: $HOME"
    else
        log_error "Home directory is not writable: $HOME"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All system requirements validated successfully"
        return 0
    else
        log_error "System requirements validation failed with $errors errors"
        return 1
    fi
}

# Validate Node.js installation
validate_nodejs() {
    local min_version="${1:-18}"
    
    log_debug "Validating Node.js installation (minimum version: $min_version)"
    
    if ! command -v node >/dev/null 2>&1; then
        log_warn "Node.js not found"
        return 1
    fi
    
    local current_version
    current_version=$(node -v 2>/dev/null | sed 's/v//')
    
    if [ -z "$current_version" ]; then
        log_error "Could not determine Node.js version"
        return 1
    fi
    
    local major_version
    major_version=$(echo "$current_version" | cut -d. -f1)
    
    if [ "$major_version" -ge "$min_version" ]; then
        log_success "Node.js version meets requirements: v$current_version (>= v$min_version)"
        return 0
    else
        log_warn "Node.js version too old: v$current_version (< v$min_version)"
        return 1
    fi
}

# Validate Claude Code installation
validate_claude_code() {
    log_debug "Validating Claude Code installation"
    
    if ! command -v claude >/dev/null 2>&1; then
        log_warn "Claude Code not found"
        return 1
    fi
    
    local version
    if version=$(claude --version 2>/dev/null); then
        log_success "Claude Code is installed: $version"
        return 0
    else
        log_error "Claude Code installation appears corrupted"
        return 1
    fi
}

# Validate model alias
validate_model_alias() {
    local alias="$1"
    
    if [ -z "$alias" ]; then
        log_error "Model alias cannot be empty"
        return 1
    fi
    
    # Check if alias contains only allowed characters
    if [[ ! "$alias" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Model alias contains invalid characters: $alias"
        log_info "Allowed characters: letters, numbers, underscore, hyphen"
        return 1
    fi
    
    # Check alias length
    if [ ${#alias} -gt 20 ]; then
        log_error "Model alias too long (max 20 characters): $alias"
        return 1
    fi
    
    log_debug "Model alias validation passed: $alias"
    return 0
}

# Validate provider name
validate_provider_name() {
    local provider="$1"
    local available_providers="${2:-$AVAILABLE_PROVIDERS}"
    
    if [ -z "$provider" ]; then
        log_error "Provider name cannot be empty"
        return 1
    fi
    
    # Check if provider is in the list of available providers
    if [[ " $available_providers " =~ " $provider " ]]; then
        log_debug "Provider validation passed: $provider"
        return 0
    else
        log_error "Unknown provider: $provider"
        log_info "Available providers: $available_providers"
        return 1
    fi
}

# Validate API key format
validate_api_key() {
    local api_key="$1"
    local provider="${2:-generic}"
    
    if [ -z "$api_key" ]; then
        log_error "API key cannot be empty"
        return 1
    fi
    
    # Check minimum length
    if [ ${#api_key} -lt 10 ]; then
        log_error "API key too short (minimum 10 characters)"
        return 1
    fi
    
    # Provider-specific validation
    case "$provider" in
        "moonshot")
            if [[ "$api_key" =~ ^sk-[a-zA-Z0-9]{40,}$ ]]; then
                log_debug "Moonshot API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Moonshot (expected: sk-...)"
                return 0  # Warning only, don't fail
            fi
            ;;
        "zhipu")
            if [[ "$api_key" =~ ^[a-zA-Z0-9]{32,}$ ]]; then
                log_debug "Zhipu API key format validation passed"
                return 0
            else
                log_warn "API key format may be incorrect for Zhipu"
                return 0  # Warning only, don't fail
            fi
            ;;
        *)
            log_debug "Generic API key validation passed"
            return 0
            ;;
    esac
}

# Validate file path
validate_file_path() {
    local file_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$file_path" ]; then
        log_error "File path cannot be empty"
        return 1
    fi
    
    # Check if file must exist
    if [ "$must_exist" = "true" ] && [ ! -f "$file_path" ]; then
        log_error "File does not exist: $file_path"
        return 1
    fi
    
    # Check if file must be writable
    if [ "$must_be_writable" = "true" ]; then
        local dir_path
        dir_path=$(dirname "$file_path")
        if [ ! -w "$dir_path" ]; then
            log_error "Directory not writable: $dir_path"
            return 1
        fi
        
        if [ -f "$file_path" ] && [ ! -w "$file_path" ]; then
            log_error "File not writable: $file_path"
            return 1
        fi
    fi
    
    log_debug "File path validation passed: $file_path"
    return 0
}

# Validate directory path
validate_directory_path() {
    local dir_path="$1"
    local must_exist="${2:-false}"
    local must_be_writable="${3:-false}"
    
    if [ -z "$dir_path" ]; then
        log_error "Directory path cannot be empty"
        return 1
    fi
    
    # Check if directory must exist
    if [ "$must_exist" = "true" ] && [ ! -d "$dir_path" ]; then
        log_error "Directory does not exist: $dir_path"
        return 1
    fi
    
    # Check if directory must be writable
    if [ "$must_be_writable" = "true" ] && [ -d "$dir_path" ] && [ ! -w "$dir_path" ]; then
        log_error "Directory not writable: $dir_path"
        return 1
    fi
    
    log_debug "Directory path validation passed: $dir_path"
    return 0
}

# Validate URL format
validate_url() {
    local url="$1"
    
    if [ -z "$url" ]; then
        log_error "URL cannot be empty"
        return 1
    fi
    
    # Basic URL format validation
    if [[ "$url" =~ ^https?://[a-zA-Z0-9.-]+[a-zA-Z0-9]+(:[0-9]+)?(/.*)?$ ]]; then
        log_debug "URL format validation passed: $url"
        return 0
    else
        log_error "Invalid URL format: $url"
        return 1
    fi
}

# Validate version string
validate_version() {
    local version="$1"
    
    if [ -z "$version" ]; then
        log_error "Version cannot be empty"
        return 1
    fi
    
    # Semantic version format (major.minor.patch)
    if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
        log_debug "Version format validation passed: $version"
        return 0
    else
        log_error "Invalid version format: $version (expected: major.minor.patch)"
        return 1
    fi
}

# Validate shell type
validate_shell_type() {
    local shell_path="$1"
    
    if [ -z "$shell_path" ]; then
        shell_path="$SHELL"
    fi
    
    local shell_name
    shell_name=$(basename "$shell_path")
    
    case "$shell_name" in
        bash|zsh|sh)
            log_debug "Supported shell detected: $shell_name"
            return 0
            ;;
        *)
            log_warn "Shell may not be fully supported: $shell_name"
            return 0  # Warning only, don't fail
            ;;
    esac
}

# Validate configuration completeness
validate_configuration_completeness() {
    log_progress "Validating configuration completeness..."
    
    local errors=0
    
    # Check required variables from app.conf
    local required_app_vars=(
        "APP_NAME"
        "APP_VERSION"
        "SWITCHER_DIR"
        "MODEL_CONFIG_FILE"
    )
    
    for var in "${required_app_vars[@]}"; do
        if [ -z "${!var}" ]; then
            log_error "Required configuration variable not set: $var"
            ((errors++))
        fi
    done
    
    # Check model configuration
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_error "No models configured in MODEL_PROVIDERS"
        ((errors++))
    fi
    
    # Check provider configuration
    if [ -z "$AVAILABLE_PROVIDERS" ]; then
        log_error "No providers configured in AVAILABLE_PROVIDERS"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "Configuration completeness validation passed"
        return 0
    else
        log_error "Configuration completeness validation failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/installers/claude_installer.sh`:

```sh
#!/bin/bash

# Claude Code Installer Module
# Handles Claude Code CLI installation and configuration

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Claude Code CLI
install_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Installation"
    
    # Validate Node.js is available
    if ! validate_nodejs; then
        log_error "Node.js is required for Claude Code installation"
        return 1
    fi
    
    # Check if Claude Code is already installed
    if validate_claude_code; then
        log_info "Claude Code is already installed and working"
        _display_claude_info
        return 0
    fi
    
    log_progress "Installing Claude Code CLI package: $package_name"
    
    # Install via npm
    if _install_claude_npm "$package_name"; then
        log_success "Claude Code CLI installed successfully"
    else
        log_error "Failed to install Claude Code CLI"
        return 1
    fi
    
    # Configure Claude Code
    if _configure_claude_code; then
        log_success "Claude Code configured successfully"
    else
        log_warn "Claude Code installation succeeded but configuration failed"
    fi
    
    # Verify installation
    if validate_claude_code; then
        log_success "Claude Code installation and verification completed"
        _display_claude_info
        return 0
    else
        log_error "Claude Code installation verification failed"
        return 1
    fi
}

# Install Claude Code via npm
_install_claude_npm() {
    local package_name="$1"
    
    log_debug "Installing $package_name via npm..."
    
    # Check npm availability
    if ! command -v npm >/dev/null 2>&1; then
        log_error "npm command not found"
        return 1
    fi
    
    # Install globally with error handling
    local install_output
    if install_output=$(npm install -g "$package_name" 2>&1); then
        log_debug "npm install output: $install_output"
        return 0
    else
        log_error "npm install failed: $install_output"
        return 1
    fi
}

# Configure Claude Code
_configure_claude_code() {
    log_progress "Configuring Claude Code to skip onboarding..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    
    # Ensure Claude config directory exists
    if ! mkdir -p "$claude_config_dir"; then
        log_error "Failed to create Claude config directory: $claude_config_dir"
        return 1
    fi
    
    # Create or update configuration using Node.js
    local config_script='
        const fs = require("fs");
        const path = require("path");
        const os = require("os");
        const configPath = path.join(os.homedir(), ".claude.json");
        
        let config = {};
        if (fs.existsSync(configPath)) {
            try {
                const content = fs.readFileSync(configPath, "utf-8");
                config = JSON.parse(content);
            } catch (e) {
                console.error("Warning: Could not parse existing config, creating new one");
                config = {};
            }
        }
        
        config.hasCompletedOnboarding = true;
        
        try {
            fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
            console.log("Configuration updated successfully");
        } catch (e) {
            console.error("Failed to write configuration:", e.message);
            process.exit(1);
        }
    '
    
    if node -e "$config_script" 2>/dev/null; then
        log_success "Claude Code configuration updated"
        return 0
    else
        log_error "Failed to configure Claude Code"
        return 1
    fi
}

# Display Claude Code information
_display_claude_info() {
    log_info "Claude Code Installation Summary:"
    
    if command -v claude >/dev/null 2>&1; then
        local claude_version
        if claude_version=$(claude --version 2>/dev/null); then
            log_indent info "Claude Code version: $claude_version" 2
        else
            log_indent warn "Could not determine Claude Code version" 2
        fi
        
        local claude_path
        if claude_path=$(which claude 2>/dev/null); then
            log_indent info "Claude Code path: $claude_path" 2
        fi
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration file: $config_file" 2
        local onboarding_status
        if onboarding_status=$(node -e "
            try {
                const config = JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'));
                console.log(config.hasCompletedOnboarding ? 'completed' : 'pending');
            } catch (e) {
                console.log('unknown');
            }
        " 2>/dev/null); then
            log_indent info "Onboarding status: $onboarding_status" 2
        fi
    fi
}

# Update Claude Code
update_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Update"
    
    # Check current installation
    if ! validate_claude_code; then
        log_error "Claude Code not found. Please install it first."
        return 1
    fi
    
    log_progress "Updating Claude Code CLI package: $package_name"
    
    # Update via npm
    if _update_claude_npm "$package_name"; then
        log_success "Claude Code CLI updated successfully"
        _display_claude_info
        return 0
    else
        log_error "Failed to update Claude Code CLI"
        return 1
    fi
}

# Update Claude Code via npm
_update_claude_npm() {
    local package_name="$1"
    
    log_debug "Updating $package_name via npm..."
    
    local update_output
    if update_output=$(npm update -g "$package_name" 2>&1); then
        log_debug "npm update output: $update_output"
        return 0
    else
        log_error "npm update failed: $update_output"
        return 1
    fi
}

# Uninstall Claude Code
uninstall_claude_code() {
    local package_name="${1:-$CLAUDE_PACKAGE}"
    
    log_header "Claude Code Uninstallation"
    
    # Check if Claude Code is installed
    if ! command -v claude >/dev/null 2>&1; then
        log_info "Claude Code not found, nothing to uninstall"
        return 0
    fi
    
    log_progress "Uninstalling Claude Code CLI package: $package_name"
    
    # Uninstall via npm
    if _uninstall_claude_npm "$package_name"; then
        log_success "Claude Code CLI uninstalled successfully"
    else
        log_error "Failed to uninstall Claude Code CLI"
        return 1
    fi
    
    # Clean up configuration (optional)
    local cleanup_config="${2:-false}"
    if [ "$cleanup_config" = "true" ]; then
        _cleanup_claude_config
    fi
    
    return 0
}

# Uninstall Claude Code via npm
_uninstall_claude_npm() {
    local package_name="$1"
    
    log_debug "Uninstalling $package_name via npm..."
    
    local uninstall_output
    if uninstall_output=$(npm uninstall -g "$package_name" 2>&1); then
        log_debug "npm uninstall output: $uninstall_output"
        return 0
    else
        log_error "npm uninstall failed: $uninstall_output"
        return 1
    fi
}

# Clean up Claude Code configuration
_cleanup_claude_config() {
    log_progress "Cleaning up Claude Code configuration..."
    
    local claude_config_dir="$HOME/.claude"
    local claude_config_file="$claude_config_dir/.claude.json"
    local claude_settings_file="$claude_config_dir/settings.json"
    
    # Remove configuration files
    local files_to_remove=("$claude_config_file" "$claude_settings_file")
    
    for file in "${files_to_remove[@]}"; do
        if [ -f "$file" ]; then
            log_debug "Removing configuration file: $file"
            rm -f "$file"
        fi
    done
    
    # Remove empty directory
    if [ -d "$claude_config_dir" ] && [ -z "$(ls -A "$claude_config_dir" 2>/dev/null)" ]; then
        log_debug "Removing empty Claude config directory: $claude_config_dir"
        rmdir "$claude_config_dir"
    fi
    
    log_success "Claude Code configuration cleanup completed"
}

# Test Claude Code installation
test_claude_installation() {
    log_header "Claude Code Installation Test"
    
    local errors=0
    
    # Test Claude command availability
    if command -v claude >/dev/null 2>&1; then
        log_success "Claude command is available"
    else
        log_error "Claude command not found"
        ((errors++))
    fi
    
    # Test Claude version command
    local version_output
    if version_output=$(claude --version 2>/dev/null); then
        log_success "Claude version command works: $version_output"
    else
        log_error "Claude version command failed"
        ((errors++))
    fi
    
    # Test Claude help command
    if claude --help >/dev/null 2>&1; then
        log_success "Claude help command works"
    else
        log_error "Claude help command failed"
        ((errors++))
    fi
    
    # Test configuration file
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_success "Claude configuration file exists"
        
        # Test configuration file validity
        if node -e "JSON.parse(require('fs').readFileSync('$config_file', 'utf-8'))" 2>/dev/null; then
            log_success "Claude configuration file is valid JSON"
        else
            log_error "Claude configuration file has invalid JSON"
            ((errors++))
        fi
    else
        log_warn "Claude configuration file not found (may be created on first run)"
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Claude Code tests passed"
        return 0
    else
        log_error "Claude Code tests failed with $errors errors"
        return 1
    fi
}

# Get Claude Code status
get_claude_status() {
    log_info "Claude Code Status:"
    
    if command -v claude >/dev/null 2>&1; then
        log_indent success "Status: Installed" 2
        
        local version
        if version=$(claude --version 2>/dev/null); then
            log_indent info "Version: $version" 2
        fi
        
        local path
        if path=$(which claude 2>/dev/null); then
            log_indent info "Path: $path" 2
        fi
    else
        log_indent error "Status: Not installed" 2
    fi
    
    local config_file="$HOME/.claude.json"
    if [ -f "$config_file" ]; then
        log_indent info "Configuration: Found" 2
    else
        log_indent warn "Configuration: Not found" 2
    fi
}


```

`claude-model-switcher/lib/installers/nodejs_installer.sh`:

```sh
#!/bin/bash

# Node.js Installer Module
# Handles Node.js installation via NVM

# Source dependencies
source "$(dirname "${BASH_SOURCE[0]}")/../core/logger.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../core/validator.sh"

# Install Node.js via NVM
install_nodejs() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    local nvm_version="${2:-$NVM_VERSION}"
    
    log_header "Node.js Installation"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met for Node.js installation"
        return 1
    fi
    
    # Check if Node.js is already installed and meets requirements
    if validate_nodejs "$min_version"; then
        log_info "Node.js already meets requirements, skipping installation"
        return 0
    fi
    
    local platform
    platform=$(uname -s)
    
    case "$platform" in
        Linux|Darwin)
            _install_nodejs_unix "$min_version" "$nvm_version"
            ;;
        *)
            log_error "Unsupported platform for Node.js installation: $platform"
            return 1
            ;;
    esac
}

# Install Node.js on Unix-like systems (Linux/macOS)
_install_nodejs_unix() {
    local min_version="$1"
    local nvm_version="$2"
    
    log_progress "Installing Node.js via NVM for Unix-like system..."
    
    # Check if NVM is already installed
    if [ -d "$HOME/.nvm" ]; then
        log_info "NVM directory already exists, sourcing existing installation..."
        _source_nvm
    else
        log_progress "Downloading and installing NVM $nvm_version..."
        if ! _install_nvm "$nvm_version"; then
            log_error "Failed to install NVM"
            return 1
        fi
    fi
    
    # Install Node.js LTS
    log_progress "Installing Node.js LTS version..."
    if ! _install_nodejs_lts; then
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Verify installation
    if validate_nodejs "$min_version"; then
        log_success "Node.js installation completed successfully"
        _display_nodejs_info
        return 0
    else
        log_error "Node.js installation verification failed"
        return 1
    fi
}

# Install NVM
_install_nvm() {
    local nvm_version="$1"
    local install_url="${NVM_INSTALL_URL:-https://raw.githubusercontent.com/nvm-sh/nvm/$nvm_version/install.sh}"
    
    log_debug "Downloading NVM from: $install_url"
    
    # Validate URL format
    if ! validate_url "$install_url"; then
        log_error "Invalid NVM install URL: $install_url"
        return 1
    fi
    
    # Download and execute NVM installer
    if curl -s -o- "$install_url" | bash; then
        log_success "NVM installation script executed successfully"
        _source_nvm
        return 0
    else
        log_error "Failed to download or execute NVM installer"
        return 1
    fi
}

# Source NVM environment
_source_nvm() {
    log_debug "Sourcing NVM environment..."
    
    export NVM_DIR="$HOME/.nvm"
    
    # Source NVM script
    if [ -s "$NVM_DIR/nvm.sh" ]; then
        source "$NVM_DIR/nvm.sh"
        log_debug "NVM script sourced successfully"
    else
        log_error "NVM script not found: $NVM_DIR/nvm.sh"
        return 1
    fi
    
    # Source NVM bash completion (optional)
    if [ -s "$NVM_DIR/bash_completion" ]; then
        source "$NVM_DIR/bash_completion"
        log_debug "NVM bash completion sourced"
    fi
    
    return 0
}

# Install Node.js LTS
_install_nodejs_lts() {
    # Ensure NVM is sourced
    if ! command -v nvm >/dev/null 2>&1; then
        if ! _source_nvm; then
            log_error "NVM not available after sourcing"
            return 1
        fi
    fi
    
    log_debug "Installing Node.js LTS via NVM..."
    
    # Install LTS version
    if nvm install --lts; then
        log_success "Node.js LTS installed successfully"
    else
        log_error "Failed to install Node.js LTS"
        return 1
    fi
    
    # Use LTS version
    if nvm use --lts; then
        log_success "Switched to Node.js LTS"
    else
        log_error "Failed to switch to Node.js LTS"
        return 1
    fi
    
    # Set LTS as default
    if nvm alias default 'lts/*'; then
        log_success "Node.js LTS set as default"
    else
        log_warn "Failed to set Node.js LTS as default"
    fi
    
    return 0
}

# Display Node.js installation information
_display_nodejs_info() {
    log_info "Node.js Installation Summary:"
    
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_indent info "Node.js version: $node_version" 2
    fi
    
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_indent info "npm version: $npm_version" 2
    fi
    
    if command -v nvm >/dev/null 2>&1; then
        local nvm_version
        nvm_version=$(nvm --version 2>/dev/null)
        log_indent info "NVM version: $nvm_version" 2
    fi
}

# Check if Node.js upgrade is needed
check_nodejs_upgrade() {
    local min_version="${1:-$NODE_MIN_VERSION}"
    
    if ! validate_nodejs "$min_version"; then
        log_info "Node.js upgrade recommended"
        return 1
    else
        log_info "Node.js version is up to date"
        return 0
    fi
}

# Upgrade Node.js to latest LTS
upgrade_nodejs() {
    log_header "Node.js Upgrade"
    
    # Check if NVM is available
    if [ ! -d "$HOME/.nvm" ]; then
        log_error "NVM not found. Please install Node.js first."
        return 1
    fi
    
    # Source NVM
    if ! _source_nvm; then
        log_error "Failed to source NVM environment"
        return 1
    fi
    
    log_progress "Upgrading to latest Node.js LTS..."
    
    # Install latest LTS
    if ! _install_nodejs_lts; then
        log_error "Failed to upgrade Node.js"
        return 1
    fi
    
    log_success "Node.js upgrade completed"
    _display_nodejs_info
    return 0
}

# Uninstall Node.js (remove NVM)
uninstall_nodejs() {
    log_header "Node.js Uninstallation"
    
    if [ -d "$HOME/.nvm" ]; then
        log_progress "Removing NVM directory..."
        rm -rf "$HOME/.nvm"
        log_success "NVM directory removed"
    else
        log_info "NVM directory not found, nothing to remove"
    fi
    
    # Remove NVM lines from shell configuration files
    local shell_files=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile")
    
    for shell_file in "${shell_files[@]}"; do
        if [ -f "$shell_file" ]; then
            if grep -q "NVM_DIR" "$shell_file"; then
                log_progress "Cleaning NVM configuration from: $shell_file"
                # Create backup
                cp "$shell_file" "${shell_file}.nvm_removal_backup"
                # Remove NVM lines
                sed -i '/NVM_DIR/d' "$shell_file"
                sed -i '/nvm.sh/d' "$shell_file"
                sed -i '/bash_completion/d' "$shell_file"
                log_success "NVM configuration removed from: $shell_file"
            fi
        fi
    done
    
    log_success "Node.js uninstallation completed"
    log_info "Please restart your terminal for changes to take effect"
}

# Test Node.js installation
test_nodejs_installation() {
    log_header "Node.js Installation Test"
    
    local errors=0
    
    # Test Node.js command
    if command -v node >/dev/null 2>&1; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js command available: $node_version"
    else
        log_error "Node.js command not found"
        ((errors++))
    fi
    
    # Test npm command
    if command -v npm >/dev/null 2>&1; then
        local npm_version
        npm_version=$(npm -v 2>/dev/null)
        log_success "npm command available: $npm_version"
    else
        log_error "npm command not found"
        ((errors++))
    fi
    
    # Test simple Node.js execution
    local test_result
    test_result=$(node -e "console.log('Node.js test successful')" 2>/dev/null)
    if [ "$test_result" = "Node.js test successful" ]; then
        log_success "Node.js execution test passed"
    else
        log_error "Node.js execution test failed"
        ((errors++))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success "All Node.js tests passed"
        return 0
    else
        log_error "Node.js tests failed with $errors errors"
        return 1
    fi
}


```

`claude-model-switcher/lib/managers/model_manager.sh`:

```sh
#!/bin/bash

# Model Manager Module
# Handles model switching, listing, and configuration

# Source dependencies
# Note: Core modules (logger, validator, config_loader) are expected to be 
# available in the environment. This avoids circular dependencies during testing.

# List available models (implementation)
list_models_impl() {
    log_header "Available Models"
    
    # Reload configuration to get latest models
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if models are configured
    if [ ${#MODEL_PROVIDERS[@]} -eq 0 ]; then
        log_warn "No models defined in $MODEL_CONFIG_FILE"
        return 1
    fi
    
    # Display table header
    local table_width="${TABLE_WIDTH:-110}"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    printf "%-12s %-12s %-25s %-25s %s\n" "Alias" "Provider" "Main Model" "Fast Model" "Context"
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display models
    for alias in "${!MODEL_PROVIDERS[@]}"; do
        local provider="${MODEL_PROVIDERS[$alias]}"
        local main_model="${MODEL_API_NAMES[$alias]}"
        local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
        local context="${MODEL_CONTEXTS[$alias]:-N/A}"
        
        printf "%-12s %-12s %-25s %-25s %s\n" \
            "$alias" \
            "$provider" \
            "$main_model" \
            "$fast_model" \
            "$context"
    done
    
    printf '%*s\n' "$table_width" | tr ' ' '-'
    
    # Display additional information
    log_info "Total models configured: ${#MODEL_PROVIDERS[@]}"
    log_info "Configuration file: $MODEL_CONFIG_FILE"
    
    return 0
}

# Use/switch to a specific model (implementation)
use_model_impl() {
    local alias="$1"
    local api_key="$2"  # Optional: can be provided or prompted
    
    log_header "Model Switching: $alias"
    
    # Validate input
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        log_info "Usage: use_model <alias> [api_key]"
        list_models
        return 1
    fi
    
    # Validate alias format
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    # Reload configuration
    if ! config_load "$MODEL_CONFIG_FILE" "true"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if model exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found in configuration"
        list_models
        return 1
    fi
    
    # Get model properties
    local provider="${MODEL_PROVIDERS[$alias]}"
    local main_model="${MODEL_API_NAMES[$alias]}"
    local fast_model="${MODEL_SMALL_FAST_NAMES[$alias]:-$main_model}"
    local context_info="${MODEL_CONTEXTS[$alias]}"
    local description="${MODEL_DESCRIPTIONS[$alias]:-N/A}"
    
    # Validate provider
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    # Configure provider-specific settings
    if ! _configure_provider "$provider" "$alias" "$api_key"; then
        log_error "Failed to configure provider: $provider"
        return 1
    fi
    
    # Set model environment variables
    export ANTHROPIC_MODEL="$main_model"
    export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
    log_success "Model environment variables configured: $main_model | $fast_model"
    
    # Save environment variables for persistence
    _save_current_env_vars "$provider" "$main_model" "$fast_model"
    
    # Configure Claude Code settings
    if ! _configure_claude_settings "$alias" "$main_model" "$fast_model" "$context_info"; then
        log_error "Failed to configure Claude Code settings"
        return 1
    fi
    
    # Update memory/context file
    if ! _update_model_context "$alias" "$provider" "$main_model" "$fast_model" "$context_info" "$description"; then
        log_warn "Failed to update model context file"
    fi
    
    log_success "Successfully switched to model: $alias"
    _display_active_model_info "$alias" "$provider" "$main_model" "$fast_model" "$context_info"
    
    return 0
}

# Configure provider-specific settings
_configure_provider() {
    local provider="$1"
    local alias="$2"
    local api_key="$3"
    
    log_progress "Configuring provider: $provider"
    
    # Get provider configuration
    local base_url_var="PROVIDER_${provider^^}_BASE_URL"
    local base_url="${!base_url_var}"
    
    if [ -z "$base_url" ]; then
        log_error "Base URL not configured for provider: $provider"
        return 1
    fi
    
    # Validate base URL
    if ! validate_url "$base_url"; then
        log_error "Invalid base URL for provider $provider: $base_url"
        return 1
    fi
    
    # Set base URL
    export ANTHROPIC_BASE_URL="$base_url"
    log_success "Base URL configured: $base_url"
    
    # Handle API key
    if [ -z "$api_key" ]; then
        log_info "Please enter your $provider API key (input hidden):"
        read -s api_key
        echo  # New line after hidden input
    fi
    
    # Validate API key
    if ! validate_api_key "$api_key" "$provider"; then
        log_error "Invalid API key format"
        return 1
    fi
    
    # Set API key
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    log_success "API key configured for this session"
    
    return 0
}

# Configure Claude Code settings
_configure_claude_settings() {
    local alias="$1"
    local main_model="$2"
    local fast_model="$3"
    local context_info="$4"
    
    log_progress "Configuring Claude Code settings..."
    
    local claude_dir="$HOME/.claude"
    local settings_file="$claude_dir/settings.json"
    
    # Ensure Claude directory exists
    mkdir -p "$claude_dir"
    
    # Get configuration values
    local temperature="${CLAUDE_DEFAULT_TEMPERATURE:-0.6}"
    local timeout="${CLAUDE_DEFAULT_TIMEOUT:-300000}"
    
    # Create settings JSON
    local settings_content
    settings_content=$(cat << EOF
{
  "model": "$main_model",
  "env": {
    "CLAUDE_CODE_TEMPERATURE": "$temperature",
    "BASH_DEFAULT_TIMEOUT_MS": "$timeout",
    "ANTHROPIC_MODEL": "$main_model",
    "ANTHROPIC_SMALL_FAST_MODEL": "$fast_model"
  },
  "hooks": {
    "SessionStart": [
      {
        "type": "command",
        "command": "echo '🤖 Active: $main_model ($alias) | Fast: $fast_model | Context: $context_info | T:$temperature | Timeout:${timeout}ms'"
      }
    ]
  }
}
EOF
    )
    
    # Write settings file
    if echo "$settings_content" > "$settings_file"; then
        log_success "Claude Code settings updated: $settings_file"
        return 0
    else
        log_error "Failed to write Claude Code settings file"
        return 1
    fi
}

# Update model context file
_update_model_context() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    local description="$6"
    
    local memory_file="$MEMORY_DIR/model-context.md"
    
    # Ensure memory directory exists
    mkdir -p "$MEMORY_DIR"
    
    # Create context content
    local context_content
    context_content=$(cat << EOF
# Model Context Reference

## Current Configuration
- **Provider**: $provider
- **Alias**: $alias
- **Main Model**: $main_model
- **Fast Model**: $fast_model
- **Context Window**: $context_info
- **Description**: $description
- **Temperature**: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6} (Programming Mode)
- **Timeout**: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms (5 minutes)
- **Last Updated**: $(date)

## Environment Variables
- **ANTHROPIC_BASE_URL**: ${ANTHROPIC_BASE_URL:-Not set}
- **ANTHROPIC_MODEL**: $main_model
- **ANTHROPIC_SMALL_FAST_MODEL**: $fast_model

## Usage Instructions
1. Use \`claude "your prompt here"\` for general queries
2. The system automatically selects between main and fast models based on task complexity
3. Programming assistance is optimized with temperature 0.6
4. Session timeout is set to 5 minutes for long-running tasks

## Provider Information
- **Base URL**: ${ANTHROPIC_BASE_URL:-Not configured}
- **Authentication**: Session-based (API key required per session)

---
*Generated by Claude Model Switcher v${APP_VERSION:-5.0.0}*
EOF
    )
    
    # Write context file
    if echo "$context_content" > "$memory_file"; then
        log_debug "Model context file updated: $memory_file"
        return 0
    else
        log_warn "Failed to update model context file: $memory_file"
        return 1
    fi
}

# Display active model information
_display_active_model_info() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context_info="$5"
    
    log_info "Active Model Configuration:"
    log_indent info "Alias: $alias" 2
    log_indent info "Provider: $provider" 2
    log_indent info "Main Model: $main_model" 2
    log_indent info "Fast Model: $fast_model" 2
    log_indent info "Context: $context_info" 2
    log_indent info "Temperature: ${CLAUDE_DEFAULT_TEMPERATURE:-0.6}" 2
    log_indent info "Timeout: ${CLAUDE_DEFAULT_TIMEOUT:-300000}ms" 2
    
    log_info "Ready to use Claude Code with: claude \"your prompt here\""
}

# Get current model status
get_model_status() {
    log_info "Current Model Status:"
    
    # Check environment variables
    if [ -n "$ANTHROPIC_MODEL" ]; then
        log_indent success "Main Model: $ANTHROPIC_MODEL" 2
    else
        log_indent warn "Main Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_SMALL_FAST_MODEL" ]; then
        log_indent success "Fast Model: $ANTHROPIC_SMALL_FAST_MODEL" 2
    else
        log_indent warn "Fast Model: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_BASE_URL" ]; then
        log_indent success "Base URL: $ANTHROPIC_BASE_URL" 2
    else
        log_indent warn "Base URL: Not configured" 2
    fi
    
    if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
        log_indent success "API Key: Configured" 2
    else
        log_indent warn "API Key: Not configured" 2
    fi
    
    # Check settings file
    local settings_file="$HOME/.claude/settings.json"
    if [ -f "$settings_file" ]; then
        log_indent success "Settings File: $settings_file" 2
    else
        log_indent warn "Settings File: Not found" 2
    fi
    
    # Check context file
    local context_file="$MEMORY_DIR/model-context.md"
    if [ -f "$context_file" ]; then
        log_indent success "Context File: $context_file" 2
    else
        log_indent warn "Context File: Not found" 2
    fi
}

# Add a new model to configuration
add_model() {
    local alias="$1"
    local provider="$2"
    local main_model="$3"
    local fast_model="$4"
    local context="$5"
    local description="$6"
    
    log_header "Adding New Model: $alias"
    
    # Validate inputs
    if ! validate_model_alias "$alias"; then
        return 1
    fi
    
    if ! validate_provider_name "$provider"; then
        return 1
    fi
    
    if [ -z "$main_model" ]; then
        log_error "Main model name is required"
        return 1
    fi
    
    # Set defaults
    fast_model="${fast_model:-$main_model}"
    context="${context:-N/A}"
    description="${description:-Custom model configuration}"
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias already exists
    if [ -n "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' already exists"
        return 1
    fi
    
    # Add model to configuration file
    log_progress "Adding model to configuration file..."
    
    local new_model_config
    new_model_config=$(cat << EOF

# Model Alias: '$alias' - $description
MODEL_PROVIDERS["$alias"]="$provider"
MODEL_API_NAMES["$alias"]="$main_model"
MODEL_SMALL_FAST_NAMES["$alias"]="$fast_model"
MODEL_CONTEXTS["$alias"]="$context"
MODEL_DESCRIPTIONS["$alias"]="$description"
EOF
    )
    
    # Append to configuration file
    if echo "$new_model_config" >> "$MODEL_CONFIG_FILE"; then
        log_success "Model '$alias' added to configuration"
        
        # Update AVAILABLE_MODELS list
        local current_models
        current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
        local updated_models="$current_models $alias"
        
        # Update the AVAILABLE_MODELS line
        sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
        
        log_success "Model successfully added and configuration updated"
        return 0
    else
        log_error "Failed to add model to configuration file"
        return 1
    fi
}

# Remove a model from configuration
remove_model() {
    local alias="$1"
    
    log_header "Removing Model: $alias"
    
    if [ -z "$alias" ]; then
        log_error "Model alias is required"
        return 1
    fi
    
    # Load current configuration
    if ! config_load "$MODEL_CONFIG_FILE"; then
        log_error "Failed to load model configuration"
        return 1
    fi
    
    # Check if alias exists
    if [ -z "${MODEL_PROVIDERS[$alias]}" ]; then
        log_error "Model alias '$alias' not found"
        return 1
    fi
    
    # Create backup
    local backup_file="${MODEL_CONFIG_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    if cp "$MODEL_CONFIG_FILE" "$backup_file"; then
        log_success "Configuration backup created: $backup_file"
    else
        log_warn "Failed to create backup, proceeding anyway"
    fi
    
    # Remove model entries from configuration file
    log_progress "Removing model entries from configuration..."
    
    # Remove all lines related to this model
    sed -i "/MODEL_PROVIDERS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_API_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_SMALL_FAST_NAMES\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_CONTEXTS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    sed -i "/MODEL_DESCRIPTIONS\[\"$alias\"\]/d" "$MODEL_CONFIG_FILE"
    
    # Update AVAILABLE_MODELS list
    local current_models
    current_models=$(grep "AVAILABLE_MODELS=" "$MODEL_CONFIG_FILE" | cut -d'"' -f2)
    local updated_models
    updated_models=$(echo "$current_models" | sed "s/\b$alias\b//g" | tr -s ' ' | sed 's/^ *//;s/ *$//')
    
    sed -i "s/AVAILABLE_MODELS=\".*\"/AVAILABLE_MODELS=\"$updated_models\"/" "$MODEL_CONFIG_FILE"
    
    log_success "Model '$alias' removed from configuration"
    return 0
}

# Save current environment variables for persistence
_save_current_env_vars() {
    local provider="$1"
    local main_model="$2"
    local fast_model="$3"
    
    local env_file="$CONFIG_DIR/current_env.conf"
    
    # Create environment configuration content
    local env_content
    env_content=$(cat << EOF
# Current Model Environment Variables
# This file is automatically managed by the model switcher
# Last updated: $(date)

export ANTHROPIC_BASE_URL="$ANTHROPIC_BASE_URL"
export ANTHROPIC_AUTH_TOKEN="$ANTHROPIC_AUTH_TOKEN"
export ANTHROPIC_MODEL="$main_model"
export ANTHROPIC_SMALL_FAST_MODEL="$fast_model"
EOF
    )
    
    # Write environment file
    if echo "$env_content" > "$env_file"; then
        log_success "Environment variables saved for persistence"
        return 0
    else
        log_warn "Failed to save environment variables"
        return 1
    fi
}

# Load persisted environment variables
load_persisted_env_vars() {
    local env_file="$CONFIG_DIR/current_env.conf"
    
    if [ -f "$env_file" ]; then
        source "$env_file"
        return 0
    fi
    
    return 1
}


```

`claude-model-switcher/main.sh`:

```sh
#!/bin/bash

# Claude Model Switcher - Main Entry Point
# Version 5.0.0 - Modular Architecture
# A robust installer and manager for Claude Code with multi-model support

set -e

# --- Script Metadata ---
SCRIPT_VERSION="5.0.0"
SCRIPT_NAME="Claude Model Switcher"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Bootstrap Configuration ---
# Load base configuration to get directory paths
if [ -f "$SCRIPT_DIR/config/app.conf" ]; then
    source "$SCRIPT_DIR/config/app.conf"
else
    echo "❌ Error: Configuration file not found: $SCRIPT_DIR/config/app.conf"
    echo "Please ensure the script is run from the correct directory."
    exit 1
fi

# --- Module Loading ---
# Load core modules
source "$SCRIPT_DIR/lib/core/logger.sh"
source "$SCRIPT_DIR/lib/core/config_loader.sh"
source "$SCRIPT_DIR/lib/core/validator.sh"

# Load installer modules
source "$SCRIPT_DIR/lib/installers/nodejs_installer.sh"
source "$SCRIPT_DIR/lib/installers/claude_installer.sh"

# Load manager modules
source "$SCRIPT_DIR/lib/managers/model_manager.sh"

# --- Initialization ---
initialize_system() {
    # Initialize logger
    logger_init
    
    log_header "$SCRIPT_NAME v$SCRIPT_VERSION"
    log_info "Initializing modular system..."
    
    # Load all configurations
    if ! config_load_all "$SCRIPT_DIR/config"; then
        log_error "Failed to load configurations"
        return 1
    fi
    
    # Validate environment
    if ! config_validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi
    
    log_success "System initialization completed"
    return 0
}

# --- Command Functions ---

# Install command - Full installation process
cmd_install() {
    log_header "Full Installation Process"
    
    # Validate system requirements
    if ! validate_system_requirements; then
        log_error "System requirements not met"
        return 1
    fi
    
    # Install Node.js if needed
    log_progress "Step 1: Node.js Installation"
    if ! install_nodejs; then
        log_error "Node.js installation failed"
        return 1
    fi
    
    # Install Claude Code
    log_progress "Step 2: Claude Code Installation"
    if ! install_claude_code; then
        log_error "Claude Code installation failed"
        return 1
    fi
    
    # Setup shell integration
    log_progress "Step 3: Shell Integration Setup"
    if ! setup_shell_integration; then
        log_error "Shell integration setup failed"
        return 1
    fi
    
    # Display completion message
    display_installation_complete
    
    return 0
}

# Setup shell integration
setup_shell_integration() {
    log_progress "Setting up shell integration..."
    
    # Detect shell
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    log_info "Detected shell: $current_shell"
    log_info "Configuration file: $rc_file"
    
    # Create backup
    if [ -f "$rc_file" ]; then
        local backup_file="$rc_file.claude_backup.$(date +%Y%m%d_%H%M%S)"
        if cp "$rc_file" "$backup_file"; then
            log_success "Backup created: $backup_file"
        else
            log_warn "Failed to create backup"
        fi
        
        # Remove old configuration block
        sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
    fi
    
    # Add new configuration block
    local shell_config
    shell_config=$(cat << 'EOF'

# CLAUDE_CODE_MODEL_MANAGER_V5
# --- Claude Model Switcher (Modular Architecture) ---
# This block is managed automatically by the installation script.

# Define paths for the switcher's files.
export CLAUDE_SWITCHER_DIR="$HOME/.claude/claude-model-switcher"
export CLAUDE_MODELS_CONF="$CLAUDE_SWITCHER_DIR/config/models.conf"

# Load the modular system
if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ]; then
    # Source configuration
    [ -f "$CLAUDE_SWITCHER_DIR/config/app.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/app.conf"
    [ -f "$CLAUDE_SWITCHER_DIR/config/providers.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/providers.conf"
    
    # Pre-declare associative arrays before loading models.conf
    declare -gA MODEL_PROVIDERS 2>/dev/null || true
    declare -gA MODEL_API_NAMES 2>/dev/null || true
    declare -gA MODEL_CONTEXTS 2>/dev/null || true
    declare -gA MODEL_SMALL_FAST_NAMES 2>/dev/null || true
    declare -gA MODEL_DESCRIPTIONS 2>/dev/null || true
    declare -gA MODEL_CAPABILITIES 2>/dev/null || true
    
    [ -f "$CLAUDE_SWITCHER_DIR/config/models.conf" ] && source "$CLAUDE_SWITCHER_DIR/config/models.conf"
    
    # Source core modules
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/logger.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/config_loader.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/core/validator.sh"
    [ -f "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh" ] && source "$CLAUDE_SWITCHER_DIR/lib/managers/model_manager.sh"
    
    # Initialize logger for shell functions
    logger_init >/dev/null 2>&1
    
    # Load persisted environment variables if available
    if declare -f load_persisted_env_vars >/dev/null 2>&1; then
        load_persisted_env_vars >/dev/null 2>&1 || true
    fi
fi

# Shell functions for user interaction
list_models() {
    # Check if the modular system is loaded
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f list_models_impl >/dev/null 2>&1; then
        list_models_impl "$@"
    else
        echo "❌ Claude Model Switcher not properly installed"
        echo "💡 Try running: source ~/.bashrc"
        return 1
    fi
}

use_model() {
    # Check if the modular system is loaded  
    if [ -f "$CLAUDE_SWITCHER_DIR/main.sh" ] && declare -f use_model_impl >/dev/null 2>&1; then
        use_model_impl "$@"
    else
        echo "❌ Claude Model Switcher not properly installed"
        echo "💡 Try running: source ~/.bashrc"
        return 1
    fi
}

# END_OF_CLAUDE_CONFIG
EOF
    )
    
    # Append configuration
    if echo "$shell_config" >> "$rc_file"; then
        log_success "Shell integration configured: $rc_file"
        return 0
    else
        log_error "Failed to configure shell integration"
        return 1
    fi
}

# Display installation complete message
display_installation_complete() {
    log_header "Installation Complete!"
    
    echo ""
    log_success "🎉 Claude Model Switcher v$SCRIPT_VERSION is ready!"
    echo ""
    
    log_info "Next Steps:"
    log_indent info "1. Refresh your environment:" 2
    log_indent info "   source ~/.bashrc  # or ~/.zshrc" 4
    echo ""
    
    log_indent info "2. List available models:" 2
    log_indent info "   list_models" 4
    echo ""
    
    log_indent info "3. Switch to a model:" 2
    log_indent info "   use_model kimi" 4
    log_indent info "   use_model glm4" 4
    echo ""
    
    log_indent info "4. Start using Claude Code:" 2
    log_indent info "   claude \"your prompt here\"" 4
    echo ""
    
    log_info "Configuration Files:"
    log_indent info "• Models: $MODEL_CONFIG_FILE" 2
    log_indent info "• Providers: $PROVIDERS_CONFIG_FILE" 2
    log_indent info "• Application: $SCRIPT_DIR/config/app.conf" 2
    echo ""
    
    log_info "For help: $SCRIPT_DIR/main.sh --help"
}

# Uninstall command
cmd_uninstall() {
    log_header "Uninstallation Process"
    
    echo "This will remove Claude Model Switcher and all its components."
    echo -n "Are you sure you want to continue? [y/N]: "
    read -r confirmation
    
    case "$confirmation" in
        [yY]|[yY][eE][sS])
            log_progress "Proceeding with uninstallation..."
            ;;
        *)
            log_info "Uninstallation cancelled"
            return 0
            ;;
    esac
    
    # Remove shell integration
    local current_shell
    current_shell=$(basename "$SHELL")
    local rc_file
    
    case "$current_shell" in
        bash) rc_file="$HOME/.bashrc" ;;
        zsh) rc_file="$HOME/.zshrc" ;;
        *) rc_file="$HOME/.profile" ;;
    esac
    
    if [ -f "$rc_file" ]; then
        if grep -q "$SHELL_CONFIG_MARKER" "$rc_file"; then
            log_progress "Removing shell integration..."
            
            # Create backup
            local backup_file="$rc_file.uninstall_backup.$(date +%Y%m%d_%H%M%S)"
            cp "$rc_file" "$backup_file"
            
            # Remove configuration block
            sed -i "/$SHELL_CONFIG_MARKER/,/$SHELL_CONFIG_END_MARKER/d" "$rc_file"
            log_success "Shell integration removed. Backup: $backup_file"
        fi
    fi
    
    # Remove switcher directory
    if [ -d "$SWITCHER_DIR" ]; then
        log_progress "Removing switcher directory: $SWITCHER_DIR"
        rm -rf "$SWITCHER_DIR"
        
        # After removing the directory, disable file logging to avoid errors
        # since the log directory no longer exists
        export LOGGER_FILE=""
        
        log_success "Switcher directory removed"
    fi
    
    # Optionally remove Claude Code (ask user)
    echo -n "Do you want to remove Claude Code CLI as well? [y/N]: "
    read -r remove_claude
    
    case "$remove_claude" in
        [yY]|[yY][eE][sS])
            uninstall_claude_code "" "true"
            ;;
        *)
            log_info "Claude Code CLI preserved"
            ;;
    esac
    
    log_success "🎉 Uninstallation completed successfully"
    log_info "Please restart your terminal for changes to take effect"
    
    return 0
}

# Status command
cmd_status() {
    log_header "System Status"
    
    # System requirements
    log_progress "Checking system requirements..."
    validate_system_requirements
    echo ""
    
    # Node.js status
    log_progress "Checking Node.js..."
    if validate_nodejs; then
        local node_version
        node_version=$(node -v 2>/dev/null)
        log_success "Node.js: $node_version"
    else
        log_warn "Node.js: Not installed or version too old"
    fi
    echo ""
    
    # Claude Code status
    log_progress "Checking Claude Code..."
    if validate_claude_code; then
        local claude_version
        claude_version=$(claude --version 2>/dev/null)
        log_success "Claude Code: $claude_version"
    else
        log_warn "Claude Code: Not installed"
    fi
    echo ""
    
    # Model configuration
    log_progress "Checking model configuration..."
    get_model_status
    echo ""
    
    # Configuration files
    log_progress "Checking configuration files..."
    local config_files=(
        "$SCRIPT_DIR/config/app.conf"
        "$SCRIPT_DIR/config/models.conf"
        "$SCRIPT_DIR/config/providers.conf"
    )
    
    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            log_indent success "$(basename "$config_file"): Found" 2
        else
            log_indent error "$(basename "$config_file"): Missing" 2
        fi
    done
    
    return 0
}

# Help command
cmd_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION - Modular Architecture

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    install         Full installation process (Node.js + Claude Code + Shell integration)
    uninstall       Remove Claude Model Switcher and optionally Claude Code
    status          Show system and component status
    list-models     List all available models
    use-model       Switch to a specific model
    add-model       Add a new model to configuration
    remove-model    Remove a model from configuration
    update          Update Claude Code to latest version
    test            Run system tests
    help            Show this help message

EXAMPLES:
    # Full installation
    $0 install

    # List available models
    $0 list-models

    # Switch to a model
    $0 use-model kimi

    # Add a custom model
    $0 add-model my-model openai gpt-4 gpt-3.5-turbo "8K tokens" "Custom GPT-4 configuration"

    # Check system status
    $0 status

    # Uninstall everything
    $0 uninstall

SHELL FUNCTIONS (available after installation):
    list_models     List available models
    use_model       Switch to a model

CONFIGURATION:
    • Application: $SCRIPT_DIR/config/app.conf
    • Models: $SCRIPT_DIR/config/models.conf
    • Providers: $SCRIPT_DIR/config/providers.conf

For more information, visit: https://github.com/your-repo/claude-model-switcher
EOF
}

# --- Command Line Interface ---

# Parse command line arguments
parse_arguments() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        "install")
            cmd_install "$@"
            ;;
        "uninstall")
            cmd_uninstall "$@"
            ;;
        "status")
            cmd_status "$@"
            ;;
        "list-models")
            list_models_impl "$@"
            ;;
        "use-model")
            use_model_impl "$@"
            ;;
        "add-model")
            add_model "$@"
            ;;
        "remove-model")
            remove_model "$@"
            ;;
        "update")
            update_claude_code "$@"
            ;;
        "test")
            cmd_test "$@"
            ;;
        "help"|"--help"|"-h")
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

# Test command
cmd_test() {
    log_header "System Tests"
    
    local errors=0
    
    # Test Node.js
    if ! test_nodejs_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test Claude Code
    if ! test_claude_installation; then
        ((errors++))
    fi
    echo ""
    
    # Test configuration
    log_progress "Testing configuration..."
    if ! validate_configuration_completeness; then
        ((errors++))
    fi
    echo ""
    
    if [ $errors -eq 0 ]; then
        log_success "🎉 All tests passed!"
        return 0
    else
        log_error "❌ Tests failed with $errors errors"
        return 1
    fi
}

# --- Main Execution ---

main() {
    # Initialize system
    if ! initialize_system; then
        echo "❌ Failed to initialize system"
        exit 1
    fi
    
    # Parse and execute command
    parse_arguments "$@"
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi


```

`claude-model-switcher/tests/bdd/test_user_scenarios.sh`:

```sh
#!/bin/bash

# BDD Tests - User Scenarios

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger first
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    source "$PROJECT_DIR/lib/managers/model_manager.sh"
    
    # Create mock environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    
    # Setup configuration
    mkdir -p "$CONFIG_DIR"
    cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
    config_load_all "$CONFIG_DIR"
}

# Scenario: User wants to list available models
describe "BDD Scenario: Listing Available Models"

context "Given that the system is properly configured"

it "should have model configuration loaded"
assert_success "Model configuration should be loaded" "[ \${#MODEL_PROVIDERS[@]} -gt 0 ]"

context "When the user runs list_models command"

it "should display available models without errors"
# Capture output to verify content
output=$(list_models 2>&1)
assert_success "list_models should execute successfully" "list_models >/dev/null 2>&1"

it "should show model information in table format"
output=$(list_models 2>&1)
assert_contains "Output should contain table header" "$output" "Alias"
assert_contains "Output should contain provider column" "$output" "Provider"
assert_contains "Output should contain kimi model" "$output" "kimi"
assert_contains "Output should contain glm4 model" "$output" "glm4"

# Scenario: User wants to switch to a model (dry run)
describe "BDD Scenario: Model Switching (Validation Only)"

context "Given that models are configured"

it "should validate model alias before switching"
assert_success "Valid alias should pass validation" "validate_model_alias 'kimi'"
assert_failure "Invalid alias should fail validation" "validate_model_alias 'invalid@model'"

context "When user provides a valid model alias"

it "should find the model in configuration"
source "$MODEL_CONFIG_FILE"
assert_success "kimi model should exist in configuration" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"

it "should validate the provider"
provider="${MODEL_PROVIDERS[kimi]}"
assert_success "Provider should be valid" "validate_provider_name '$provider' '$AVAILABLE_PROVIDERS'"

# Scenario: User adds a custom model
describe "BDD Scenario: Adding Custom Model"

context "Given that the user wants to add a new model"

it "should validate new model parameters"
assert_success "New alias should be valid" "validate_model_alias 'custom-model'"
assert_success "Provider should be valid" "validate_provider_name 'moonshot' '$AVAILABLE_PROVIDERS'"

context "When the user adds the model"

it "should accept valid model configuration"
# Test the validation logic that would be used in add_model function
alias="custom-model"
provider="moonshot"
main_model="custom-api-model"
fast_model="custom-api-model-fast"
context="100K tokens"
description="Custom test model"

assert_success "All parameters should validate" "
    validate_model_alias '$alias' && 
    validate_provider_name '$provider' '$AVAILABLE_PROVIDERS' &&
    [ -n '$main_model' ] &&
    [ -n '$fast_model' ]
"

# Scenario: System health check
describe "BDD Scenario: System Health Check"

context "Given that the system is installed"

it "should have all required directories"
config_validate_environment >/dev/null 2>&1
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

context "When checking configuration files"

it "should have all required configuration files"
assert_file_exists "App config should exist" "$CONFIG_DIR/app.conf"
assert_file_exists "Models config should exist" "$CONFIG_DIR/models.conf"
assert_file_exists "Providers config should exist" "$CONFIG_DIR/providers.conf"

context "When validating configuration content"

it "should have valid configuration syntax"
assert_success "App config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/app.conf'"
assert_success "Models config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/models.conf'"
assert_success "Providers config should have valid syntax" "config_validate_syntax '$CONFIG_DIR/providers.conf'"

# Scenario: Error handling
describe "BDD Scenario: Error Handling"

context "Given that user provides invalid input"

it "should handle empty model alias gracefully"
# This should fail gracefully, not crash
assert_failure "Empty alias should be rejected" "validate_model_alias ''"

it "should handle unknown model alias gracefully"
# Load config first
source "$MODEL_CONFIG_FILE"
# Check for non-existent model
assert_equals "Unknown model should return empty provider" "" "${MODEL_PROVIDERS[nonexistent]}"

context "When configuration files are missing"

it "should handle missing config files gracefully"
# Test with non-existent config file
assert_failure "Missing config file should fail gracefully" "config_load '/nonexistent/path/config.conf'"
```

`claude-model-switcher/tests/integration/test_installation.sh`:

```sh
#!/bin/bash

# Integration Tests for Installation Process

setup_all() {
    # Initialize test environment variables first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="INFO"
    export USE_EMOJIS="false"
    mkdir -p "$LOG_DIR"
    
    # Source app configuration first
    source "$PROJECT_DIR/config/app.conf"
    
    # Source and initialize logger
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Source other modules after logger is ready
    source "$PROJECT_DIR/lib/core/config_loader.sh"
    source "$PROJECT_DIR/lib/core/validator.sh"
    
    # Create mock installation environment
    export MOCK_HOME="$TEMP_DIR/mock_home"
    mkdir -p "$MOCK_HOME"
    
    # Override paths for testing (force override after app.conf)
    export SWITCHER_DIR="$MOCK_HOME/.claude/claude-model-switcher"
    export CONFIG_DIR="$SWITCHER_DIR/config"
    export LIB_DIR="$SWITCHER_DIR/lib"
    export MEMORY_DIR="$SWITCHER_DIR/memory"
    export MODEL_CONFIG_FILE="$CONFIG_DIR/models.conf"
    

}

teardown_all() {
    # Clean up mock environment
    rm -rf "$MOCK_HOME"
}

# Test configuration loading
describe "Integration Tests - Configuration System"

context "When loading configurations"

it "should load all configuration files successfully"
# Copy config files to test environment
mkdir -p "$CONFIG_DIR"
cp "$PROJECT_DIR/config"/*.conf "$CONFIG_DIR/"
assert_success "All configurations should load" "config_load_all \"$CONFIG_DIR\""

it "should validate configuration completeness"
# Use the absolute path from setup_all to avoid variable override issues
test_config_dir="$TEMP_DIR/mock_home/.claude/claude-model-switcher/config"
test_config_validation() {
    local config_dir="$1"
    config_load_all "$config_dir" "true" && validate_configuration_completeness
}
assert_success "Configuration should be complete" "test_config_validation '$test_config_dir'"

# Test directory structure creation
describe "Integration Tests - Directory Structure"

context "When creating directory structure"

it "should create all required directories"
assert_success "Environment validation should create directories" "config_validate_environment"

it "should create switcher directory"
assert_dir_exists "Switcher directory should exist" "$SWITCHER_DIR"

it "should create config directory"
assert_dir_exists "Config directory should exist" "$CONFIG_DIR"

it "should create memory directory"
assert_dir_exists "Memory directory should exist" "$MEMORY_DIR"

it "should create log directory"
assert_dir_exists "Log directory should exist" "$LOG_DIR"

# Test model configuration
describe "Integration Tests - Model Configuration"

context "When working with model configuration"

it "should load model definitions"
assert_success "Model configuration should load" "config_load '$MODEL_CONFIG_FILE'"

it "should have default models configured"
# Source the models config to check arrays
source "$MODEL_CONFIG_FILE"
assert_success "Should have kimi model" "[ -n \"\${MODEL_PROVIDERS[kimi]}\" ]"
assert_success "Should have glm4 model" "[ -n \"\${MODEL_PROVIDERS[glm4]}\" ]"

# Test system validation
describe "Integration Tests - System Validation"

context "When validating system requirements"

it "should validate bash version"
assert_success "Bash version should be valid" "validate_shell_type"

it "should check required commands"
assert_success "Required commands should be available" "command -v curl && command -v sed && command -v grep"
```

`claude-model-switcher/tests/results/test_report.txt`:

```txt
Claude Model Switcher - Test Report
Generated: Tue Aug 19 02:20:26 UTC 2025

TEST SUMMARY:
=============
Total Tests: 86
Passed: 86
Failed: 0
Skipped: 0

PASS RATE: 100%

RESULT: PASSED

```

`claude-model-switcher/tests/test_runner.sh`:

```sh
#!/bin/bash

# Test Runner - Simple TDD/BDD Framework for Bash
# Supports unit tests, integration tests, and BDD scenarios

# Test framework configuration
TEST_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$TEST_DIR")"
RESULTS_DIR="$TEST_DIR/results"
TEMP_DIR="$TEST_DIR/temp"

# Test statistics
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test framework functions

# Initialize test environment
test_init() {
    echo -e "${BLUE}🧪 Initializing Test Environment${NC}"
    
    # Create necessary directories
    mkdir -p "$RESULTS_DIR"
    mkdir -p "$TEMP_DIR"
    
    # Clean up previous test results
    rm -f "$RESULTS_DIR"/*.log
    rm -rf "$TEMP_DIR"/*
    
    # Initialize test statistics
    TESTS_TOTAL=0
    TESTS_PASSED=0
    TESTS_FAILED=0
    TESTS_SKIPPED=0
    
    echo "Test directory: $TEST_DIR"
    echo "Project directory: $PROJECT_DIR"
    echo "Results directory: $RESULTS_DIR"
    echo ""
}

# Test assertion functions

# Assert that a command succeeds
assert_success() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ✓ $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Command: $command"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a command fails
assert_failure() {
    local description="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  ✗ $description... "
    
    if eval "$command" >/dev/null 2>&1; then
        echo -e "${RED}FAIL${NC}"
        echo "    Expected command to fail: $command"
        ((TESTS_FAILED++))
        return 1
    else
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    fi
}

# Assert that two strings are equal
assert_equals() {
    local description="$1"
    local expected="$2"
    local actual="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  = $description... "
    
    if [ "$expected" = "$actual" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Expected: '$expected'"
        echo "    Actual: '$actual'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a file exists
assert_file_exists() {
    local description="$1"
    local file_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  📁 $description... "
    
    if [ -f "$file_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    File not found: $file_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a directory exists
assert_dir_exists() {
    local description="$1"
    local dir_path="$2"
    
    ((TESTS_TOTAL++))
    
    echo -n "  📂 $description... "
    
    if [ -d "$dir_path" ]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    Directory not found: $dir_path"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Assert that a string contains a substring
assert_contains() {
    local description="$1"
    local haystack="$2"
    local needle="$3"
    
    ((TESTS_TOTAL++))
    
    echo -n "  🔍 $description... "
    
    if [[ "$haystack" == *"$needle"* ]]; then
        echo -e "${GREEN}PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}FAIL${NC}"
        echo "    String '$needle' not found in: '$haystack'"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Skip a test
skip_test() {
    local description="$1"
    local reason="$2"
    
    ((TESTS_TOTAL++))
    ((TESTS_SKIPPED++))
    
    echo -e "  ⏭️  $description... ${YELLOW}SKIP${NC}"
    if [ -n "$reason" ]; then
        echo "    Reason: $reason"
    fi
}

# BDD-style functions

# Describe a test suite
describe() {
    local suite_name="$1"
    echo -e "${BLUE}📋 $suite_name${NC}"
}

# Define a test context
context() {
    local context_name="$1"
    echo -e "${BLUE}  📝 $context_name${NC}"
}

# Define a test case
it() {
    local test_name="$1"
    echo -e "    🧪 $test_name"
}

# Test setup and teardown - empty by default
setup() { :; }
teardown() { :; }
setup_all() { :; }
teardown_all() { :; }

# Test discovery and execution

# Run a single test file
run_test_file() {
    local test_file="$1"
    
    if [ ! -f "$test_file" ]; then
        echo -e "${RED}❌ Test file not found: $test_file${NC}"
        return 1
    fi
    
    echo -e "${BLUE}🚀 Running test file: $(basename "$test_file")${NC}"
    echo ""
    
    # Reset functions for this test file
    setup_all() { :; }
    teardown_all() { :; }
    
    # Source the test file in a controlled manner
    set +e  # Don't exit on errors
    
    # First, source only the function definitions (setup_all, teardown_all)
    # by creating a temporary file with only function definitions
    local temp_functions_file="$TEMP_DIR/$(basename "$test_file").functions"
    
    # Extract function definitions from the test file
    awk '/^(setup_all|teardown_all)\(\)/ {p=1} p && /^}$/ {print; p=0; next} p' "$test_file" > "$temp_functions_file"
    
    # Source the function definitions
    source "$temp_functions_file"
    
    # If setup_all is defined, call it first
    if declare -f setup_all >/dev/null 2>&1; then
        setup_all 2>/dev/null || echo -e "${YELLOW}⚠️  Warning: setup_all failed${NC}"
    fi
    
    # Now source the full test file to run the tests
    source "$test_file"
    
    # If teardown_all is defined, call it
    if declare -f teardown_all >/dev/null 2>&1; then
        teardown_all 2>/dev/null || echo -e "${YELLOW}⚠️  Warning: teardown_all failed${NC}"
    fi
    
    # Clean up temporary file
    rm -f "$temp_functions_file"
    
    set -e  # Re-enable exit on error
    
    echo ""
    return 0
}

# Run all test files in a directory
run_test_directory() {
    local test_dir="$1"
    
    if [ ! -d "$test_dir" ]; then
        echo -e "${RED}❌ Test directory not found: $test_dir${NC}"
        return 1
    fi
    
    echo -e "${BLUE}🔍 Discovering tests in: $test_dir${NC}"
    
    local test_files
    test_files=($(find "$test_dir" -name "test_*.sh" -type f | sort))
    
    if [ ${#test_files[@]} -eq 0 ]; then
        echo -e "${YELLOW}⚠️  No test files found in: $test_dir${NC}"
        return 0
    fi
    
    echo "Found ${#test_files[@]} test files"
    echo ""
    
    for test_file in "${test_files[@]}"; do
        run_test_file "$test_file"
    done
}

# Generate test report
generate_report() {
    local report_file="$RESULTS_DIR/test_report.txt"
    
    echo "Generating test report: $report_file"
    
    cat > "$report_file" << EOF
Claude Model Switcher - Test Report
Generated: $(date)

TEST SUMMARY:
=============
Total Tests: $TESTS_TOTAL
Passed: $TESTS_PASSED
Failed: $TESTS_FAILED
Skipped: $TESTS_SKIPPED

PASS RATE: $(( TESTS_TOTAL > 0 ? TESTS_PASSED * 100 / TESTS_TOTAL : 0 ))%

EOF

    if [ $TESTS_FAILED -gt 0 ]; then
        echo "RESULT: FAILED" >> "$report_file"
    else
        echo "RESULT: PASSED" >> "$report_file"
    fi
    
    echo "Test report generated: $report_file"
}

# Display test summary
display_summary() {
    echo ""
    echo -e "${BLUE}📊 TEST SUMMARY${NC}"
    echo "================"
    echo "Total Tests: $TESTS_TOTAL"
    echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
    echo -e "Failed: ${RED}$TESTS_FAILED${NC}"
    echo -e "Skipped: ${YELLOW}$TESTS_SKIPPED${NC}"
    
    if [ $TESTS_TOTAL -gt 0 ]; then
        local pass_rate=$((TESTS_PASSED * 100 / TESTS_TOTAL))
        echo "Pass Rate: $pass_rate%"
    fi
    
    echo ""
    
    if [ $TESTS_FAILED -gt 0 ]; then
        echo -e "${RED}❌ TESTS FAILED${NC}"
        return 1
    else
        echo -e "${GREEN}✅ ALL TESTS PASSED${NC}"
        return 0
    fi
}

# Cleanup test environment
test_cleanup() {
    echo -e "${BLUE}🧹 Cleaning up test environment${NC}"
    
    # Remove temporary files
    rm -rf "$TEMP_DIR"/*
    
    echo "Cleanup completed"
}

# Main test runner function
run_tests() {
    local target="${1:-all}"
    
    test_init
    
    case "$target" in
        "all")
            run_test_directory "$TEST_DIR/unit"
            run_test_directory "$TEST_DIR/integration"
            run_test_directory "$TEST_DIR/bdd"
            ;;
        "unit")
            run_test_directory "$TEST_DIR/unit"
            ;;
        "integration")
            run_test_directory "$TEST_DIR/integration"
            ;;
        "bdd")
            run_test_directory "$TEST_DIR/bdd"
            ;;
        *)
            if [ -f "$target" ]; then
                run_test_file "$target"
            elif [ -d "$target" ]; then
                run_test_directory "$target"
            else
                echo -e "${RED}❌ Unknown test target: $target${NC}"
                return 1
            fi
            ;;
    esac
    
    generate_report
    display_summary
    local result=$?
    
    test_cleanup
    
    return $result
}

# Help function
show_help() {
    cat << EOF
Test Runner - TDD/BDD Framework for Claude Model Switcher

USAGE:
    $0 [TARGET]

TARGETS:
    all           Run all tests (unit + integration + bdd)
    unit          Run unit tests only
    integration   Run integration tests only
    bdd           Run BDD tests only
    <file>        Run a specific test file
    <directory>   Run all tests in a directory

EXAMPLES:
    $0                          # Run all tests
    $0 unit                     # Run unit tests
    $0 tests/unit/test_logger.sh # Run specific test file

TEST FILE NAMING:
    test_*.sh                   # Test files must start with 'test_'

ASSERTION FUNCTIONS:
    assert_success              # Command should succeed
    assert_failure              # Command should fail
    assert_equals               # String equality
    assert_file_exists          # File exists
    assert_dir_exists           # Directory exists
    assert_contains             # String contains substring
    skip_test                   # Skip a test

BDD FUNCTIONS:
    describe                    # Test suite description
    context                     # Test context
    it                          # Test case description

SETUP/TEARDOWN:
    setup                       # Run before each test
    teardown                    # Run after each test
    setup_all                   # Run once before all tests
    teardown_all                # Run once after all tests
EOF
}

# Main execution
main() {
    local command="${1:-all}"
    
    case "$command" in
        "help"|"--help"|"-h")
            show_help
            ;;
        *)
            run_tests "$command"
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

`claude-model-switcher/tests/unit/test_logger.sh`:

```sh
#!/bin/bash

# Unit Tests for Logger Module

# Setup test environment
setup_all() {
    # Create temporary log directory for testing
    TEST_LOG_DIR="$TEMP_DIR/logs"
    mkdir -p "$TEST_LOG_DIR"
    
    # Set test configuration before sourcing logger
    export LOG_DIR="$TEST_LOG_DIR"
    export LOG_FILE="$TEST_LOG_DIR/test.log"
    export LOG_LEVEL="DEBUG"
    export USE_EMOJIS="true"
    
    # Source the logger module after setting environment
    source "$PROJECT_DIR/lib/core/logger.sh"
    
    # Initialize logger
    logger_init
    
    # Verify initialization
    if [ ! -f "$LOG_FILE" ]; then
        touch "$LOG_FILE"
    fi
    
    # Export variables for test assertions
    export TEST_LOG_DIR
}

teardown_all() {
    # Clean up test logs
    rm -rf "$TEST_LOG_DIR"
}

# Test logger initialization
describe "Logger Module - Initialization"

context "When initializing logger"

it "should create log directory"
assert_dir_exists "Log directory should be created" "$TEST_LOG_DIR"

it "should create log file"
assert_file_exists "Log file should be created" "$LOG_FILE"

it "should set global variables"
assert_equals "LOGGER_FILE should be set" "$LOG_FILE" "$LOGGER_FILE"
assert_equals "LOGGER_LEVEL should be set" "DEBUG" "$LOGGER_LEVEL"

# Test logging functions
describe "Logger Module - Logging Functions"

context "When logging messages"

it "should log debug messages"
log_debug "Test debug message"
assert_success "Debug message should be logged" "grep 'Test debug message' '$LOG_FILE'"

it "should log info messages"
log_info "Test info message"
assert_success "Info message should be logged" "grep 'Test info message' '$LOG_FILE'"

it "should log warning messages"
log_warn "Test warning message"
assert_success "Warning message should be logged" "grep 'Test warning message' '$LOG_FILE'"

it "should log error messages"
log_error "Test error message"
assert_success "Error message should be logged" "grep 'Test error message' '$LOG_FILE'"

it "should log success messages"
log_success "Test success message"
assert_success "Success message should be logged" "grep 'Test success message' '$LOG_FILE'"

# Test log levels
describe "Logger Module - Log Levels"

context "When log level is INFO"

it "should not log debug messages when level is INFO"
export LOGGER_LEVEL="INFO"
log_debug "Debug message that should not appear"
assert_failure "Debug message should not be logged at INFO level" "grep 'Debug message that should not appear' '$LOG_FILE'"

it "should log info messages when level is INFO"
log_info "Info message that should appear"
assert_success "Info message should be logged at INFO level" "grep 'Info message that should appear' '$LOG_FILE'"

# Test log formatting
describe "Logger Module - Formatting"

context "When logging with timestamps"

it "should include timestamps in log file"
log_info "Timestamp test message"
assert_success "Log should contain timestamp" "grep '\\[.*\\] \\[INFO\\] Timestamp test message' '$LOG_FILE'"

# Test utility functions
describe "Logger Module - Utility Functions"

context "When using utility functions"

it "should create log separators"
log_separator "-" 10
assert_success "Log separator should be created" "grep -- '-----------*' '$LOG_FILE'"

it "should create log headers"
log_header "Test Header"
assert_success "Log header should be created" "grep 'Test Header' '$LOG_FILE'"
```

`claude-model-switcher/tests/unit/test_validator.sh`:

```sh
#!/bin/bash

# Unit Tests for Validator Module

setup_all() {
    # Initialize logger for testing first
    export LOG_DIR="$TEMP_DIR/logs"
    export LOG_FILE="$LOG_DIR/test.log"
    export LOG_LEVEL="ERROR"  # Reduce noise in tests
    export USE_EMOJIS="false"  # Reduce noise in test output
    mkdir -p "$LOG_DIR"
    
    # Source required modules in correct order
    source "$PROJECT_DIR/lib/core/logger.sh"
    logger_init
    
    # Ensure log file exists
    touch "$LOG_FILE"
    
    # Now source validator after logger is initialized
    source "$PROJECT_DIR/lib/core/validator.sh"
}

# Test model alias validation
describe "Validator Module - Model Alias Validation"

context "When validating model aliases"

it "should accept valid aliases"
assert_success "Valid alias 'kimi' should pass" "validate_model_alias 'kimi'"
assert_success "Valid alias 'glm4' should pass" "validate_model_alias 'glm4'"
assert_success "Valid alias 'my-model' should pass" "validate_model_alias 'my-model'"
assert_success "Valid alias 'model_123' should pass" "validate_model_alias 'model_123'"

it "should reject invalid aliases"
assert_failure "Empty alias should fail" "validate_model_alias ''"
assert_failure "Alias with spaces should fail" "validate_model_alias 'my model'"
assert_failure "Alias with special chars should fail" "validate_model_alias 'model@123'"
assert_failure "Too long alias should fail" "validate_model_alias 'this_is_a_very_long_model_alias_name'"

# Test provider name validation
describe "Validator Module - Provider Validation"

context "When validating provider names"

it "should accept valid providers"
export AVAILABLE_PROVIDERS="moonshot zhipu openai"
assert_success "Valid provider 'moonshot' should pass" "validate_provider_name 'moonshot'"
assert_success "Valid provider 'zhipu' should pass" "validate_provider_name 'zhipu'"

it "should reject invalid providers"
assert_failure "Empty provider should fail" "validate_provider_name ''"
assert_failure "Unknown provider should fail" "validate_provider_name 'unknown'"

# Test API key validation
describe "Validator Module - API Key Validation"

context "When validating API keys"

it "should accept valid API keys"
assert_success "Valid generic API key should pass" "validate_api_key 'sk-1234567890abcdef1234567890abcdef12345678'"
assert_success "Long API key should pass" "validate_api_key '1234567890abcdef1234567890abcdef12345678901234567890'"

it "should reject invalid API keys"
assert_failure "Empty API key should fail" "validate_api_key ''"
assert_failure "Too short API key should fail" "validate_api_key '123'"

# Test URL validation
describe "Validator Module - URL Validation"

context "When validating URLs"

it "should accept valid URLs"
assert_success "HTTPS URL should pass" "validate_url 'https://api.example.com'"
assert_success "HTTP URL should pass" "validate_url 'http://api.example.com'"
assert_success "URL with port should pass" "validate_url 'https://api.example.com:8080'"
assert_success "URL with path should pass" "validate_url 'https://api.example.com/v1/api'"

it "should reject invalid URLs"
assert_failure "Empty URL should fail" "validate_url ''"
assert_failure "Invalid protocol should fail" "validate_url 'ftp://example.com'"
assert_failure "No protocol should fail" "validate_url 'example.com'"
assert_failure "Invalid format should fail" "validate_url 'https://'"

# Test version validation
describe "Validator Module - Version Validation"

context "When validating version strings"

it "should accept valid versions"
assert_success "Semantic version should pass" "validate_version '1.0.0'"
assert_success "Version with pre-release should pass" "validate_version '1.0.0-alpha'"
assert_success "Version with build should pass" "validate_version '1.0.0-alpha.1'"

it "should reject invalid versions"
assert_failure "Empty version should fail" "validate_version ''"
assert_failure "Invalid format should fail" "validate_version '1.0'"
assert_failure "Non-numeric should fail" "validate_version 'v1.0.0'"

# Test file path validation
describe "Validator Module - File Path Validation"

context "When validating file paths"

it "should accept valid file paths"
assert_success "Absolute path should pass" "validate_file_path '/tmp/test.txt'"
assert_success "Relative path should pass" "validate_file_path 'config/app.conf'"

it "should reject invalid file paths"
assert_failure "Empty path should fail" "validate_file_path ''"

it "should check file existence when required"
# Create a test file
touch "$TEMP_DIR/existing_file.txt"
assert_success "Existing file should pass existence check" "validate_file_path '$TEMP_DIR/existing_file.txt' true"
assert_failure "Non-existing file should fail existence check" "validate_file_path '$TEMP_DIR/missing_file.txt' true"
```